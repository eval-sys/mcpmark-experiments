{
  "task_id": "executive_dashboard_automation",
  "task_name": "Executive Dashboard Automation",
  "category_id": "employees",
  "category_name": "Employees",
  "description": "Design automated reporting system with materialized views, stored procedures, and triggers for executive dashboard monitoring.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "stored procedures and functions",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Design a comprehensive reporting and automation system for executive dashboard and real-time monitoring. The executive team needs automated reports, data views, and trigger-based notifications to track key business metrics without manual intervention.\n\n## Your Tasks:\n\n1. **Create executive summary views** ‚Äî build three materialized views in the `employees` schema:\n   \n   **View 1: `exec_department_summary`**\n   * `department_name` (varchar) ‚Äî department name\n   * `total_employees` (integer) ‚Äî current active employee count\n   * `avg_salary` (decimal) ‚Äî average current salary\n   * `total_payroll` (bigint) ‚Äî total monthly payroll cost\n   * `manager_name` (varchar) ‚Äî current department manager name\n\n   **View 2: `exec_hiring_trends`**  \n   * `hire_year` (integer) ‚Äî year employees were hired\n   * `employees_hired` (integer) ‚Äî number hired that year\n   * `avg_starting_salary` (decimal) ‚Äî average first salary of hires that year\n   * `retention_rate` (decimal) ‚Äî percentage still employed\n   * `top_hiring_department` (varchar) ‚Äî department that hired the most that year\n\n   **View 3: `exec_salary_distribution`**\n   * `salary_band` (varchar) ‚Äî salary ranges ('30K-50K', '50K-70K', '70K-90K', '90K-110K', '110K+')  \n   * `employee_count` (integer) ‚Äî employees in this salary band\n   * `percentage_of_workforce` (decimal) ‚Äî percentage of total workforce\n   * `most_common_title` (varchar) ‚Äî most frequent job title in this band\n\n2. **Create stored procedure for report generation**:\n   \n   **Procedure: `generate_monthly_report(report_date DATE)`**\n   * Create a table `monthly_reports` with columns: report_id (auto-increment), report_date, department_count, total_employees (current active employees only), avg_salary, generated_at\n   * Insert one summary record using the report_date as identifier and current database statistics (not historical data for that date)\n   * Return the generated report_id\n\n3. **Create notification triggers**:\n   \n   **Trigger: `high_salary_alert`**\n   * Fires when a new salary record is inserted with amount > 120000\n   * Inserts alert into `salary_alerts` table with: employee_id, salary_amount, alert_date, status='new'\n\n4. **Insert test data to verify triggers**:\n   * Update employee 10001's current salary: first set their current salary record to_date='2024-01-31', then insert new salary record with amount 125000, from_date='2024-02-01', to_date='9999-01-01'\n   * Refresh all materialized views after inserting new data to ensure they reflect the updated information\n\n5. **Execute the stored procedure**:\n   * Call `generate_monthly_report('2024-01-01')` to create January report\n   * Query the generated report to verify execution\n\n6. **Create performance indexes**:\n   * Index on `salary_alerts.status` for alert processing\n   * Composite index on `monthly_reports(report_date, department_count)` for trend analysis",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 6: Reporting and Automation System\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.1 tolerance\n    For date types: convert to string for comparison\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, (Decimal, float, int)):\n            if abs(float(actual) - float(expected)) > 0.1:\n                return False\n        elif hasattr(actual, 'strftime'):  # datetime.date or datetime.datetime\n            if str(actual) != str(expected):\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_materialized_views(conn) -> bool:\n    \"\"\"Verify that materialized views were created and populated correctly.\"\"\"\n    with conn.cursor() as cur:\n        # Check if materialized views exist\n        cur.execute(\"\"\"\n            SELECT matviewname FROM pg_matviews \n            WHERE schemaname = 'employees' \n            AND matviewname IN ('exec_department_summary', 'exec_hiring_trends', 'exec_salary_distribution')\n            ORDER BY matviewname\n        \"\"\")\n        views = [row[0] for row in cur.fetchall()]\n        \n        expected_views = ['exec_department_summary', 'exec_hiring_trends', 'exec_salary_distribution']\n        if set(views) != set(expected_views):\n            print(f\"‚ùå Expected views {expected_views}, found {views}\")\n            return False\n        \n        # Check all departments' data accuracy\n        cur.execute(\"\"\"\n            SELECT department_name, total_employees, avg_salary, total_payroll, manager_name\n            FROM employees.exec_department_summary\n            ORDER BY department_name\n        \"\"\")\n        view_data = cur.fetchall()\n        \n        # Get actual data for all departments\n        cur.execute(\"\"\"\n            WITH current_salary AS (\n            SELECT employee_id, amount\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY s.employee_id\n                        ORDER BY s.from_date DESC, s.amount DESC\n                    ) AS rn\n                FROM employees.salary s\n                WHERE s.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            current_dept AS (\n            SELECT DISTINCT de.employee_id, de.department_id\n            FROM employees.department_employee de\n            WHERE de.to_date = DATE '9999-01-01'\n            ),\n            current_manager AS (\n            SELECT department_id,\n                    CONCAT(e.first_name, ' ', e.last_name) AS manager_name\n            FROM (\n                SELECT dm.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY dm.department_id\n                        ORDER BY dm.from_date DESC, dm.employee_id\n                    ) AS rn\n                FROM employees.department_manager dm\n                WHERE dm.to_date = DATE '9999-01-01'\n            ) dm\n            JOIN employees.employee e ON e.id = dm.employee_id\n            WHERE dm.rn = 1\n            )\n            SELECT\n            d.dept_name AS department_name,\n            COUNT(cd.employee_id)::INT AS total_employees,\n            AVG(cs.amount)::DECIMAL   AS avg_salary,\n            COALESCE(SUM(cs.amount), 0)::BIGINT AS total_payroll,\n            cm.manager_name\n            FROM employees.department d\n            LEFT JOIN current_dept   cd ON cd.department_id = d.id\n            LEFT JOIN current_salary cs ON cs.employee_id = cd.employee_id\n            LEFT JOIN current_manager cm ON cm.department_id = d.id\n            GROUP BY d.id, d.dept_name, cm.manager_name\n            ORDER BY d.dept_name;\n        \"\"\")\n        actual_data = cur.fetchall()\n        \n        if len(view_data) != len(actual_data):\n            print(f\"‚ùå Department count mismatch: view={len(view_data)}, actual={len(actual_data)}\")\n            return False\n            \n        for view_row, actual_row in zip(view_data, actual_data):\n            if not rows_match(view_row, actual_row):\n                print(f\"‚ùå Department summary data incorrect for {view_row[0]}: view={view_row}, actual={actual_row}\")\n                return False\n            \n        # Check all hiring trends data accuracy\n        cur.execute(\"\"\"\n            SELECT hire_year, employees_hired, avg_starting_salary, retention_rate, top_hiring_department\n            FROM employees.exec_hiring_trends\n            ORDER BY hire_year\n        \"\"\")\n        hiring_view_data = cur.fetchall()\n        \n        # Get actual data for all years\n        cur.execute(\"\"\"\n            WITH first_salary AS (\n            SELECT employee_id, amount AS starting_salary\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY s.employee_id\n                        ORDER BY s.from_date ASC, s.amount ASC\n                    ) AS rn\n                FROM employees.salary s\n            ) x\n            WHERE rn = 1\n            ),\n            current_emp AS (\n            SELECT DISTINCT s.employee_id\n            FROM employees.salary s\n            WHERE s.to_date = DATE '9999-01-01'\n            ),\n            first_dept AS (\n            SELECT employee_id, department_id\n            FROM (\n                SELECT de.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY de.employee_id\n                        ORDER BY de.from_date ASC, de.department_id\n                    ) AS rn\n                FROM employees.department_employee de\n            ) x\n            WHERE rn = 1\n            ),\n            hire_base AS (\n            SELECT e.id AS employee_id,\n                    EXTRACT(YEAR FROM e.hire_date)::INT AS hire_year\n            FROM employees.employee e\n            WHERE e.hire_date IS NOT NULL\n            ),\n            hire_by_dept_year AS (\n            SELECT hb.hire_year,\n                    d.dept_name,\n                    COUNT(*) AS dept_hires\n            FROM hire_base hb\n            LEFT JOIN first_dept fd ON fd.employee_id = hb.employee_id\n            LEFT JOIN employees.department d ON d.id = fd.department_id\n            GROUP BY hb.hire_year, d.dept_name\n            ),\n            top_dept_per_year AS (\n            SELECT hire_year,\n                    dept_name AS top_hiring_department\n            FROM (\n                SELECT hire_year, dept_name, dept_hires,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY hire_year\n                        ORDER BY dept_hires DESC NULLS LAST, dept_name\n                    ) AS rn\n                FROM hire_by_dept_year\n            ) t\n            WHERE rn = 1\n            )\n            SELECT\n            hb.hire_year,\n            COUNT(*)::INT AS employees_hired,\n            AVG(fs.starting_salary)::DECIMAL AS avg_starting_salary,\n            (COUNT(ce.employee_id)::DECIMAL / NULLIF(COUNT(*), 0) * 100) AS retention_rate,\n            td.top_hiring_department\n            FROM hire_base hb\n            LEFT JOIN first_salary fs   ON fs.employee_id = hb.employee_id\n            LEFT JOIN current_emp ce    ON ce.employee_id = hb.employee_id\n            LEFT JOIN top_dept_per_year td ON td.hire_year = hb.hire_year\n            GROUP BY hb.hire_year, td.top_hiring_department\n            ORDER BY hb.hire_year;\n        \"\"\")\n        actual_hiring_data = cur.fetchall()\n        \n        if len(hiring_view_data) != len(actual_hiring_data):\n            print(f\"‚ùå Hiring trends count mismatch: view={len(hiring_view_data)}, actual={len(actual_hiring_data)}\")\n            return False\n        \n        for hiring_view, actual_hiring in zip(hiring_view_data, actual_hiring_data):\n            # Now compare all 5 fields including top_hiring_department\n            if not rows_match(hiring_view, actual_hiring):\n                print(f\"‚ùå Hiring trends data incorrect for year {hiring_view[0]}: view={hiring_view}, actual={actual_hiring}\")\n                return False\n                \n            \n        # Check all salary bands' data accuracy\n        cur.execute(\"\"\"\n            WITH band_order AS (\n            SELECT '30K-50K' AS band, 1 AS ord UNION ALL\n            SELECT '50K-70K', 2 UNION ALL\n            SELECT '70K-90K', 3 UNION ALL\n            SELECT '90K-110K',4 UNION ALL\n            SELECT '110K+',   5\n            )\n            SELECT salary_band, employee_count, percentage_of_workforce, most_common_title\n            FROM employees.exec_salary_distribution v\n            JOIN band_order bo ON bo.band = v.salary_band\n            ORDER BY bo.ord;\n        \"\"\")\n        view_bands = cur.fetchall()\n        \n        # Calculate actual data for all bands\n        cur.execute(\"\"\"\n            WITH current_salary AS (\n            SELECT employee_id, amount\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY s.employee_id\n                        ORDER BY s.from_date DESC, s.amount DESC\n                    ) AS rn\n                FROM employees.salary s\n                WHERE s.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            current_title AS (\n            SELECT employee_id, title\n            FROM (\n                SELECT t.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY t.employee_id\n                        ORDER BY t.from_date DESC, t.title\n                    ) AS rn\n                FROM employees.title t\n                WHERE t.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            base AS (\n            SELECT cs.employee_id, cs.amount, COALESCE(ct.title, 'Unknown') AS title\n            FROM current_salary cs\n            LEFT JOIN current_title ct ON ct.employee_id = cs.employee_id\n            ),\n            banded AS (\n            SELECT\n                CASE\n                WHEN amount <  50000 THEN '30K-50K'\n                WHEN amount <  70000 THEN '50K-70K'\n                WHEN amount <  90000 THEN '70K-90K'\n                WHEN amount < 110000 THEN '90K-110K'\n                ELSE '110K+'\n                END AS salary_band,\n                title,\n                employee_id\n            FROM base\n            ),\n            band_counts AS (\n            SELECT salary_band, COUNT(DISTINCT employee_id) AS employee_count\n            FROM banded\n            GROUP BY salary_band\n            ),\n            title_counts AS (\n            SELECT salary_band, title, COUNT(DISTINCT employee_id) AS title_count\n            FROM banded\n            GROUP BY salary_band, title\n            ),\n            top_titles AS (\n            SELECT salary_band, title AS most_common_title\n            FROM (\n                SELECT salary_band, title, title_count,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY salary_band\n                        ORDER BY title_count DESC, title\n                    ) AS rn\n                FROM title_counts\n            ) t\n            WHERE rn = 1\n            ),\n            workforce AS (\n            SELECT COUNT(DISTINCT employee_id) AS total_current\n            FROM base\n            ),\n            band_order AS (\n            SELECT '30K-50K' AS band, 1 AS ord UNION ALL\n            SELECT '50K-70K', 2 UNION ALL\n            SELECT '70K-90K', 3 UNION ALL\n            SELECT '90K-110K', 4 UNION ALL\n            SELECT '110K+',   5\n            )\n            SELECT\n            bc.salary_band,\n            bc.employee_count::INT AS employee_count,\n            (bc.employee_count::DECIMAL / NULLIF((SELECT total_current FROM workforce), 0) * 100) AS percentage_of_workforce,\n            tt.most_common_title\n            FROM band_counts bc\n            LEFT JOIN top_titles tt ON tt.salary_band = bc.salary_band\n            LEFT JOIN band_order  bo ON bo.band = bc.salary_band\n            ORDER BY bo.ord;        \n        \"\"\")\n        actual_bands = cur.fetchall()\n        \n        # Compare view data with actual data\n        if len(view_bands) != len(actual_bands):\n            print(f\"‚ùå Salary band count mismatch: view={len(view_bands)}, actual={len(actual_bands)}\")\n            return False\n            \n        for view_band, actual_band in zip(view_bands, actual_bands):\n            if not rows_match(view_band, actual_band):\n                print(f\"‚ùå Salary band {actual_band[0]} data incorrect: view={view_band}, actual={actual_band}\")\n                return False\n            \n        print(\"‚úÖ All materialized views are created and contain correct data\")\n        return True\n\ndef verify_stored_procedures(conn) -> bool:\n    \"\"\"Verify that stored procedure was created.\"\"\"\n    with conn.cursor() as cur:\n        # Check if procedure exists\n        cur.execute(\"\"\"\n            SELECT routine_name FROM information_schema.routines \n            WHERE routine_schema = 'employees' \n            AND routine_type = 'FUNCTION'\n            AND routine_name = 'generate_monthly_report'\n        \"\"\")\n        procedures = [row[0] for row in cur.fetchall()]\n        \n        if 'generate_monthly_report' not in procedures:\n            print(\"‚ùå generate_monthly_report procedure not found\")\n            return False\n            \n        # Check if monthly_reports table exists with correct structure\n        cur.execute(\"\"\"\n            SELECT COUNT(*) FROM information_schema.columns \n            WHERE table_schema = 'employees' AND table_name = 'monthly_reports'\n            AND column_name IN ('report_id', 'report_date', 'department_count', 'total_employees', 'avg_salary', 'generated_at')\n        \"\"\")\n        report_columns = cur.fetchone()[0]\n        if report_columns != 6:\n            print(\"‚ùå monthly_reports table missing required columns\")\n            return False\n            \n        print(\"‚úÖ Stored procedure and supporting table are created\")\n        return True\n\ndef verify_triggers(conn) -> bool:\n    \"\"\"Verify that triggers were created and fired correctly.\"\"\"\n    with conn.cursor() as cur:\n        # Check if triggers exist\n        cur.execute(\"\"\"\n            SELECT trigger_name FROM information_schema.triggers \n            WHERE trigger_schema = 'employees'\n            AND trigger_name = 'high_salary_alert'\n        \"\"\")\n        triggers = [row[0] for row in cur.fetchall()]\n        \n        if 'high_salary_alert' not in triggers:\n            print(\"‚ùå high_salary_alert trigger not found\")\n            return False\n            \n        # Check if trigger support table exists\n        cur.execute(\"\"\"\n            SELECT table_name FROM information_schema.tables \n            WHERE table_schema = 'employees' \n            AND table_name = 'salary_alerts'\n        \"\"\")\n        trigger_tables = [row[0] for row in cur.fetchall()]\n        \n        if 'salary_alerts' not in trigger_tables:\n            print(\"‚ùå salary_alerts table not found\")\n            return False\n            \n        # Check if the old salary record was properly closed\n        cur.execute(\"\"\"\n            SELECT COUNT(*) FROM employees.salary \n            WHERE employee_id = 10001 AND to_date = '2024-01-31'\n        \"\"\")\n        old_salary_count = cur.fetchone()[0]\n        if old_salary_count == 0:\n            print(\"‚ùå Old salary record for employee 10001 was not properly closed with to_date='2024-01-31'\")\n            return False\n            \n        # Check if the new salary record was inserted\n        cur.execute(\"\"\"\n            SELECT COUNT(*) FROM employees.salary \n            WHERE employee_id = 10001 AND amount = 125000 \n            AND from_date = '2024-02-01' AND to_date = '9999-01-01'\n        \"\"\")\n        new_salary_count = cur.fetchone()[0]\n        if new_salary_count == 0:\n            print(\"‚ùå New salary record for employee 10001 with amount 125000 was not inserted\")\n            return False\n            \n        # Check if high salary alert was triggered with specific details\n        cur.execute(\"\"\"\n            SELECT COUNT(*) FROM employees.salary_alerts \n            WHERE employee_id = 10001 AND salary_amount = 125000 AND status = 'new'\n        \"\"\")\n        alert_count = cur.fetchone()[0]\n        if alert_count == 0:\n            print(\"‚ùå High salary alert was not triggered correctly for employee 10001 with amount 125000\")\n            return False\n            \n        print(\"‚úÖ Trigger is created and functioning correctly\")\n        return True\n\ndef verify_procedure_execution(conn) -> bool:\n    \"\"\"Verify that stored procedure was executed with correct data.\"\"\"\n    with conn.cursor() as cur:\n        # Check if monthly report data matches actual statistics\n        cur.execute(\"\"\"\n            SELECT department_count, total_employees, avg_salary\n            FROM employees.monthly_reports \n            WHERE report_date = '2024-01-01'\n        \"\"\")\n        report_data = cur.fetchone()\n        if not report_data:\n            print(\"‚ùå Monthly report for 2024-01-01 was not generated\")\n            return False\n            \n        # Get actual current statistics to compare\n        cur.execute(\"\"\"\nWITH current_salary AS (\n  SELECT employee_id, amount\n  FROM (\n    SELECT s.*,\n           ROW_NUMBER() OVER (\n             PARTITION BY s.employee_id\n             ORDER BY s.from_date DESC, s.amount DESC\n           ) AS rn\n    FROM employees.salary s\n    WHERE s.to_date = DATE '9999-01-01'\n  ) x\n  WHERE rn = 1\n),\ncurrent_dept AS (\n  SELECT DISTINCT de.employee_id, de.department_id\n  FROM employees.department_employee de\n  WHERE de.to_date = DATE '9999-01-01'\n),\nbase AS (\n  SELECT cd.department_id, cs.employee_id, cs.amount\n  FROM current_dept cd\n  JOIN current_salary cs ON cs.employee_id = cd.employee_id\n)\nSELECT\n  COUNT(DISTINCT department_id)        AS actual_dept_count,\n  COUNT(DISTINCT employee_id)          AS actual_total_employees,\n  AVG(amount)::DECIMAL                 AS actual_avg_salary\nFROM base;\n        \"\"\")\n        actual_stats = cur.fetchone()\n        \n        # Compare report data with actual data  \n        if not rows_match(report_data, actual_stats):\n            print(f\"‚ùå Monthly report data incorrect: expected {actual_stats}, got {report_data}\")\n            return False\n                \n        print(\"‚úÖ Stored procedure executed with correct data\")\n        return True\n\ndef verify_indexes(conn) -> bool:\n    \"\"\"Verify that performance indexes were created.\"\"\"\n    with conn.cursor() as cur:\n        # Check for required indexes\n        cur.execute(\"\"\"\n            SELECT indexname FROM pg_indexes \n            WHERE schemaname = 'employees' \n            AND tablename IN ('salary_alerts', 'monthly_reports')\n            AND indexname LIKE 'idx_%'\n            ORDER BY indexname\n        \"\"\")\n        indexes = [row[0] for row in cur.fetchall()]\n        \n        # Should have at least 2 indexes created\n        if len(indexes) < 2:\n            print(f\"‚ùå Expected at least 2 performance indexes, found {len(indexes)}\")\n            return False\n            \n        print(\"‚úÖ Performance indexes are created\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify all components\n        success = (\n            verify_materialized_views(conn) and \n            verify_stored_procedures(conn) and\n            verify_triggers(conn) and\n            verify_procedure_execution(conn) and\n            verify_indexes(conn)\n        )\n\n        conn.close()\n\n        if success:\n            print(\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}