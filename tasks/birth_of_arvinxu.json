{
  "task_id": "birth_of_arvinxu",
  "task_name": "Birth Of Arvinxu",
  "category_id": "web_search",
  "category_name": "Web Search",
  "description": "Search for biographical information about X profile arvin17x across multiple web sources, extract birth year data, verify information accuracy, and compile findings.",
  "author": "Wenbin Xu",
  "created_at": "2025-08-18",
  "difficulty": "L3",
  "tags": [
    "search aggregation",
    "data extraction"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": null,
    "stateContent": null,
    "stateUrl": null,
    "stateOriginalUrl": null
  },
  "instruction": "# Web Search Task\n\nUse Playwright MCP tools to search for information about the X profile https://x.com/arvin17x and find out when this person was born.\n\n## Requirements:\n\nExtract the answer in specific format:\n   - just year,like 1990, 2001\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Playwright web search task.\n\nSimple verification that checks if the AI agent found the correct answer.\nThe expected ground truth answer is configured at the top of the file.\n\"\"\"\n\nimport sys\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import Dict, Any\n\n# =============================================================================\n# CONFIGURATION\n# =============================================================================\n\n# Expected ground truth answer (case insensitive)\nEXPECTED_GROUND_TRUTH = \"1995\"\nACCEPTED_ANSWERS = []\n\n# =============================================================================\n# MCP RESULT PARSING\n# =============================================================================\n\n\ndef get_working_directory() -> Path:\n    \"\"\"Get the working directory where messages.json should be.\"\"\"\n    # Priority 1: Use MCP_MESSAGES path if available (most reliable)\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    if messages_path and Path(messages_path).exists():\n        return Path(messages_path).parent.resolve()\n\n    # Priority 2: Use PLAYWRIGHT_WORK_DIR environment variable\n    work_dir = os.getenv(\"PLAYWRIGHT_WORK_DIR\")\n    if work_dir:\n        work_path = Path(work_dir).resolve()\n        if (work_path / \"messages.json\").exists():\n            return work_path\n\n    # Priority 3: Check current directory (fallback)\n    current_dir = Path.cwd()\n    if (current_dir / \"messages.json\").exists():\n        return current_dir\n\n    # Priority 4: Default fallback\n    return Path(\".\").resolve()\n\n\ndef parse_ai_results(work_dir: Path) -> Dict[str, Any]:\n    \"\"\"Parse the AI agent's results from messages.json\"\"\"\n    messages_file = work_dir / \"messages.json\"\n    if not messages_file.exists():\n        return {\"success\": False, \"error\": \"No messages.json found\"}\n\n    try:\n        with open(messages_file, \"r\", encoding=\"utf-8\") as f:\n            messages = json.load(f)\n    except (json.JSONDecodeError, IOError) as e:\n        return {\"success\": False, \"error\": f\"Failed to read messages.json: {e}\"}\n\n    # Look for expected answer in the AI's responses\n    found_answer = False\n    ai_responses = []\n\n    for message in messages:\n        if message.get(\"role\") == \"assistant\":\n            content = str(message.get(\"content\", \"\"))\n\n            # Handle both string and list content formats\n            if isinstance(message.get(\"content\"), list):\n                content = \" \".join(\n                    item.get(\"text\", \"\") if isinstance(item, dict) else str(item)\n                    for item in message.get(\"content\", [])\n                )\n\n            ai_responses.append(content)\n            content_lower = content.lower()\n\n            # Check if expected answer was found (case insensitive)\n            if any(answer in content_lower for answer in ACCEPTED_ANSWERS):\n                found_answer = True\n\n    return {\n        \"success\": True,\n        \"found_answer\": found_answer,\n        \"ai_responses\": ai_responses,\n        \"total_responses\": len(ai_responses),\n    }\n\n\n# =============================================================================\n# MAIN VERIFICATION\n# =============================================================================\n\n\ndef verify_task() -> bool:\n    \"\"\"Verify the AI agent found the correct answer\"\"\"\n\n    # Parse AI agent results\n    work_dir = get_working_directory()\n    print(f\"| Working directory: {work_dir}\")\n\n    ai_results = parse_ai_results(work_dir)\n\n    if not ai_results[\"success\"]:\n        print(f\"| ‚ùå Could not parse AI results: {ai_results.get('error')}\")\n        return False\n\n    if ai_results[\"found_answer\"]:\n        print(f\"| AI agent correctly identified: {EXPECTED_GROUND_TRUTH}\")\n        return True\n    else:\n        print(f\"| AI agent did not find the correct answer: {EXPECTED_GROUND_TRUTH}\")\n        return False\n\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    try:\n        success = verify_task()\n        sys.exit(0 if success else 1)\n    except Exception as e:\n        print(f\"\\nüí• Verification error: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}