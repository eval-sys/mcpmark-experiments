{
  "task_id": "critical_issue_hotfix_workflow",
  "task_name": "Critical Issue Hotfix Workflow",
  "category_id": "claude-code",
  "category_name": "Claude Code",
  "description": "Implement a critical issue hotfix workflow for memory and context management issues with proper PR management and issue tracking.",
  "author": "Zijian Wu",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "issue management",
    "pr workflows"
  ],
  "mcp": [
    "github"
  ],
  "meta_data": {
    "stateType": "url",
    "stateContent": null,
    "stateUrl": "https://github.com/mcpmark-source/claude-code",
    "stateOriginalUrl": "https://github.com/anthropics/claude-code"
  },
  "instruction": "I need you to implement a comprehensive critical issue hotfix workflow for the repository that demonstrates advanced PR management, selective merging, and issue resolution tracking.\n\n**Step 1: Create Critical Bug Tracking Issue**\nCreate a new issue with:\n- Title: \"CRITICAL: Memory and Context Management Issues - Hotfix Tracking\"\n- Body must include:\n  - A \"## Critical Issues\" heading listing issues #49 and #46\n  - A \"## Impact Assessment\" heading describing user impact\n  - A \"## Resolution Strategy\" heading with planned approach\n  - References to existing issues #49, #46, and #47 using \"#\" notation\n  - Keywords: \"memory exhaustion\", \"context auto-compact\", \"JavaScript heap\", \"hotfix priority\"\n\n**Step 2: Create Memory Optimization Hotfix Branch**\nCreate a new branch called 'hotfix/memory-optimization-v1.0.72' from the main branch.\n\n**Step 3: Implement Memory Management Documentation**\nOn the hotfix branch, create the file `docs/MEMORY_OPTIMIZATION.md` with this exact content:\n```markdown\n# Memory Optimization Guide for Claude Code v1.0.72\n\n## Overview\nThis document addresses critical memory issues identified in issues #49 and #46.\n\n## Memory Management Issues\n\n### Context Auto-Compact Problem (Issue #49)\n- **Root Cause**: Context management stuck at 0% completion\n- **Impact**: Tool becomes unusable on macOS platforms\n- **Solution**: Implement progressive context cleanup with configurable thresholds\n\n### JavaScript Heap Exhaustion (Issue #46)\n- **Root Cause**: Memory allocation failure during large MCP operations\n- **Impact**: Complete Claude Code crash requiring restart\n- **Solution**: Add streaming data processing and garbage collection optimization\n\n## Optimization Strategies\n\n### Immediate Fixes\n1. **Context Buffer Management**\n   - Implement 10MB default context buffer limit\n   - Add automatic context pruning at 80% threshold\n   - Enable manual context reset via `/memory-reset` command\n\n2. **MCP Operation Streaming**\n   - Process large datasets in 1MB chunks\n   - Implement backpressure for MongoDB operations\n   - Add memory usage monitoring and alerts\n\n### Configuration Options\n```json\n{\n  \"memory\": {\n    \"contextBufferLimit\": \"10MB\",\n    \"autoCompactThreshold\": 0.8,\n    \"streamingChunkSize\": \"1MB\",\n    \"gcOptimization\": true\n  }\n}\n```\n\n## Related Issues\n- Fixes issue #49: Context auto-compact functionality\n- Addresses issue #46: JavaScript heap out of memory crashes\n- Related to issue #47: Cross-project hook execution problems\n```\n```\n\n**Step 4: Create Pull Request with Issue Cross-References**\nCreate a pull request from 'hotfix/memory-optimization-v1.0.72' to 'main' with:\n- Title: \"HOTFIX: Critical memory optimization for issues #49 and #46\"\n- Body must include:\n  - A \"## Summary\" heading describing the memory fixes\n  - A \"## Critical Issues Addressed\" heading listing specific problems\n  - A \"## Documentation Changes\" heading describing the new guide\n  - \"Addresses #49\" and \"Addresses #46\" pattern linking to existing issues\n  - Reference to your tracking issue using \"Tracked in #[ISSUE_NUMBER]\"\n  - Keywords: \"memory optimization\", \"context management\", \"heap exhaustion\", \"v1.0.72 hotfix\"\n\n**Step 5: Update and Merge PR #51 (Statsig Logging)**\nFor the existing PR #51:\n- Update the PR description to include technical implementation details\n- Add a \"## Technical Implementation\" section mentioning \"event logging integration\"\n- Add keywords: \"workflow enhancement\", \"issue management automation\", \"logging consistency\"\n- Merge the PR using the squash merge method\n\n**Step 6: Add Implementation Comment to Tracking Issue**\nAdd a comment to your original tracking issue with:\n- Reference to your hotfix PR using \"PR #[NUMBER]\" pattern\n- Reference to actions taken on PR #51\n- Technical details about the memory optimization approach\n- Keywords: \"context buffer management\", \"streaming optimization\", \"progressive cleanup\"\n- Mention of configuration options and thresholds\n\n**Step 7: Close Tracking Issue with Resolution Summary**\nClose your tracking issue by updating its state to 'closed' with:\n- A final comment summarizing completed actions\n- Reference to merged PR #51 and pending hotfix PR\n- Keywords: \"hotfix deployment\", \"memory issues resolved\", \"documentation updated\"",
  "verify": "import sys\nimport os\nimport requests\nfrom typing import Dict, List, Optional, Tuple\nimport base64\nfrom dotenv import load_dotenv\n\n\ndef _get_github_api(\n    endpoint: str, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> Tuple[bool, Optional[Dict]]:\n    \"\"\"Make a GET request to GitHub API and return (success, response).\"\"\"\n    url = f\"https://api.github.com/repos/{org}/{repo}/{endpoint}\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return True, response.json()\n        elif response.status_code == 404:\n            return False, None\n        else:\n            print(f\"API error for {endpoint}: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Exception for {endpoint}: {e}\", file=sys.stderr)\n        return False, None\n\n\ndef _check_branch_exists(\n    branch_name: str, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> bool:\n    \"\"\"Verify that a branch exists in the repository.\"\"\"\n    success, _ = _get_github_api(f\"branches/{branch_name}\", headers, org, repo)\n    return success\n\n\ndef _get_file_content(\n    file_path: str,\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"claude-code\",\n    ref: str = \"main\",\n) -> Optional[str]:\n    \"\"\"Get the content of a file from the repository.\"\"\"\n    success, result = _get_github_api(\n        f\"contents/{file_path}?ref={ref}\", headers, org, repo\n    )\n    if not success or not result:\n        return None\n\n    try:\n        content = base64.b64decode(result.get(\"content\", \"\")).decode(\"utf-8\")\n        return content\n    except Exception as e:\n        print(f\"Content decode error for {file_path}: {e}\", file=sys.stderr)\n        return None\n\n\ndef _find_issue_by_title_keyword(\n    keyword: str, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> Optional[Dict]:\n    \"\"\"Find an issue by title keyword and return the issue data.\"\"\"\n    # Check both open and closed issues\n    for state in [\"open\", \"closed\"]:\n        success, issues = _get_github_api(\n            f\"issues?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and issues:\n            for issue in issues:\n                if keyword.lower() in issue.get(\"title\", \"\").lower():\n                    return issue\n    return None\n\n\ndef _find_pr_by_title_keyword(\n    keyword: str, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> Optional[Dict]:\n    \"\"\"Find a PR by title keyword and return the PR data.\"\"\"\n    # Check both open and closed PRs\n    for state in [\"open\", \"closed\"]:\n        success, prs = _get_github_api(\n            f\"pulls?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and prs:\n            for pr in prs:\n                if keyword.lower() in pr.get(\"title\", \"\").lower():\n                    return pr\n    return None\n\n\ndef _get_pr_by_number(\n    pr_number: int, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> Optional[Dict]:\n    \"\"\"Get a specific PR by number.\"\"\"\n    success, pr = _get_github_api(f\"pulls/{pr_number}\", headers, org, repo)\n    if success:\n        return pr\n    return None\n\n\ndef _check_issue_references(text: str, reference_numbers: List[str]) -> bool:\n    \"\"\"Check if text contains references to specified issue numbers.\"\"\"\n    if not text:\n        return False\n\n    return all(f\"#{ref}\" in text for ref in reference_numbers)\n\n\ndef _check_addresses_pattern(pr_body: str, issue_numbers: List[str]) -> bool:\n    \"\"\"Check if PR body contains 'Addresses #X' pattern for specified issues.\"\"\"\n    if not pr_body:\n        return False\n\n    return all(\n        f\"Addresses #{num}\" in pr_body or f\"addresses #{num}\" in pr_body\n        for num in issue_numbers\n    )\n\n\ndef _get_issue_comments(\n    issue_number: int, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> List[Dict]:\n    \"\"\"Get all comments for an issue.\"\"\"\n    success, comments = _get_github_api(\n        f\"issues/{issue_number}/comments\", headers, org, repo\n    )\n    if success and comments:\n        return comments\n    return []\n\n\ndef _get_pr_reviews(\n    pr_number: int, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> List[Dict]:\n    \"\"\"Get all reviews for a PR.\"\"\"\n    success, reviews = _get_github_api(f\"pulls/{pr_number}/reviews\", headers, org, repo)\n    if success and reviews:\n        return reviews\n    return []\n\n\ndef _check_title_keywords(title: str, required_keywords: List[str]) -> bool:\n    \"\"\"Check if title contains all required keywords.\"\"\"\n    return all(keyword.lower() in title.lower() for keyword in required_keywords)\n\n\ndef _check_headings_and_keywords(\n    body: str, headings: List[str], keywords: List[str]\n) -> bool:\n    \"\"\"Check if body contains required headings and keywords.\"\"\"\n    has_headings = all(heading in body for heading in headings)\n    has_keywords = all(keyword.lower() in body.lower() for keyword in keywords)\n    return has_headings and has_keywords\n\n\ndef _check_exact_file_content(content: str, expected_sections: List[str]) -> bool:\n    \"\"\"Check if file content contains expected sections.\"\"\"\n    return all(section in content for section in expected_sections)\n\n\ndef verify() -> bool:\n    \"\"\"\n    Programmatically verify that the critical issue hotfix workflow meets the\n    requirements described in description.md.\n    \"\"\"\n    # Configuration constants\n    HOTFIX_BRANCH_NAME = \"hotfix/memory-optimization-v1.0.72\"\n    TRACKING_ISSUE_KEYWORD = \"Memory and Context Management Issues\"\n    HOTFIX_PR_KEYWORD = \"HOTFIX: Critical memory optimization\"\n\n    # Expected file content sections\n    MEMORY_DOC_SECTIONS = [\n        \"# Memory Optimization Guide for Claude Code v1.0.72\",\n        \"## Overview\",\n        \"### Context Auto-Compact Problem (Issue #49)\",\n        \"### JavaScript Heap Exhaustion (Issue #46)\",\n        \"## Optimization Strategies\",\n        \"### Immediate Fixes\",\n        \"### Configuration Options\",\n        \"## Related Issues\",\n    ]\n\n    # Issue content requirements\n    TRACKING_ISSUE_TITLE_KEYWORDS = [\n        \"CRITICAL\",\n        \"Memory\",\n        \"Context Management\",\n        \"Hotfix Tracking\",\n    ]\n    TRACKING_ISSUE_REFERENCE_NUMBERS = [\"49\", \"46\", \"47\"]\n    TRACKING_ISSUE_HEADINGS = [\n        \"## Critical Issues\",\n        \"## Impact Assessment\",\n        \"## Resolution Strategy\",\n    ]\n    TRACKING_ISSUE_KEYWORDS = [\n        \"memory exhaustion\",\n        \"context auto-compact\",\n        \"JavaScript heap\",\n        \"hotfix priority\",\n    ]\n\n    # PR content requirements\n    HOTFIX_PR_TITLE_KEYWORDS = [\n        \"HOTFIX\",\n        \"Critical memory optimization\",\n        \"issues #49\",\n        \"#46\",\n    ]\n    HOTFIX_PR_ADDRESSES_NUMBERS = [\"49\", \"46\"]\n    HOTFIX_PR_HEADINGS = [\n        \"## Summary\",\n        \"## Critical Issues Addressed\",\n        \"## Documentation Changes\",\n    ]\n    HOTFIX_PR_KEYWORDS = [\n        \"memory optimization\",\n        \"context management\",\n        \"heap exhaustion\",\n        \"v1.0.72 hotfix\",\n    ]\n\n    # PR #51 update requirements\n    PR51_UPDATE_KEYWORDS = [\n        \"Technical Implementation\",\n        \"event logging integration\",\n        \"workflow enhancement\",\n    ]\n\n    # Issue comment requirements\n    ISSUE_COMMENT_KEYWORDS = [\n        \"context buffer management\",\n        \"streaming optimization\",\n        \"progressive cleanup\",\n    ]\n\n    # Load environment variables from .mcp_env\n    load_dotenv(\".mcp_env\")\n\n    # Get GitHub token and org\n    github_token = os.environ.get(\"MCP_GITHUB_TOKEN\")\n    github_org = os.environ.get(\"GITHUB_EVAL_ORG\")\n\n    if not github_token:\n        print(\"Error: MCP_GITHUB_TOKEN environment variable not set\", file=sys.stderr)\n        return False\n\n    if not github_org:\n        print(\"Error: GITHUB_EVAL_ORG environment variable not set\", file=sys.stderr)\n        return False\n\n    headers = {\n        \"Authorization\": f\"Bearer {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    # Run verification checks\n    print(\"Verifying critical issue hotfix workflow completion...\")\n\n    # 1. Check that hotfix branch exists\n    print(\"1. Verifying hotfix branch exists...\")\n    if not _check_branch_exists(HOTFIX_BRANCH_NAME, headers, github_org):\n        print(f\"Error: Branch '{HOTFIX_BRANCH_NAME}' not found\", file=sys.stderr)\n        return False\n    print(\"✓ Hotfix branch created\")\n\n    # 2. Check that the memory optimization documentation exists with exact content\n    print(\"2. Verifying MEMORY_OPTIMIZATION.md documentation...\")\n    memory_doc_content = _get_file_content(\n        \"docs/MEMORY_OPTIMIZATION.md\",\n        headers,\n        github_org,\n        \"claude-code\",\n        HOTFIX_BRANCH_NAME,\n    )\n    if not memory_doc_content:\n        print(\n            \"Error: docs/MEMORY_OPTIMIZATION.md not found in hotfix branch\",\n            file=sys.stderr,\n        )\n        return False\n\n    if not _check_exact_file_content(memory_doc_content, MEMORY_DOC_SECTIONS):\n        print(\n            \"Error: MEMORY_OPTIMIZATION.md missing required sections or content\",\n            file=sys.stderr,\n        )\n        return False\n    print(\"✓ Memory optimization documentation created with correct content\")\n\n    # 3. Find and verify the tracking issue\n    print(\"3. Verifying tracking issue creation and content...\")\n    tracking_issue = _find_issue_by_title_keyword(\n        TRACKING_ISSUE_KEYWORD, headers, github_org\n    )\n    if not tracking_issue:\n        print(\n            f\"Error: Tracking issue with keyword '{TRACKING_ISSUE_KEYWORD}' not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    tracking_issue_number = tracking_issue.get(\"number\")\n    tracking_issue_title = tracking_issue.get(\"title\", \"\")\n    tracking_issue_body = tracking_issue.get(\"body\", \"\")\n\n    # Check tracking issue title keywords\n    if not _check_title_keywords(tracking_issue_title, TRACKING_ISSUE_TITLE_KEYWORDS):\n        print(\"Error: Tracking issue title missing required keywords\", file=sys.stderr)\n        return False\n\n    # Check tracking issue headings, content and references\n    if not _check_headings_and_keywords(\n        tracking_issue_body, TRACKING_ISSUE_HEADINGS, TRACKING_ISSUE_KEYWORDS\n    ):\n        print(\n            \"Error: Tracking issue missing required headings or keywords\",\n            file=sys.stderr,\n        )\n        return False\n\n    if not _check_issue_references(\n        tracking_issue_body, TRACKING_ISSUE_REFERENCE_NUMBERS\n    ):\n        print(\n            \"Error: Tracking issue does not reference required issues #49, #46, #47\",\n            file=sys.stderr,\n        )\n        return False\n    print(\"✓ Tracking issue created with correct content and references\")\n\n    # 4. Find and verify the hotfix PR\n    print(\"4. Verifying hotfix pull request creation and content...\")\n    hotfix_pr = _find_pr_by_title_keyword(HOTFIX_PR_KEYWORD, headers, github_org)\n    if not hotfix_pr:\n        print(\n            f\"Error: Hotfix PR with keyword '{HOTFIX_PR_KEYWORD}' not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    hotfix_pr_number = hotfix_pr.get(\"number\")\n    hotfix_pr_title = hotfix_pr.get(\"title\", \"\")\n    hotfix_pr_body = hotfix_pr.get(\"body\", \"\")\n\n    # Check hotfix PR title keywords\n    if not _check_title_keywords(hotfix_pr_title, HOTFIX_PR_TITLE_KEYWORDS):\n        print(\"Error: Hotfix PR title missing required keywords\", file=sys.stderr)\n        return False\n\n    # Check hotfix PR headings and content\n    if not _check_headings_and_keywords(\n        hotfix_pr_body, HOTFIX_PR_HEADINGS, HOTFIX_PR_KEYWORDS\n    ):\n        print(\"Error: Hotfix PR missing required headings or keywords\", file=sys.stderr)\n        return False\n\n    # Check hotfix PR addresses pattern\n    if not _check_addresses_pattern(hotfix_pr_body, HOTFIX_PR_ADDRESSES_NUMBERS):\n        print(\n            \"Error: Hotfix PR does not properly address issues #49 and #46\",\n            file=sys.stderr,\n        )\n        return False\n\n    # Check reference to tracking issue\n    if f\"#{tracking_issue_number}\" not in hotfix_pr_body:\n        print(\n            f\"Error: Hotfix PR does not reference tracking issue #{tracking_issue_number}\",\n            file=sys.stderr,\n        )\n        return False\n    print(\"✓ Hotfix PR created with correct content and references\")\n\n    # 5. Check PR #51 has been updated and merged\n    print(\"5. Verifying PR #51 update and merge...\")\n    pr51 = _get_pr_by_number(51, headers, github_org)\n    if not pr51:\n        print(\"Error: PR #51 not found\", file=sys.stderr)\n        return False\n\n    pr51_body = pr51.get(\"body\", \"\")\n    pr51_state = pr51.get(\"state\", \"\")\n\n    # Check PR #51 has been updated with required content\n    if not _check_headings_and_keywords(\n        pr51_body, [\"## Technical Implementation\"], PR51_UPDATE_KEYWORDS\n    ):\n        print(\n            \"Error: PR #51 missing updated technical implementation section\",\n            file=sys.stderr,\n        )\n        return False\n\n    # Check PR #51 has been merged\n    if pr51_state != \"closed\" or not pr51.get(\"merged_at\"):\n        print(\"Error: PR #51 has not been merged\", file=sys.stderr)\n        return False\n    print(\"✓ PR #51 updated and merged successfully\")\n\n    # 6. Check tracking issue has implementation comment\n    print(\"6. Verifying tracking issue implementation comment...\")\n    tracking_issue_comments = _get_issue_comments(\n        tracking_issue_number, headers, github_org\n    )\n\n    has_implementation_comment = False\n    for comment in tracking_issue_comments:\n        body = comment.get(\"body\", \"\")\n        has_pr_ref = f\"PR #{hotfix_pr_number}\" in body\n        has_pr51_ref = \"PR #51\" in body\n        has_keywords = all(\n            keyword.lower() in body.lower() for keyword in ISSUE_COMMENT_KEYWORDS\n        )\n        if has_pr_ref and has_pr51_ref and has_keywords:\n            has_implementation_comment = True\n            break\n\n    if not has_implementation_comment:\n        print(\n            f\"Error: Tracking issue #{tracking_issue_number} missing implementation comment with required references and keywords\",\n            file=sys.stderr,\n        )\n        return False\n    print(\"✓ Tracking issue has implementation comment with PR references\")\n\n    # 7. Check tracking issue is closed\n    print(\"7. Verifying tracking issue closure...\")\n    if tracking_issue.get(\"state\") != \"closed\":\n        print(\n            f\"Error: Tracking issue #{tracking_issue_number} is not closed\",\n            file=sys.stderr,\n        )\n        return False\n    print(\"✓ Tracking issue closed successfully\")\n\n    print(\"\\n✅ All verification checks passed!\")\n    print(\"Critical issue hotfix workflow completed successfully:\")\n    print(f\"  - Tracking Issue #{tracking_issue_number}: {tracking_issue.get('title')}\")\n    print(f\"  - Hotfix PR #{hotfix_pr_number}: {hotfix_pr.get('title')}\")\n    print(f\"  - Branch: {HOTFIX_BRANCH_NAME}\")\n    print(\"  - PR #51 merged: ✓\")\n    print(\"  - Memory optimization documentation: ✓\")\n\n    return True\n\n\nif __name__ == \"__main__\":\n    success = verify()\n    sys.exit(0 if success else 1)\n"
}