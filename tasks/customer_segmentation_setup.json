{
  "task_id": "customer_segmentation_setup",
  "task_name": "Customer Segmentation Setup",
  "category_id": "shopping_admin",
  "category_name": "Shopping Admin",
  "description": "Configure customer segmentation system in admin panel by defining demographic criteria, creating behavior-based segments, implementing targeting rules, and setting up automated marketing workflows.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "content submission",
    "inventory management"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "Perform customer segmentation setup and analysis in the Magento Admin panel to establish new customer groups and manage customer profiles.\n\n**Task Requirements:**\n\n1. Access the Magento Admin panel to begin customer segmentation setup. if need to login, login with username 'admin' and password 'admin1234'\n\n2. Establish baseline metrics for customer groups:\n   - Record the exact number shown in \"records found\" at the top of the grid\n   - This will be your initial groups count\n\n3. Create a specialized customer group for European premium customers:\n   - Group Name: Premium Europe\n   - Tax Class: Retail Customer\n   - Save the group\n\n4. Verify the customer group creation was successful:\n   - After saving, return to Customer Groups list\n   - Record the new total shown in \"records found\"\n\n5. Establish baseline metrics for all customers database:\n   - Record the exact number shown in \"records found\" at the top of the grid\n   - This will be your initial customers count\n\n6. Add a representative customer to the new premium group:\n   - Create a new customer with the following details:\n   - First Name: Isabella\n   - Last Name: Romano\n   - Email: isabella.romano@premium.eu\n   - Associate to Website: Main Website\n   - Group: The group you just created\n   - Save the customer\n\n7. Verify the customer creation was successful:\n   - After saving, return to All Customers list\n   - Record the new total shown in \"records found\"\n\n8. Analyze recent customer activity patterns:\n   - Navigate to Dashboard\n   - Look at the \"Last Orders\" section\n   - Record the customer name in the last row of the table\n\n9. Compile all your findings and output them in the following exact format:\n\n```\n<answer>\nInitialGroups|count\nFinalGroups|count  \nInitialCustomers|count\nFinalCustomers|count\nLastOrderCustomer|name\n</answer>\n```\n\n**Example Output:**\n```\n<answer>\nInitialGroups|XX\nFinalGroups|XX\nInitialCustomers|XXX\nFinalCustomers|XXX\nLastOrderCustomer|XXX\n</answer>\n```",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nimport json\nfrom pathlib import Path\nfrom playwright.async_api import (\n    async_playwright,\n    TimeoutError as PlaywrightTimeoutError,\n)\n\n# 从环境变量读取 base_url（shopping_admin 会注入 http://localhost:7780/admin），默认回退到本地\nBASE_URL = os.getenv(\"WEBARENA_BASE_URL\", \"http://localhost:7780/admin\").rstrip(\"/\")\n\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n\n    try:\n        with open(messages_path, \"r\") as f:\n            messages = json.load(f)\n\n        # Find the last assistant message\n        for message in reversed(messages):\n            if (\n                message.get(\"role\") == \"assistant\"\n                and message.get(\"status\") == \"completed\"\n            ):\n                content = message.get(\"content\", [])\n                for item in content:\n                    if item.get(\"type\") == \"output_text\":\n                        return item.get(\"text\", \"\")\n\n        print(\"Warning: No assistant response found in messages\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef parse_answer_format(text):\n    \"\"\"\n    Parse the <answer>...</answer> format from the agent's output.\n    Returns a dictionary with the parsed values.\n    \"\"\"\n    if not text:\n        return None\n\n    # Look for <answer>...</answer> pattern\n    match = re.search(r\"<answer>(.*?)</answer>\", text, re.IGNORECASE | re.DOTALL)\n    if not match:\n        return None\n\n    answer_content = match.group(1).strip()\n\n    # Parse each line\n    result = {}\n    lines = answer_content.split(\"\\n\")\n\n    if len(lines) != 5:\n        print(f\"Error: Expected 5 lines in answer, got {len(lines)}\", file=sys.stderr)\n        return None\n\n    for line in lines:\n        if \"|\" in line:\n            key, value = line.split(\"|\", 1)\n            result[key.strip()] = value.strip()\n\n    return result\n\n\ndef load_expected_answer(label_path):\n    \"\"\"\n    Load the expected answer from label.txt file.\n    Returns a dictionary with the expected values.\n    \"\"\"\n    try:\n        with open(label_path, \"r\") as f:\n            lines = f.read().strip().split(\"\\n\")\n\n        expected = {}\n        for line in lines:\n            if \"|\" in line:\n                key, value = line.split(\"|\", 1)\n                expected[key.strip()] = value.strip()\n\n        return expected\n    except Exception as e:\n        print(f\"Error reading label file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef compare_answers(model_answer, expected_answer):\n    \"\"\"\n    Compare the model's answer with the expected answer.\n    Returns True if all key information matches, False otherwise.\n    \"\"\"\n    if not model_answer or not expected_answer:\n        return False\n\n    # Check each expected key\n    mismatches = []\n    for key, expected_value in expected_answer.items():\n        model_value = model_answer.get(key, \"\")\n\n        # Exact match for all fields\n        if model_value != expected_value:\n            mismatches.append(\n                f\"{key}: expected '{expected_value}', got '{model_value}'\"\n            )\n\n    if mismatches:\n        print(\"\\n=== Answer Comparison Mismatches ===\", file=sys.stderr)\n        for mismatch in mismatches:\n            print(f\"✗ {mismatch}\", file=sys.stderr)\n        return False\n\n    print(\"\\n=== Answer Comparison ===\", file=sys.stderr)\n    print(\"✓ All key information matches the expected answer\", file=sys.stderr)\n    return True\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the customer segmentation setup task has been completed correctly.\n    First checks the model's answer against the expected label,\n    then verifies the actual state in the Magento Admin.\n    \"\"\"\n    # Get the label file path\n    label_path = Path(__file__).parent / \"label.txt\"\n\n    # Load expected answer\n    expected_answer = load_expected_answer(label_path)\n    if not expected_answer:\n        print(\"Error: Could not load expected answer from label.txt\", file=sys.stderr)\n        return False\n\n    # Get model's response from MCP_MESSAGES\n    model_response = get_model_response()\n    if model_response:\n        print(\"Found model response, parsing answer format...\", file=sys.stderr)\n        model_answer = parse_answer_format(model_response)\n\n        if model_answer:\n            print(\"\\n=== Model Answer Parsed ===\", file=sys.stderr)\n            for key, value in model_answer.items():\n                print(f\"{key}: {value}\", file=sys.stderr)\n\n            # Compare answers\n            answer_match = compare_answers(model_answer, expected_answer)\n            if not answer_match:\n                print(\"\\nModel answer does not match expected answer\", file=sys.stderr)\n                return False\n            print(\"\\n✓ Model answer matches expected answer\", file=sys.stderr)\n        else:\n            print(\n                \"Warning: Could not parse answer format from model response\",\n                file=sys.stderr,\n            )\n            print(\"Will proceed with browser verification only\", file=sys.stderr)\n    else:\n        print(\n            \"No model response found, proceeding with browser verification\",\n            file=sys.stderr,\n        )\n\n    # Browser verification for actual state\n    print(\"\\n=== Starting Browser Verification ===\", file=sys.stderr)\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=True)\n        context = await browser.new_context()\n        page = await context.new_page()\n\n        try:\n            # Navigate to Magento Admin\n            print(\"Navigating to Magento Admin...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/\", wait_until=\"networkidle\"\n            )\n\n            # Check if already logged in, if not, login\n            if \"dashboard\" not in page.url.lower():\n                print(\"Logging into Magento Admin...\", file=sys.stderr)\n                await page.fill('input[name=\"login[username]\"]', \"admin\")\n                await page.fill('input[name=\"login[password]\"]', \"admin1234\")\n                await page.click('button:has-text(\"Sign in\")')\n                await page.wait_for_load_state(\"networkidle\")\n\n                if \"dashboard\" not in page.url.lower():\n                    print(\"Error: Login failed\", file=sys.stderr)\n                    return False\n\n            print(\"Successfully logged into Magento Admin\", file=sys.stderr)\n\n            # 1. Verify Customer Groups\n            print(\"\\nVerifying Customer Groups...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/customer/group/\",\n                wait_until=\"networkidle\",\n            )\n            await page.wait_for_timeout(2000)  # Wait for grid to load\n\n            # Check for Premium Europe group\n            premium_europe_exists = (\n                await page.locator(\"text=Premium Europe\").count() > 0\n            )\n            if premium_europe_exists:\n                print(\"✓ Found 'Premium Europe' customer group\", file=sys.stderr)\n\n                # Check if it has Retail Customer tax class\n                # Look for Premium Europe row and check its tax class\n                premium_row = page.locator('tr:has-text(\"Premium Europe\")')\n                if await premium_row.count() > 0:\n                    tax_class_text = await premium_row.locator(\"td\").nth(2).inner_text()\n                    if \"Retail Customer\" in tax_class_text:\n                        print(\n                            \"✓ Premium Europe has 'Retail Customer' tax class\",\n                            file=sys.stderr,\n                        )\n                    else:\n                        print(\n                            f\"Warning: Premium Europe tax class is '{tax_class_text}'\",\n                            file=sys.stderr,\n                        )\n            else:\n                print(\"✗ 'Premium Europe' customer group not found\", file=sys.stderr)\n                return False\n\n            # Check total groups count\n            records_found = page.locator(\"text=records found\").first\n            if await records_found.count() > 0:\n                count_text = await records_found.inner_text()\n                print(f\"Customer Groups count: {count_text}\", file=sys.stderr)\n\n                # Extract number\n                import re\n\n                match = re.search(r\"(\\d+)\\s+records found\", count_text)\n                if match:\n                    groups_count = int(match.group(1))\n                    print(f\"✓ Customer groups count is {groups_count}\", file=sys.stderr)\n\n            # 2. Verify Customer\n            print(\"\\nVerifying Customer Isabella Romano...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/customer/index/\",\n                wait_until=\"networkidle\",\n            )\n            await page.wait_for_timeout(3000)  # Wait for grid to load\n\n            # Check total customers count\n            customer_records = page.locator(\"text=records found\").first\n            if await customer_records.count() > 0:\n                count_text = await customer_records.inner_text()\n                print(f\"Customers count: {count_text}\", file=sys.stderr)\n\n                # Extract number\n                match = re.search(r\"(\\d+)\\s+records found\", count_text)\n                if match:\n                    customers_count = int(match.group(1))\n                    print(\n                        f\"✓ Total customers count is {customers_count}\", file=sys.stderr\n                    )\n\n                    # Verify against expected answer if available\n                    if expected_answer and \"FinalCustomers\" in expected_answer:\n                        expected_final = int(expected_answer[\"FinalCustomers\"])\n                        if customers_count == expected_final:\n                            print(\n                                f\"✓ Customer count matches expected: {customers_count}\",\n                                file=sys.stderr,\n                            )\n                        else:\n                            print(\n                                f\"✗ Customer count mismatch: Expected {expected_final} customers, found {customers_count}\",\n                                file=sys.stderr,\n                            )\n                            return False\n\n            # Wait for the customer grid to load properly\n            await page.wait_for_timeout(5000)\n            \n            # Check if Isabella Romano exists - first wait for grid to load\n            grid_loaded = False\n            for i in range(3):\n                # Look for grid container and wait for it to populate\n                grid_container = page.locator(\".admin__data-grid-outer-wrap, .data-grid, table\").first\n                if await grid_container.count() > 0:\n                    # Check if there are customer rows loaded\n                    customer_rows = page.locator(\"td[data-column='email'], td:has-text('@')\")\n                    if await customer_rows.count() > 0:\n                        grid_loaded = True\n                        break\n                await page.wait_for_timeout(2000)\n            \n            if not grid_loaded:\n                print(\"✗ Customer grid failed to load properly\", file=sys.stderr)\n                return False\n            \n            # Now check if Isabella Romano exists in the loaded grid\n            isabella_exists = (\n                await page.locator(\"text=isabella.romano@premium.eu\").count() > 0\n            )\n            \n            if not isabella_exists:\n                # Try searching for the customer to be more thorough\n                try:\n                    search_box = page.locator('input[placeholder*=\"Search by keyword\"], input[name=\"search\"], [data-role=\"search\"]').first\n                    if await search_box.count() > 0:\n                        await search_box.clear()\n                        await search_box.fill(\"isabella.romano@premium.eu\")\n                        await page.keyboard.press(\"Enter\")\n                        await page.wait_for_load_state(\"networkidle\")\n                        await page.wait_for_timeout(3000)\n                        \n                        # Check again after search\n                        isabella_exists = (\n                            await page.locator(\"text=isabella.romano@premium.eu\").count() > 0\n                        )\n                        \n                        # Also check for \"No records found\" message\n                        no_records = await page.locator(\"text=We couldn't find any records., text=No records found\").count() > 0\n                        if no_records:\n                            print(\n                                \"✗ Customer 'isabella.romano@premium.eu' not found - search returned no results\",\n                                file=sys.stderr,\n                            )\n                            return False\n                except Exception as e:\n                    print(f\"✗ Search failed: {str(e)}\", file=sys.stderr)\n            \n            if isabella_exists:\n                print(\n                    \"✓ Found customer with email 'isabella.romano@premium.eu'\",\n                    file=sys.stderr,\n                )\n            else:\n                print(\n                    \"✗ Customer 'isabella.romano@premium.eu' not found\",\n                    file=sys.stderr,\n                )\n                return False\n\n            # 3. Verify Dashboard Last Orders\n            print(\"\\nVerifying Dashboard Last Orders...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/admin/dashboard/\",\n                wait_until=\"networkidle\",\n            )\n            await page.wait_for_timeout(2000)\n\n            # Check for Last Orders section\n            last_orders_exists = await page.locator(\"text=Last Orders\").count() > 0\n            if last_orders_exists:\n                print(\"✓ Found 'Last Orders' section on dashboard\", file=sys.stderr)\n\n                # Find the first customer in the table\n                # Look for the table after \"Last Orders\" heading\n                orders_table = (\n                    page.locator(\"text=Last Orders\")\n                    .locator(\"..\")\n                    .locator(\"table\")\n                    .first\n                )\n                if await orders_table.count() > 0:\n                    # Get the last row in tbody\n                    last_row = orders_table.locator(\"tbody tr\").last\n                    if await last_row.count() > 0:\n                        last_customer = await last_row.locator(\n                            \"td\"\n                        ).first.inner_text()\n                        print(\n                            f\"✓ Last customer in Last Orders: {last_customer}\",\n                            file=sys.stderr,\n                        )\n\n                        # Verify against expected answer if available\n                        if expected_answer and \"LastOrderCustomer\" in expected_answer:\n                            if last_customer == expected_answer[\"LastOrderCustomer\"]:\n                                print(\n                                    f\"✓ Last Order Customer matches expected: {last_customer}\",\n                                    file=sys.stderr,\n                                )\n                            else:\n                                print(\n                                    f\"✗ Last Order Customer mismatch: Expected '{expected_answer['LastOrderCustomer']}' but actual is '{last_customer}'\",\n                                    file=sys.stderr,\n                                )\n                                return False\n            else:\n                print(\n                    \"Warning: 'Last Orders' section not found on dashboard\",\n                    file=sys.stderr,\n                )\n\n            # Summary of verification - only print if we reach this point (all checks passed)\n            print(\"\\n=== Browser Verification Summary ===\", file=sys.stderr)\n            print(\"✓ Magento Admin login successful\", file=sys.stderr)\n            print(\n                \"✓ Customer group 'Premium Europe' exists with correct tax class\",\n                file=sys.stderr,\n            )\n            print(\"✓ Customer 'isabella.romano@premium.eu' found in system\", file=sys.stderr)\n            print(\"✓ Customer counts verified\", file=sys.stderr)\n            print(\"✓ Dashboard Last Orders section accessible\", file=sys.stderr)\n\n            return True\n\n        except PlaywrightTimeoutError as e:\n            print(f\"Error: Timeout occurred - {str(e)}\", file=sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"Error: Unexpected error - {str(e)}\", file=sys.stderr)\n            return False\n        finally:\n            await browser.close()\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}