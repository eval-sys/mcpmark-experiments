{
  "task_id": "rls_business_access",
  "task_name": "RLS Business Access",
  "category_id": "security",
  "category_name": "Security",
  "description": "Implement Row Level Security policies for social platform with proper access control for posts, comments, and channels.",
  "author": "Fanshi Zhang",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "security and access control",
    "stored procedures and functions",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Implement Row Level Security (RLS) policies for a social media platform with Users, Posts, Comments, and Channels.\n\n## Your Mission:\n\nBuild RLS policies for a social platform where users create posts and comments in channels. Implement proper access control so users can manage their own content, while channel moderators can moderate content in their channels.\n\n## RLS Requirements:\n\n### 1. Users Table Access Rules:\n- **SELECT**: Users can read all public user profiles (username, created_at)\n- **UPDATE**: Users can only modify their own profile\n- **DELETE**: Users can only delete their own account\n\n### 2. Channels Table Access Rules:\n- **SELECT**: Everyone can read public channel information\n- **INSERT**: Any authenticated user can create a channel (becomes owner)\n- **UPDATE**: Only channel owners can modify channel details\n- **DELETE**: Only channel owners can delete channels\n\n### 3. Posts Table Access Rules:\n- **SELECT**: Users can read all posts in channels they have access to\n- **INSERT**: Authenticated users can create posts in any channel\n- **UPDATE**: Post authors OR channel moderators OR channel owners can edit posts\n- **DELETE**: Post authors OR channel moderators OR channel owners can delete posts\n\n### 4. Comments Table Access Rules:\n- **SELECT**: Users can read comments on posts they can access\n- **INSERT**: Authenticated users can comment on posts they can see\n- **UPDATE**: Comment authors OR post authors OR channel moderators OR channel owners can edit comments\n- **DELETE**: Comment authors OR post authors OR channel moderators OR channel owners can delete comments\n\n### 5. Channel Moderators Table Access Rules:\n- **SELECT**: Users can see moderator lists for channels\n- **INSERT**: Only channel owners can add moderators\n- **DELETE**: Channel owners can remove moderators; moderators can remove themselves\n\n## Session Context:\n\nUse `current_setting('app.current_user_id')` to get the current user ID from session context.\n\n## Schema Requirements:\n\n- **Use only the `public` schema** for all tables, functions, and policies\n- All helper functions should be created in the `public` schema\n- Do not create additional schemas\n\n## Expected Deliverables:\n\n1. **Enable RLS** on all five tables\n2. **Create policies** for SELECT, INSERT, UPDATE, DELETE operations on each table\n3. **Helper functions** to check permissions efficiently:\n   - `is_channel_owner(channel_id, user_id)`\n   - `is_channel_moderator(channel_id, user_id)`\n   - `can_moderate_channel(channel_id, user_id)`\n4. **Proper indexing** to ensure RLS policies perform well\n\n## Test Scenarios:\n\nYour RLS implementation will be verified with:\n\n- **Content ownership**: Users can only edit their own posts/comments\n- **Moderation hierarchy**: Moderators can moderate content in their channels\n- **Channel isolation**: Users only see content from accessible channels\n- **Permission escalation**: Owners have full control over their channels\n- **Cross-table access**: Comment policies respect post and channel permissions\n\n## Success Criteria:\n\n- Users can manage their own content (posts, comments)\n- Channel owners have full control over their channels\n- Moderators can moderate content in their assigned channels\n- No unauthorized access to other users' private data\n- Policies are efficient and don't create performance bottlenecks\n- All operations (SELECT, INSERT, UPDATE, DELETE) are properly secured\n",
  "verify": "#!/usr/bin/env python3\n\nimport os\nimport psycopg2\nfrom psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT\nimport sys\n\ndef verify_rls_implementation():\n    \"\"\"\n    Verify that Row Level Security policies have been properly implemented\n    for the social media platform with Users, Posts, Comments, and Channels.\n    \"\"\"\n\n    # Database connection parameters from environment\n    admin_db_params = {\n        'host': os.getenv('POSTGRES_HOST', 'localhost'),\n        'port': os.getenv('POSTGRES_PORT', '5432'),\n        'user': os.getenv('POSTGRES_USER', 'postgres'),\n        'password': os.getenv('POSTGRES_PASSWORD', 'password'),\n        'database': os.getenv('POSTGRES_DATABASE', 'postgres')\n    }\n\n    # Test user parameters (non-superuser for proper RLS testing)\n    test_db_params = {\n        'host': os.getenv('POSTGRES_HOST', 'localhost'),\n        'port': os.getenv('POSTGRES_PORT', '5432'),\n        'user': 'test_user',\n        'password': 'testpass',\n        'database': os.getenv('POSTGRES_DATABASE', 'postgres')\n    }\n\n    try:\n        # First connect as admin to ensure test user exists\n        admin_conn = psycopg2.connect(**admin_db_params)\n        admin_conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        admin_cur = admin_conn.cursor()\n\n        # Create test user if it doesn't exist\n        try:\n            admin_cur.execute(\"CREATE ROLE test_user LOGIN PASSWORD 'testpass';\")\n        except psycopg2.Error:\n            pass  # User already exists\n\n        # Grant necessary permissions to test user on the current database\n        admin_cur.execute(\"SELECT current_database();\")\n        current_db_name = admin_cur.fetchone()[0]\n\n        admin_cur.execute(f\"GRANT CONNECT ON DATABASE \\\"{current_db_name}\\\" TO test_user;\")\n        admin_cur.execute(\"GRANT USAGE ON SCHEMA public TO test_user;\")\n        admin_cur.execute(\"GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO test_user;\")\n        admin_cur.execute(\"GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO test_user;\")\n        admin_cur.execute(\"GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO test_user;\")\n\n        admin_cur.close()\n        admin_conn.close()\n\n        # Update test_db_params with the correct database name\n        test_db_params['database'] = current_db_name\n\n        # Now connect as test user for RLS verification\n        conn = psycopg2.connect(**test_db_params)\n        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)\n        cur = conn.cursor()\n\n        print(\"Verifying...\")\n\n        test_results = []\n\n        # Test 1: Check if RLS is enabled on all tables\n        print(\"\\n1. Checking RLS enablement...\")\n        expected_tables = ['users', 'channels', 'channel_moderators', 'posts', 'comments']\n\n        for table in expected_tables:\n            cur.execute(\"\"\"\n                SELECT relrowsecurity\n                FROM pg_class\n                WHERE relname = %s AND relkind = 'r'\n            \"\"\", (table,))\n            result = cur.fetchone()\n\n            if result and result[0]:\n                test_results.append(f\"✓ RLS enabled on {table}\")\n            else:\n                test_results.append(f\"✗ RLS NOT enabled on {table}\")\n\n        # Test 2: Users can only update their own profile\n        print(\"\\n2. Testing user profile access control...\")\n\n        # Alice tries to update her own profile (should work)\n        try:\n            cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice\n            cur.execute(\"\"\"\n                UPDATE users\n                SET email = 'alice.updated@example.com'\n                WHERE id = '11111111-1111-1111-1111-111111111111'\n            \"\"\")\n            test_results.append(\"✓ Users can update their own profile\")\n        except Exception as e:\n            test_results.append(f\"✗ User cannot update own profile: {e}\")\n\n        # Alice tries to update Bob's profile (should fail)\n        try:\n            cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice\n            cur.execute(\"\"\"\n                UPDATE users\n                SET email = 'bob.hacked@example.com'\n                WHERE id = '22222222-2222-2222-2222-222222222222'\n            \"\"\")\n            # Check if the update actually affected any rows (RLS blocks by affecting 0 rows)\n            if cur.rowcount == 0:\n                test_results.append(\"✓ Users blocked from updating other users' profiles\")\n            else:\n                test_results.append(\"✗ User was able to update another user's profile (should be blocked)\")\n        except psycopg2.Error:\n            test_results.append(\"✓ Users blocked from updating other users' profiles\")\n\n        # Test 3: Channel ownership controls\n        print(\"\\n3. Testing channel ownership controls...\")\n\n        # Alice (owner of general channel) tries to update her channel\n        try:\n            cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice\n            cur.execute(\"\"\"\n                UPDATE channels\n                SET description = 'Updated by Alice'\n                WHERE id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'\n            \"\"\")\n            test_results.append(\"✓ Channel owners can update their channels\")\n        except Exception as e:\n            test_results.append(f\"✗ Channel owner cannot update channel: {e}\")\n\n        # Charlie tries to update Alice's channel (should fail)\n        try:\n            cur.execute(\"SET app.current_user_id = '33333333-3333-3333-3333-333333333333';\")  # Charlie\n            cur.execute(\"\"\"\n                UPDATE channels\n                SET description = 'Hacked by Charlie'\n                WHERE id = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'\n            \"\"\")\n            # Check if the update actually affected any rows (RLS blocks by affecting 0 rows)\n            if cur.rowcount == 0:\n                test_results.append(\"✓ Non-owners blocked from updating channels\")\n            else:\n                test_results.append(\"✗ Non-owner was able to update channel (should be blocked)\")\n        except psycopg2.Error:\n            test_results.append(\"✓ Non-owners blocked from updating channels\")\n\n        # Test 4: Post authorship and moderation controls\n        print(\"\\n4. Testing post access controls...\")\n\n        # Alice (author) tries to update her own post\n        try:\n            cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice\n            cur.execute(\"\"\"\n                UPDATE posts\n                SET title = 'Updated by Alice'\n                WHERE id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'\n            \"\"\")\n            test_results.append(\"✓ Post authors can update their posts\")\n        except Exception as e:\n            test_results.append(f\"✗ Post author cannot update post: {e}\")\n\n        # Bob (moderator of general) tries to update Alice's post (should work)\n        try:\n            cur.execute(\"SET app.current_user_id = '22222222-2222-2222-2222-222222222222';\")  # Bob (moderator)\n            cur.execute(\"\"\"\n                UPDATE posts\n                SET content = 'Moderated by Bob'\n                WHERE id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'\n            \"\"\")\n            test_results.append(\"✓ Channel moderators can update posts in their channels\")\n        except Exception as e:\n            test_results.append(f\"✗ Channel moderator cannot update post: {e}\")\n\n        # Eve tries to update Alice's post (should fail - not author, owner, or moderator)\n        try:\n            cur.execute(\"SET app.current_user_id = '55555555-5555-5555-5555-555555555555';\")  # Eve\n            cur.execute(\"\"\"\n                UPDATE posts\n                SET content = 'Hacked by Eve'\n                WHERE id = 'dddddddd-dddd-dddd-dddd-dddddddddddd'\n            \"\"\")\n            # Check if the update actually affected any rows (RLS blocks by affecting 0 rows)\n            if cur.rowcount == 0:\n                test_results.append(\"✓ Unauthorized users blocked from updating posts\")\n            else:\n                test_results.append(\"✗ Unauthorized user was able to update post (should be blocked)\")\n        except psycopg2.Error:\n            test_results.append(\"✓ Unauthorized users blocked from updating posts\")\n\n        # Test 5: Comment access controls\n        print(\"\\n5. Testing comment access controls...\")\n\n        # Bob (comment author) tries to update his own comment\n        try:\n            cur.execute(\"SET app.current_user_id = '22222222-2222-2222-2222-222222222222';\")  # Bob\n            cur.execute(\"\"\"\n                UPDATE comments\n                SET content = 'Updated by Bob himself'\n                WHERE id = '99999999-9999-9999-9999-999999999999'\n            \"\"\")\n            test_results.append(\"✓ Comment authors can update their comments\")\n        except Exception as e:\n            test_results.append(f\"✗ Comment author cannot update comment: {e}\")\n\n        # Alice (post author) tries to update Bob's comment on her post (should work)\n        try:\n            cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice (post author)\n            cur.execute(\"\"\"\n                UPDATE comments\n                SET content = 'Moderated by post author Alice'\n                WHERE id = '99999999-9999-9999-9999-999999999999'\n            \"\"\")\n            test_results.append(\"✓ Post authors can moderate comments on their posts\")\n        except Exception as e:\n            test_results.append(f\"✗ Post author cannot moderate comment: {e}\")\n\n        # Test 6: Channel moderator assignment controls\n        print(\"\\n6. Testing moderator assignment controls...\")\n\n        # Alice (channel owner) tries to add a moderator\n        try:\n            cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice (owner of general)\n            cur.execute(\"\"\"\n                INSERT INTO channel_moderators (channel_id, user_id)\n                VALUES ('aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa', '33333333-3333-3333-3333-333333333333')\n            \"\"\")\n            test_results.append(\"✓ Channel owners can add moderators\")\n        except Exception as e:\n            test_results.append(f\"✗ Channel owner cannot add moderator: {e}\")\n\n        # Charlie tries to add himself as moderator to Bob's channel (should fail)\n        try:\n            cur.execute(\"SET app.current_user_id = '33333333-3333-3333-3333-333333333333';\")  # Charlie\n            cur.execute(\"\"\"\n                INSERT INTO channel_moderators (channel_id, user_id)\n                VALUES ('bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb', '33333333-3333-3333-3333-333333333333')\n            \"\"\")\n            # Check if the insert actually affected any rows (RLS blocks by affecting 0 rows)\n            if cur.rowcount == 0:\n                test_results.append(\"✓ Non-owners blocked from adding moderators\")\n            else:\n                test_results.append(\"✗ Non-owner was able to add moderator (should be blocked)\")\n        except psycopg2.Error:\n            test_results.append(\"✓ Non-owners blocked from adding moderators\")\n\n        # Test 7: Content visibility based on user context\n        print(\"\\n7. Testing content visibility...\")\n\n        # Count posts visible to Alice\n        cur.execute(\"SET app.current_user_id = '11111111-1111-1111-1111-111111111111';\")  # Alice\n        cur.execute(\"SELECT COUNT(*) FROM posts;\")\n        alice_posts = cur.fetchone()[0]\n\n        # Count posts visible to Eve\n        cur.execute(\"SET app.current_user_id = '55555555-5555-5555-5555-555555555555';\")  # Eve\n        cur.execute(\"SELECT COUNT(*) FROM posts;\")\n        eve_posts = cur.fetchone()[0]\n\n        if alice_posts >= 2 and eve_posts >= 1:  # Alice should see posts in channels she has access to\n            test_results.append(\"✓ Content visibility varies correctly based on user context\")\n        else:\n            test_results.append(f\"✗ Content visibility issue: Alice sees {alice_posts}, Eve sees {eve_posts}\")\n\n        # Test 8: Anonymous user access\n        print(\"\\n8. Testing anonymous user restrictions...\")\n\n        try:\n            cur.execute(\"SET app.current_user_id = '';\")  # Anonymous user\n            cur.execute(\"SELECT COUNT(*) FROM users;\")\n            anon_users = cur.fetchone()[0]\n\n            # Anonymous users should be able to see public user profiles per requirements\n            # Count public users that should be visible\n            cur.execute(\"SELECT COUNT(*) FROM users WHERE is_public = true;\")\n            public_users = cur.fetchone()[0] if cur.rowcount > 0 else 0\n\n            if anon_users == public_users and anon_users > 0:\n                test_results.append(f\"✓ Anonymous users can see {anon_users} public user profiles (correct)\")\n            elif anon_users == 0:\n                test_results.append(\"✗ Anonymous users cannot see any users (should see public profiles)\")\n            else:\n                test_results.append(f\"✗ Anonymous users can see {anon_users} users but expected {public_users} public users\")\n        except Exception as e:\n            test_results.append(\"✓ Anonymous users properly restricted\")\n\n        # Print results\n        print(\"\\n\" + \"=\"*60)\n        print(\"RLS VERIFICATION RESULTS - SOCIAL MEDIA PLATFORM\")\n        print(\"=\"*60)\n\n        passed = sum(1 for result in test_results if result.startswith(\"✓\"))\n        failed = sum(1 for result in test_results if result.startswith(\"✗\"))\n\n        for result in test_results:\n            print(result)\n\n        print(f\"\\nSummary: {passed} passed, {failed} failed\")\n\n        cur.close()\n        conn.close()\n\n        if failed == 0:\n            print(\"\\nAll tests passed.\")\n            return True\n        else:\n            print(f\"\\n{failed} test(s) failed.\")\n            return False\n\n    except Exception as e:\n        print(f\"Error during verification: {e}\")\n        return False\n\nif __name__ == \"__main__\":\n    success = verify_rls_implementation()\n    sys.exit(0 if success else 1)\n"
}