{
  "task_id": "products_sales_analysis",
  "task_name": "Products Sales Analysis",
  "category_id": "shopping_admin",
  "category_name": "Shopping Admin",
  "description": "Generate comprehensive sales performance reports by extracting product metrics, analyzing revenue trends, identifying top performers, evaluating inventory turnover, and creating actionable insights.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "comparative analysis",
    "content submission"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "Perform a comprehensive products and sales analysis in the Magento Admin panel to identify inventory status and sales performance metrics.\n\n**Task Requirements:**\n\n1. if need to login, login with username 'admin' and password 'admin1234'\n\n2. Analyze product inventory and catalog details, perform the following:\n   - Search for all products containing 'Yoga' in their name - count the exact number of results\n   - Clear the search and find the product with SKU 'WH11' - record its exact price\n   - Apply a filter to show only products with Quantity = 0.0000 - count how many products match\n\n3. To identify top-selling products and revenue metrics, navigate to the Dashboard and from the Bestsellers table:\n   - Identify the product with lowest price and lowest quantity - record the product name and quantity sold\n   - Find the second cheapest product in the table - record its exact quantity sold\n   - Note the total Revenue amount displayed in the dashboard\n\n4. Father all customers' information and demographics:\n   - Find customer 'Sarah Miller' - record her exact email address\n   - Count the total number of customers shown in the grid\n\n5. Review order status and customer purchase history, go to orders of sales:\n   - Count the total number of orders with 'Pending' status\n   - Find the order ID of Grace Nguyen's order with the completed status and the most expensive price (starting with \"000\")\n\n6. To provide a comprehensive report of all gathered data, compile all your findings and output them in the following exact format:\n\n```\n<answer>\nYogaProducts|count\nWH11Price|price\nZeroQuantityProducts|count\nLowestProduct|name:quantity\nQuestLumaflexQuantity|quantity\nDashboardRevenue|amount\nSarahMillerEmail|email\nTotalCustomers|count\nPendingOrders|count\nGraceNguyenOrderID|orderid\n</answer>\n```\n\n**Example Output:**\n```\n<answer>\nYogaProducts|XX\nWH11Price|$XX.XX\nZeroQuantityProducts|XX\nLowestProduct|Product Name Here:XX\nQuestLumaflexQuantity|XX\nDashboardRevenue|$XX.XX\nSarahMillerEmail|email@example.com\nTotalCustomers|XX\nPendingOrders|X\nGraceNguyenOrderID|00000XXXX\n</answer>\n```",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nimport json\nfrom pathlib import Path\n\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n\n    try:\n        with open(messages_path, \"r\") as f:\n            messages = json.load(f)\n\n        # Find the last assistant message\n        for message in reversed(messages):\n            if (\n                message.get(\"role\") == \"assistant\"\n                and message.get(\"status\") == \"completed\"\n            ):\n                content = message.get(\"content\", [])\n                for item in content:\n                    if item.get(\"type\") == \"output_text\":\n                        return item.get(\"text\", \"\")\n\n        print(\"Warning: No assistant response found in messages\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef parse_answer_format(text):\n    \"\"\"\n    Parse the <answer>...</answer> format from the agent's output.\n    Returns a dictionary with the parsed values.\n    \"\"\"\n    if not text:\n        print(\"Error: No text provided to parse\", file=sys.stderr)\n        return None\n\n    # Look for <answer>...</answer> pattern\n    match = re.search(r\"<answer>(.*?)</answer>\", text, re.IGNORECASE | re.DOTALL)\n    if not match:\n        print(\"Error: No <answer>...</answer> tags found in response\", file=sys.stderr)\n        return None\n\n    answer_content = match.group(1).strip()\n    if not answer_content:\n        print(\"Error: Empty answer content\", file=sys.stderr)\n        return None\n\n    # Parse each line\n    result = {}\n    lines = [line.strip() for line in answer_content.split(\"\\n\") if line.strip()]\n\n    if len(lines) != 10:\n        print(f\"Error: Expected 10 lines in answer, got {len(lines)}\", file=sys.stderr)\n        print(f\"Lines found: {lines}\", file=sys.stderr)\n        return None\n\n    # Expected keys for validation\n    expected_keys = [\n        \"YogaProducts\", \"WH11Price\", \"ZeroQuantityProducts\", \"LowestProduct\",\n        \"QuestLumaflexQuantity\", \"DashboardRevenue\", \"SarahMillerEmail\",\n        \"TotalCustomers\", \"PendingOrders\", \"GraceNguyenOrderID\"\n    ]\n\n    for line in lines:\n        if \"|\" not in line:\n            print(f\"Error: Line missing '|' separator: {line}\", file=sys.stderr)\n            return None\n        \n        parts = line.split(\"|\", 1)\n        if len(parts) != 2:\n            print(f\"Error: Invalid line format: {line}\", file=sys.stderr)\n            return None\n            \n        key, value = parts[0].strip(), parts[1].strip()\n        \n        if not key or not value:\n            print(f\"Error: Empty key or value in line: {line}\", file=sys.stderr)\n            return None\n            \n        result[key] = value\n\n    # Validate all expected keys are present\n    missing_keys = set(expected_keys) - set(result.keys())\n    if missing_keys:\n        print(f\"Error: Missing required keys: {missing_keys}\", file=sys.stderr)\n        return None\n\n    return result\n\n\ndef load_expected_answer(label_path):\n    \"\"\"\n    Load the expected answer from label.txt file.\n    Returns a dictionary with the expected values.\n    \"\"\"\n    try:\n        with open(label_path, \"r\") as f:\n            lines = f.read().strip().split(\"\\n\")\n\n        expected = {}\n        for line in lines:\n            if \"|\" in line:\n                key, value = line.split(\"|\", 1)\n                expected[key.strip()] = value.strip()\n\n        return expected\n    except Exception as e:\n        print(f\"Error reading label file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef compare_answers(model_answer, expected_answer):\n    \"\"\"\n    Compare the model's answer with the expected answer.\n    Returns True if all key information matches, False otherwise.\n    \"\"\"\n    if not model_answer or not expected_answer:\n        return False\n\n    # Check each expected key\n    mismatches = []\n    for key, expected_value in expected_answer.items():\n        model_value = model_answer.get(key, \"\")\n\n        # Special handling for different types of values\n        if key == \"LowestProduct\":\n            # Check if product name and quantity match (format: \"Product Name:quantity\")\n            if \":\" in expected_value and \":\" in model_value:\n                expected_name, expected_qty = expected_value.rsplit(\":\", 1)\n                model_name, model_qty = model_value.rsplit(\":\", 1)\n                if expected_name != model_name or expected_qty != model_qty:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n            else:\n                if expected_value != model_value:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n\n        elif key in [\"WH11Price\", \"DashboardRevenue\"]:\n            # For price/amount fields, normalize format\n            expected_clean = expected_value.replace(\"$\", \"\").replace(\",\", \"\")\n            model_clean = model_value.replace(\"$\", \"\").replace(\",\", \"\")\n            if expected_clean != model_clean:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"SarahMillerEmail\":\n            # Email should match exactly\n            if model_value.lower() != expected_value.lower():\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        else:\n            # Exact match for other fields\n            if model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n    if mismatches:\n        print(\"\\n=== Answer Comparison Mismatches ===\", file=sys.stderr)\n        for mismatch in mismatches:\n            print(f\"✗ {mismatch}\", file=sys.stderr)\n        return False\n\n    print(\"\\n=== Answer Comparison ===\", file=sys.stderr)\n    print(\"✓ All key information matches the expected answer\", file=sys.stderr)\n    return True\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the products and sales analysis task has been completed correctly.\n    First checks the model's answer against the expected label,\n    then optionally verifies the actual state in the Magento Admin.\n    \"\"\"\n    # Get the label file path\n    label_path = Path(__file__).parent / \"label.txt\"\n\n    # Load expected answer\n    expected_answer = load_expected_answer(label_path)\n    if not expected_answer:\n        print(\"Error: Could not load expected answer from label.txt\", file=sys.stderr)\n        return False\n\n    # Get model's response from MCP_MESSAGES\n    model_response = get_model_response()\n    if model_response:\n        print(\"Found model response, parsing answer format...\", file=sys.stderr)\n        model_answer = parse_answer_format(model_response)\n\n        if model_answer:\n            print(\"\\n=== Model Answer Parsed ===\", file=sys.stderr)\n            for key, value in model_answer.items():\n                print(f\"{key}: {value}\", file=sys.stderr)\n\n            # Compare answers\n            answer_match = compare_answers(model_answer, expected_answer)\n            if not answer_match:\n                print(\"\\nModel answer does not match expected answer\", file=sys.stderr)\n                return False\n            print(\"\\n✓ Model answer matches expected answer\", file=sys.stderr)\n            return True\n        else:\n            print(\n                \"Warning: Could not parse answer format from model response\",\n                file=sys.stderr,\n            )\n            return False\n    else:\n        print(\"No model response found\", file=sys.stderr)\n        return False\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}