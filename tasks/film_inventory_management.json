{
  "task_id": "film_inventory_management",
  "task_name": "Film Inventory Management",
  "category_id": "dvdrental",
  "category_name": "DVD Rental",
  "description": "Manage film inventory through multiple operations including adding films, updating records, and cleaning old data.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-20",
  "difficulty": "L3",
  "tags": [
    "data migration",
    "transactional operations",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "Enum \"mpaa_rating\" {\n  \"G\"\n  \"PG\"\n  \"PG-13\"\n  \"R\"\n  \"NC-17\"\n}\n\nTable \"customer\" {\n  \"customer_id\" int4 [pk, not null, increment]\n  \"store_id\" int2 [not null]\n  \"first_name\" varchar(45) [not null]\n  \"last_name\" varchar(45) [not null]\n  \"email\" varchar(50)\n  \"address_id\" int2 [not null]\n  \"activebool\" bool [not null, default: true]\n  \"create_date\" date [not null, default: `('now'::text)::date`]\n  \"last_update\" timestamp [default: `now()`]\n  \"active\" int4\n\n  Indexes {\n    address_id [type: btree, name: \"idx_fk_address_id\"]\n    store_id [type: btree, name: \"idx_fk_store_id\"]\n    last_name [type: btree, name: \"idx_last_name\"]\n  }\n}\n\nTable \"actor\" {\n  \"actor_id\" int4 [pk, not null, increment]\n  \"first_name\" varchar(45) [not null]\n  \"last_name\" varchar(45) [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    last_name [type: btree, name: \"idx_actor_last_name\"]\n  }\n}\n\nTable \"category\" {\n  \"category_id\" int4 [pk, not null, increment]\n  \"name\" varchar(25) [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n}\n\nTable \"film\" {\n  \"film_id\" int4 [pk, not null, increment]\n  \"title\" varchar(255) [not null]\n  \"description\" text\n  \"release_year\" int4\n  \"language_id\" int2 [not null]\n  \"rental_duration\" int2 [not null, default: 3]\n  \"rental_rate\" numeric(4,2) [not null, default: 4.99]\n  \"length\" int2\n  \"replacement_cost\" numeric(5,2) [not null, default: 19.99]\n  \"rating\" mpaa_rating [default: 'G']\n  \"last_update\" timestamp [not null, default: `now()`]\n  \"special_features\" \"text[]\"\n  \"fulltext\" tsvector [not null]\n\n  Indexes {\n    fulltext [type: gist, name: \"film_fulltext_idx\"]\n    language_id [type: btree, name: \"idx_fk_language_id\"]\n    title [type: btree, name: \"idx_title\"]\n  }\n}\n\nTable \"film_actor\" {\n  \"actor_id\" int2 [not null]\n  \"film_id\" int2 [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    (actor_id, film_id) [type: btree, name: \"film_actor_pkey\"]\n    film_id [type: btree, name: \"idx_fk_film_id\"]\n  }\n}\n\nTable \"film_category\" {\n  \"film_id\" int2 [not null]\n  \"category_id\" int2 [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    (film_id, category_id) [type: btree, name: \"film_category_pkey\"]\n  }\n}\n\nTable \"address\" {\n  \"address_id\" int4 [pk, not null, increment]\n  \"address\" varchar(50) [not null]\n  \"address2\" varchar(50)\n  \"district\" varchar(20) [not null]\n  \"city_id\" int2 [not null]\n  \"postal_code\" varchar(10)\n  \"phone\" varchar(20) [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    city_id [type: btree, name: \"idx_fk_city_id\"]\n  }\n}\n\nTable \"city\" {\n  \"city_id\" int4 [pk, not null, increment]\n  \"city\" varchar(50) [not null]\n  \"country_id\" int2 [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    country_id [type: btree, name: \"idx_fk_country_id\"]\n  }\n}\n\nTable \"country\" {\n  \"country_id\" int4 [pk, not null, increment]\n  \"country\" varchar(50) [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n}\n\nTable \"inventory\" {\n  \"inventory_id\" int4 [pk, not null, increment]\n  \"film_id\" int2 [not null]\n  \"store_id\" int2 [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    (store_id, film_id) [type: btree, name: \"idx_store_id_film_id\"]\n  }\n}\n\nTable \"language\" {\n  \"language_id\" int4 [pk, not null, increment]\n  \"name\" bpchar(20) [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n}\n\nTable \"payment\" {\n  \"payment_id\" int4 [pk, not null, increment]\n  \"customer_id\" int2 [not null]\n  \"staff_id\" int2 [not null]\n  \"rental_id\" int4 [not null]\n  \"amount\" numeric(5,2) [not null]\n  \"payment_date\" timestamp [not null]\n\n  Indexes {\n    rental_id [type: btree, name: \"idx_fk_rental_id\"]\n    staff_id [type: btree, name: \"idx_fk_staff_id\"]\n  }\n}\n\nTable \"rental\" {\n  \"rental_id\" int4 [pk, not null, increment]\n  \"rental_date\" timestamp [not null]\n  \"inventory_id\" int4 [not null]\n  \"customer_id\" int2 [not null]\n  \"return_date\" timestamp\n  \"staff_id\" int2 [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n\n  Indexes {\n    (rental_date, inventory_id, customer_id) [type: btree, name: \"idx_unq_rental_rental_date_inventory_id_customer_id\"]\n    inventory_id [type: btree, name: \"idx_fk_inventory_id\"]\n  }\n}\n\nTable \"staff\" {\n  \"staff_id\" int4 [pk, not null, increment]\n  \"first_name\" varchar(45) [not null]\n  \"last_name\" varchar(45) [not null]\n  \"address_id\" int2 [not null]\n  \"email\" varchar(50)\n  \"store_id\" int2 [not null]\n  \"active\" bool [not null, default: true]\n  \"username\" varchar(16) [not null]\n  \"password\" varchar(40)\n  \"last_update\" timestamp [not null, default: `now()`]\n  \"picture\" bytea\n}\n\nTable \"store\" {\n  \"store_id\" int4 [pk, not null, increment]\n  \"manager_staff_id\" int2 [unique, not null]\n  \"address_id\" int2 [not null]\n  \"last_update\" timestamp [not null, default: `now()`]\n}\n\nRef \"fk_address_city\":\"city\".\"city_id\" < \"address\".\"city_id\"\n\nRef \"fk_city\":\"country\".\"country_id\" < \"city\".\"country_id\"\n\nRef \"customer_address_id_fkey\":\"address\".\"address_id\" < \"customer\".\"address_id\" [update: cascade, delete: restrict]\n\nRef \"film_language_id_fkey\":\"language\".\"language_id\" < \"film\".\"language_id\" [update: cascade, delete: restrict]\n\nRef \"film_actor_actor_id_fkey\":\"actor\".\"actor_id\" < \"film_actor\".\"actor_id\" [update: cascade, delete: restrict]\n\nRef \"film_actor_film_id_fkey\":\"film\".\"film_id\" < \"film_actor\".\"film_id\" [update: cascade, delete: restrict]\n\nRef \"film_category_category_id_fkey\":\"category\".\"category_id\" < \"film_category\".\"category_id\" [update: cascade, delete: restrict]\n\nRef \"film_category_film_id_fkey\":\"film\".\"film_id\" < \"film_category\".\"film_id\" [update: cascade, delete: restrict]\n\nRef \"inventory_film_id_fkey\":\"film\".\"film_id\" < \"inventory\".\"film_id\" [update: cascade, delete: restrict]\n\nRef \"payment_customer_id_fkey\":\"customer\".\"customer_id\" < \"payment\".\"customer_id\" [update: cascade, delete: restrict]\n\nRef \"payment_rental_id_fkey\":\"rental\".\"rental_id\" < \"payment\".\"rental_id\" [update: cascade, delete: set null]\n\nRef \"payment_staff_id_fkey\":\"staff\".\"staff_id\" < \"payment\".\"staff_id\" [update: cascade, delete: restrict]\n\nRef \"rental_customer_id_fkey\":\"customer\".\"customer_id\" < \"rental\".\"customer_id\" [update: cascade, delete: restrict]\n\nRef \"rental_inventory_id_fkey\":\"inventory\".\"inventory_id\" < \"rental\".\"inventory_id\" [update: cascade, delete: restrict]\n\nRef \"rental_staff_id_key\":\"staff\".\"staff_id\" < \"rental\".\"staff_id\"\n\nRef \"staff_address_id_fkey\":\"address\".\"address_id\" < \"staff\".\"address_id\" [update: cascade, delete: restrict]\n\nRef \"store_address_id_fkey\":\"address\".\"address_id\" < \"store\".\"address_id\" [update: cascade, delete: restrict]\n\nRef \"store_manager_staff_id_fkey\":\"staff\".\"staff_id\" < \"store\".\"manager_staff_id\" [update: cascade, delete: restrict]\n",
    "stateUrl": null,
    "stateOriginalUrl": "https://github.com/gordonkwokkwok/DVD-Rental-PostgreSQL-Project"
  },
  "instruction": "Manage film inventory operations in the DVD rental database.\n\n## Background\n\nYou are the database administrator for the DVD rental store. The store manager has requested several database operations to manage the film inventory. You need to perform multiple operations including adding new films, updating inventory, querying available films, and cleaning up old records.\n\n## Your Task\n\nComplete the following database operations in sequence:\n\n### 1. Add New Films\nAdd these two new films to the database:\n- **Film 1**: Title \"Data Science Adventures\", Description \"A thrilling journey through machine learning algorithms\", Release Year 2024, Language ID 1, Rental Duration 5 days, Rental Rate $3.99, Length 120 minutes, Replacement Cost $15.99, Rating 'PG-13'\n- **Film 2**: Title \"Cloud Computing Chronicles\", Description \"Exploring the world of distributed systems\", Release Year 2024, Language ID 1, Rental Duration 7 days, Rental Rate $4.99, Length 135 minutes, Replacement Cost $18.99, Rating 'PG'\n\n### 2. Add Inventory Records\nFor each new film, add 3 inventory records for store_id = 1 and 2 inventory records for store_id = 2.\n\n### 3. Update Film Information\nUpdate the rental_rate of all films with rating 'PG-13' to increase by 10% (multiply by 1.1).\n\n### 4. Create Available Films Table\nCreate a table called `available_films` with the following structure:\n- `film_id` (INTEGER, PRIMARY KEY)\n- `title` (VARCHAR(255), NOT NULL)\n- `rental_rate` (NUMERIC(4,2), NOT NULL)\n- `length` (SMALLINT)\n\nPopulate this table with films that meet these criteria:\n- Have rental_rate between $3.00 and $5.00\n- Have length greater than 100 minutes  \n- Are available in store_id = 1 (have at least 1 inventory record)\n\n\n### 5. Clean Up Inventory\nDelete inventory records for films that meet ALL of the following criteria:\n- Have a replacement_cost greater than $25.00\n- AND have rental_rate less than $1.00\n- AND have no rental history (no records in the rental table)\n\n\n### 6. Create Summary Report Table\nCreate a table called `film_inventory_summary` with the following structure:\n- `title` (VARCHAR(255), NOT NULL)\n- `rental_rate` (NUMERIC(4,2), NOT NULL)\n- `total_inventory` (INTEGER, NOT NULL)\n- `store1_count` (INTEGER, NOT NULL)\n- `store2_count` (INTEGER, NOT NULL)\n\nPopulate this table with a summary query that shows:\n- Film title\n- Current rental rate (after any updates from step 3)\n- Total count of inventory records across all stores\n- Count of inventory records in store_id = 1\n- Count of inventory records in store_id = 2\n\nRequirements for the summary report:\n- Include only films that currently have at least one inventory record  \n- Insert the results sorted by inventory count from highest to lowest, and then alphabetically by film title\n- Ensure all counts reflect the state after completing the previous operations\n\n## Requirements\n\n- Complete all operations in the specified sequence\n- Ensure data integrity throughout all operations\n- Verify that your operations affect the expected number of records\n- Handle any constraint violations appropriately",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 4: Film Inventory Management\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"Compare two rows with appropriate tolerance for decimals and floats.\"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, (Decimal, float)) and isinstance(expected, (Decimal, float)):\n            # Use higher tolerance for floating point comparisons\n            if abs(float(actual) - float(expected)) > 0.01:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef check_new_films(conn) -> bool:\n    \"\"\"Check if the two new films were added correctly.\"\"\"\n    with conn.cursor() as cur:\n        cur.execute(\"\"\"\n            SELECT title, description, release_year, language_id, \n                   rental_duration, rental_rate, length, replacement_cost, \n                   rating\n            FROM film \n            WHERE title IN ('Data Science Adventures', 'Cloud Computing Chronicles')\n            ORDER BY title\n        \"\"\")\n        actual_films = cur.fetchall()\n        \n        expected_films = [\n            ('Cloud Computing Chronicles', 'Exploring the world of distributed systems', 2024, 1, 7, Decimal('4.99'), 135, Decimal('18.99'), 'PG'),\n            ('Data Science Adventures', 'A thrilling journey through machine learning algorithms', 2024, 1, 5, Decimal('4.389'), 120, Decimal('15.99'), 'PG-13')\n        ]\n        \n        if len(actual_films) != len(expected_films):\n            print(f\"‚ùå Expected {len(expected_films)} new films, found {len(actual_films)}\")\n            return False\n            \n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_films, expected_films)):\n            if not rows_match(actual, expected):\n                print(f\"‚ùå Film {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n                \n        if mismatches > 0:\n            print(f\"‚ùå Total film mismatches: {mismatches}\")\n            return False\n            \n        print(\"‚úÖ Both new films added correctly\")\n        return True\n\ndef check_inventory_records(conn) -> bool:\n    \"\"\"Check if inventory records were added for new films.\"\"\"\n    with conn.cursor() as cur:\n        cur.execute(\"\"\"\n            SELECT f.title, i.store_id, COUNT(*) as count\n            FROM film f\n            JOIN inventory i ON f.film_id = i.film_id\n            WHERE f.title IN ('Data Science Adventures', 'Cloud Computing Chronicles')\n            GROUP BY f.title, i.store_id\n            ORDER BY f.title, i.store_id\n        \"\"\")\n        actual_inventory = cur.fetchall()\n        \n        expected_inventory = [\n            ('Cloud Computing Chronicles', 1, 3),\n            ('Cloud Computing Chronicles', 2, 2), \n            ('Data Science Adventures', 1, 3),\n            ('Data Science Adventures', 2, 2)\n        ]\n        \n        if len(actual_inventory) != len(expected_inventory):\n            print(f\"‚ùå Expected {len(expected_inventory)} inventory groups, found {len(actual_inventory)}\")\n            return False\n            \n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_inventory, expected_inventory)):\n            if not rows_match(actual, expected):\n                print(f\"‚ùå Inventory group {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n                \n        if mismatches > 0:\n            print(f\"‚ùå Total inventory mismatches: {mismatches}\")\n            return False\n                \n        print(\"‚úÖ Inventory records added correctly\")\n        return True\n\ndef check_available_films_table(conn) -> bool:\n    \"\"\"Check if available_films table was created and populated correctly.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT film_id, title, rental_rate, length\n            FROM available_films\n            ORDER BY rental_rate DESC, length DESC, title ASC\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            SELECT DISTINCT f.film_id, f.title, f.rental_rate, f.length\n            FROM film f\n            JOIN inventory i ON f.film_id = i.film_id\n            WHERE f.rental_rate >= 3.00 AND f.rental_rate <= 5.00\n            AND f.length > 100\n            AND i.store_id = 1\n            ORDER BY f.rental_rate DESC, f.length DESC, f.title ASC\n        \"\"\")\n        expected_results = cur.fetchall()\n        \n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå available_films table has {len(actual_results)} records, expected {len(expected_results)}\")\n            return False\n            \n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå available_films row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n                \n        if mismatches > 0:\n            print(f\"‚ùå Total available_films mismatches: {mismatches}\")\n            return False\n            \n        print(f\"‚úÖ available_films table created and populated correctly ({len(actual_results)} records)\")\n        return True\n\ndef check_inventory_cleanup(conn) -> bool:\n    \"\"\"Check if inventory cleanup was performed correctly.\"\"\"\n    with conn.cursor() as cur:\n        # Check that no inventory exists for films with replacement_cost > 25 AND rental_rate < 1\n        # that also don't have rental records (safe to delete)\n        cur.execute(\"\"\"\n            SELECT COUNT(*)\n            FROM inventory i\n            JOIN film f ON i.film_id = f.film_id\n            WHERE f.replacement_cost > 25.00 AND f.rental_rate < 1.00\n            AND NOT EXISTS (SELECT 1 FROM rental r WHERE r.inventory_id = i.inventory_id)\n        \"\"\")\n        \n        remaining_count = cur.fetchone()[0]\n        \n        if remaining_count > 0:\n            print(f\"‚ùå Found {remaining_count} inventory records that should have been deleted (no rental history)\")\n            return False\n            \n        print(\"‚úÖ Inventory cleanup completed correctly\")\n        return True\n\ndef check_summary_table(conn) -> bool:\n    \"\"\"Check if film_inventory_summary table was created and populated correctly.\"\"\"\n    with conn.cursor() as cur:\n            \n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT title, rental_rate, total_inventory, store1_count, store2_count\n            FROM film_inventory_summary\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            SELECT f.title, f.rental_rate,\n                   COUNT(i.inventory_id) as total_inventory,\n                   COUNT(CASE WHEN i.store_id = 1 THEN 1 END) as store1_count,\n                   COUNT(CASE WHEN i.store_id = 2 THEN 1 END) as store2_count\n            FROM film f\n            JOIN inventory i ON f.film_id = i.film_id\n            GROUP BY f.film_id, f.title, f.rental_rate\n            ORDER BY total_inventory DESC, f.title ASC\n        \"\"\")\n        expected_results = cur.fetchall()\n        \n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå film_inventory_summary table has {len(actual_results)} records, expected {len(expected_results)}\")\n            return False\n            \n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Summary row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n                \n        if mismatches > 0:\n            print(f\"‚ùå Total summary table mismatches: {mismatches}\")\n            return False\n                \n        print(f\"‚úÖ film_inventory_summary table created and populated correctly ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 70)\n    print(\"PostgreSQL Task 4 Verification: Film Inventory Management\")\n    print(\"=\" * 70)\n    \n    # Get connection parameters\n    conn_params = get_connection_params()\n    \n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n    \n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n        \n        # Verify all operations with short-circuit evaluation\n        success = (\n            check_new_films(conn) and \n            check_inventory_records(conn) and\n            check_available_films_table(conn) and \n            check_inventory_cleanup(conn) and\n            check_summary_table(conn)\n        )\n        \n        conn.close()\n        \n        if success:\n            print(f\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(f\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n            \n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}