{
  "task_id": "transactional_inventory_transfer",
  "task_name": "Transactional Inventory Transfer",
  "category_id": "lego",
  "category_name": "Lego",
  "description": "Create PostgreSQL function to handle inventory part transfers between LEGO sets with validation and audit logging.",
  "author": "Jiawei Wang",
  "created_at": "2025-08-16",
  "difficulty": "L3",
  "tags": [
    "transactional operations",
    "stored procedures and functions",
    "audit and compliance"
  ],
  "mcp": [
    "postgres"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "Table \"lego_colors\" {\n  \"id\" int4 [pk, not null, increment]\n  \"name\" varchar(255) [not null]\n  \"rgb\" varchar(6) [not null]\n  \"is_trans\" bpchar(1) [not null]\n}\n\nTable \"lego_inventories\" {\n  \"id\" int4 [pk, not null, increment]\n  \"version\" int4 [not null]\n  \"set_num\" varchar(255) [not null]\n}\n\nTable \"lego_inventory_parts\" {\n  \"inventory_id\" int4 [not null]\n  \"part_num\" varchar(255) [not null]\n  \"color_id\" int4 [not null]\n  \"quantity\" int4 [not null]\n  \"is_spare\" bool [not null]\n}\n\nTable \"lego_inventory_sets\" {\n  \"inventory_id\" int4 [not null]\n  \"set_num\" varchar(255) [not null]\n  \"quantity\" int4 [not null]\n}\n\nTable \"lego_part_categories\" {\n  \"id\" int4 [pk, not null, increment]\n  \"name\" varchar(255) [not null]\n}\n\nTable \"lego_parts\" {\n  \"part_num\" varchar(255) [pk, not null]\n  \"name\" text [not null]\n  \"part_cat_id\" int4 [not null]\n}\n\nTable \"lego_sets\" {\n  \"set_num\" varchar(255) [pk, not null]\n  \"name\" varchar(255) [not null]\n  \"year\" int4\n  \"theme_id\" int4\n  \"num_parts\" int4\n}\n\nTable \"lego_themes\" {\n  \"id\" int4 [pk, not null, increment]\n  \"name\" varchar(255) [not null]\n  \"parent_id\" int4\n}\n",
    "stateUrl": null,
    "stateOriginalUrl": "https://github.com/neondatabase-labs/postgres-sample-dbs/blob/main/lego.sql"
  },
  "instruction": "Create a PostgreSQL function to handle inventory part transfers between LEGO sets with enhanced validation and audit capabilities. The LEGO warehouse management system needs to support transferring parts while maintaining data integrity and tracking transfer history.\n\n## Your Tasks:\n\n1. **Create the transfer function** ‚Äî Implement a PostgreSQL function named `transfer_parts` with the following signature:\n   ```sql\n   CREATE OR REPLACE FUNCTION transfer_parts(\n       source_inventory_id INTEGER,\n       target_inventory_id INTEGER,\n       part_to_transfer_num VARCHAR,\n       color_to_transfer_id INTEGER,\n       quantity_to_transfer INTEGER,\n       transfer_reason VARCHAR DEFAULT 'manual_transfer'\n   ) RETURNS TEXT\n   ```\n\n2. **Create audit logging table** ‚Äî Create a new table to track transfer history:\n   ```sql\n   CREATE TABLE inventory_transfer_log (\n       log_id SERIAL PRIMARY KEY,\n       transfer_timestamp TIMESTAMP DEFAULT NOW(),\n       source_inventory_id INTEGER NOT NULL,\n       target_inventory_id INTEGER NOT NULL,\n       part_num VARCHAR NOT NULL,\n       color_id INTEGER NOT NULL,\n       quantity_transferred INTEGER NOT NULL,\n       transfer_reason VARCHAR NOT NULL,\n       transfer_status VARCHAR NOT NULL CHECK (transfer_status IN ('success', 'failed')),\n       error_message TEXT\n   );\n   ```\n\n3. **Implement enhanced validation** ‚Äî The function must perform these validations:\n   \n   **Validation A: Basic Checks**\n   - Verify both inventory IDs exist in `lego_inventories` table\n   - Verify part exists in `lego_parts` table\n   - Verify color exists in `lego_colors` table\n   - Check source has sufficient quantity (including spare parts)\n   - Prevent self-transfers (source and target cannot be the same)\n\n   **Validation B: Business Rules**\n   - Maximum transfer quantity is 500 parts per operation\n   - Minimum transfer quantity is 1 part\n   - Source and target must be different inventories\n\n4. **Implement transactional logic** ‚Äî The function must perform these operations within a single transaction:\n   \n   **Step A: Pre-validation**\n   - Lock both inventory records using `SELECT ... FOR UPDATE`\n   - Perform all validation checks\n   - Calculate transfer feasibility\n\n   **Step B: Source Inventory Update**\n   - Decrease quantity in source inventory\n   - If quantity becomes zero, delete the row\n   - Handle spare parts appropriately (maintain `is_spare` flag)\n\n   **Step C: Target Inventory Update**\n   - Check if part exists in target inventory\n   - If exists: increase quantity\n   - If not exists: insert new record\n   - Handle spare parts appropriately\n\n   **Step D: Audit Logging**\n   - Log successful transfers with details\n   - Log failed transfers with error messages\n   - Include transfer reason and status\n\n5. **Error handling requirements**:\n   - Use `RAISE EXCEPTION` with descriptive error messages\n   - Handle all validation failures gracefully\n   - Ensure complete rollback on any failure\n   - Log all attempts (successful and failed)\n\n6. **Return value**:\n   - Return success message: `'Successfully transferred {quantity} parts ({part_num}, color_id: {color_id}) from inventory {source_id} to inventory {target_id}. Reason: {reason}'`\n   - Include transfer details and reason in the message\n\n## Function Requirements:\n\n- **Transaction Safety**: All operations wrapped in transaction block\n- **Data Integrity**: No partial updates possible\n- **Audit Trail**: Complete logging of all transfer attempts\n- **Validation**: Comprehensive input and business rule validation\n- **Error Recovery**: Failed transfers leave database unchanged\n- **Performance**: Use appropriate locking to prevent race conditions\n\n## Example Usage:\n\n```sql\n-- Basic transfer with reason\nSELECT transfer_parts(14469, 14686, '3024', 15, 100, 'inventory_adjustment');\n\n-- Transfer to new inventory (should create new record)\nSELECT transfer_parts(11124, 14686, '3001', 4, 50, 'part_redistribution');\n\n-- This should fail due to insufficient quantity\nSELECT transfer_parts(14469, 14686, '3024', 15, 2000, 'large_transfer');\n\n-- This should fail due to self-transfer\nSELECT transfer_parts(14469, 14469, '3024', 15, 10, 'self_transfer');\n```\n\n## Verification Criteria:\n\n- Function handles all validation rules correctly\n- Audit logging captures all transfer attempts\n- Failed transfers are properly logged with error details\n- Self-transfers are prevented\n- Quantity limits are enforced\n- Database state remains consistent after failures",
  "verify": "\"\"\"\nVerification script for PostgreSQL LEGO Task 2: Enhanced Inventory Transfer Function\nTests the transfer_parts function with audit logging and enhanced validation.\n\nKey Features Tested:\n- Core transfer functionality with audit logging\n- Business rule validation (quantity limits, self-transfer prevention)\n- Error handling and rollback mechanisms\n- Audit trail maintenance for both success and failure cases\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nimport psycopg2.errors\nfrom typing import Optional, Tuple\n\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters from environment variables.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\"),\n    }\n\n\ndef get_inventory_part_quantity(conn, inventory_id: int, part_num: str, color_id: int) -> int:\n    \"\"\"Get the current quantity of a specific part in an inventory.\"\"\"\n    with conn.cursor() as cur:\n        cur.execute(\n            \"\"\"\n            SELECT quantity FROM public.lego_inventory_parts\n            WHERE inventory_id = %s AND part_num = %s AND color_id = %s\n            \"\"\",\n            (inventory_id, part_num, color_id)\n        )\n        result = cur.fetchone()\n        return result[0] if result else 0\n\n\ndef verify_system_components(conn) -> bool:\n    \"\"\"Verify that all required system components exist.\"\"\"\n    print(\"\\n-- Verifying System Components --\")\n    try:\n        with conn.cursor() as cur:\n            # Check main function\n            cur.execute(\n                \"\"\"\n                SELECT COUNT(*) FROM pg_proc p\n                JOIN pg_namespace n ON p.pronamespace = n.oid\n                WHERE n.nspname = 'public' AND p.proname = 'transfer_parts'\n                \"\"\"\n            )\n            main_func_count = cur.fetchone()[0]\n            \n            # Check audit table\n            cur.execute(\n                \"\"\"\n                SELECT COUNT(*) FROM information_schema.tables \n                WHERE table_schema = 'public' AND table_name = 'inventory_transfer_log'\n                \"\"\"\n            )\n            audit_table_count = cur.fetchone()[0]\n            \n            if main_func_count == 0:\n                print(\"‚ùå FAIL: transfer_parts function does not exist\")\n                return False\n            \n            if audit_table_count == 0:\n                print(\"‚ùå FAIL: inventory_transfer_log table does not exist\")\n                return False\n            \n            print(\"‚úÖ PASS: All system components exist\")\n            return True\n    finally:\n        conn.rollback()\n\n\ndef verify_successful_transfer_with_audit(conn) -> bool:\n    \"\"\"Test a successful transfer with audit logging.\"\"\"\n    print(\"\\n-- Verifying Successful Transfer with Audit --\")\n    passed = False\n    try:\n        # Test data: Transfer 100 white plates from Mosaic Dino to Mosaic Johnny Thunder\n        source_id = 14469\n        target_id = 14686\n        part_num = '3024'\n        color_id = 15\n        transfer_qty = 100\n        reason = 'inventory_adjustment'\n        \n        source_initial = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        target_initial = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        print(f\"Initial quantities - Source: {source_initial}, Target: {target_initial}\")\n        \n        # Get initial audit log count\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT COUNT(*) FROM inventory_transfer_log\")\n            initial_log_count = cur.fetchone()[0]\n        \n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                (source_id, target_id, part_num, color_id, transfer_qty, reason)\n            )\n            result = cur.fetchone()\n            print(f\"Transfer result: {result[0]}\")\n        \n        source_final = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        target_final = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        print(f\"Final quantities - Source: {source_final}, Target: {target_final}\")\n        \n        # Verify audit log entry\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT COUNT(*) FROM inventory_transfer_log\")\n            final_log_count = cur.fetchone()[0]\n            \n            if final_log_count <= initial_log_count:\n                print(\"‚ùå FAIL: No audit log entry was created\")\n                return False\n            \n            # Check latest audit entry\n            cur.execute(\n                \"\"\"\n                SELECT transfer_status, quantity_transferred, transfer_reason\n                FROM inventory_transfer_log\n                ORDER BY log_id DESC\n                LIMIT 1\n                \"\"\"\n            )\n            audit_entry = cur.fetchone()\n            \n            if not audit_entry:\n                print(\"‚ùå FAIL: Could not retrieve audit log entry\")\n                return False\n            \n            status, qty_transferred, trans_reason = audit_entry\n            \n            if status != 'success':\n                print(f\"‚ùå FAIL: Transfer status should be 'success', got '{status}'\")\n                return False\n            \n            if qty_transferred != transfer_qty or trans_reason != reason:\n                print(f\"‚ùå FAIL: Audit log details don't match transfer parameters\")\n                return False\n        \n        expected_source = source_initial - transfer_qty\n        expected_target = target_initial + transfer_qty\n        \n        if source_final != expected_source:\n            print(f\"‚ùå FAIL: Source quantity mismatch. Expected {expected_source}, got {source_final}\")\n        elif target_final != expected_target:\n            print(f\"‚ùå FAIL: Target quantity mismatch. Expected {expected_target}, got {target_final}\")\n        else:\n            print(\"‚úÖ PASS: Successful transfer with audit logging completed correctly\")\n            passed = True\n            \n    except psycopg2.Error as e:\n        print(f\"‚ùå FAIL: Transfer failed unexpectedly with error: {e}\")\n    finally:\n        conn.rollback()\n    return passed\n\n\ndef verify_new_part_transfer(conn) -> bool:\n    \"\"\"Test transferring a part to an inventory that doesn't have it.\"\"\"\n    print(\"\\n-- Verifying New Part Transfer --\")\n    passed = False\n    try:\n        # Test data: Transfer red bricks to Mosaic Johnny Thunder (which doesn't have them)\n        source_id = 11124  # Giant Lego Dacta Basic Set (has red bricks)\n        target_id = 14686  # Lego Mosaic Johnny Thunder (doesn't have red bricks)\n        part_num = '3001'\n        color_id = 4\n        transfer_qty = 50\n        reason = 'part_redistribution'\n        \n        target_initial = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        if target_initial != 0:\n            print(f\"‚ùå FAIL: Pre-condition failed. Target already has {target_initial} of this part, expected 0\")\n            return False\n        \n        source_initial = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        print(f\"Initial quantities - Source: {source_initial}, Target: {target_initial}\")\n        \n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                (source_id, target_id, part_num, color_id, transfer_qty, reason)\n            )\n            result = cur.fetchone()\n            print(f\"Transfer result: {result[0]}\")\n        \n        source_final = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        target_final = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        print(f\"Final quantities - Source: {source_final}, Target: {target_final}\")\n        \n        expected_source = source_initial - transfer_qty\n        expected_target = transfer_qty\n        \n        if source_final != expected_source:\n            print(f\"‚ùå FAIL: Source quantity mismatch. Expected {expected_source}, got {source_final}\")\n        elif target_final != expected_target:\n            print(f\"‚ùå FAIL: Target quantity mismatch. Expected {expected_target}, got {target_final}\")\n        else:\n            print(\"‚úÖ PASS: New part transfer completed correctly\")\n            passed = True\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå FAIL: Transfer failed unexpectedly with error: {e}\")\n    finally:\n        conn.rollback()\n    return passed\n\n\ndef verify_business_rule_validation(conn) -> bool:\n    \"\"\"Test business rule validation including quantity limits and self-transfer prevention.\"\"\"\n    print(\"\\n-- Verifying Business Rule Validation --\")\n    \n    # Test 1: Self-transfer (should fail)\n    print(\"Test 1: Self-transfer (should fail)\")\n    test1_passed = False\n    try:\n        source_id = 14469\n        part_num = '3024'\n        color_id = 15\n        transfer_qty = 10\n        reason = 'self_transfer'\n        \n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                (source_id, source_id, part_num, color_id, transfer_qty, reason)\n            )\n            result = cur.fetchone()\n            print(f\"‚ùå FAIL: Self-transfer should have failed but succeeded: {result[0]}\")\n    except psycopg2.Error:\n        print(f\"‚úÖ PASS: Self-transfer correctly failed\")\n        test1_passed = True\n    except Exception as e:\n        print(f\"‚ùå FAIL: Self-transfer test failed with unexpected error: {e}\")\n    finally:\n        conn.rollback() # Rollback after first test\n\n    # Test 2: Transfer quantity exceeds maximum (should fail)\n    print(\"Test 2: Transfer quantity exceeds maximum (should fail)\")\n    test2_passed = False\n    try:\n        source_id = 14469\n        target_id = 14686\n        part_num = '3024'\n        color_id = 15\n        \n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                (source_id, target_id, part_num, color_id, 600, 'large_transfer')\n            )\n            result = cur.fetchone()\n            print(f\"‚ùå FAIL: Large transfer should have failed but succeeded: {result[0]}\")\n    except psycopg2.Error:\n        print(f\"‚úÖ PASS: Large transfer correctly failed\")\n        test2_passed = True\n    except Exception as e:\n        print(f\"‚ùå FAIL: Large transfer test failed with unexpected error: {e}\")\n    finally:\n        conn.rollback() # Rollback after second test\n\n    # Test 3: Transfer quantity below minimum (should fail)\n    print(\"Test 3: Transfer quantity below minimum (should fail)\")\n    test3_passed = False\n    try:\n        source_id = 14469\n        target_id = 14686\n        part_num = '3024'\n        color_id = 15\n\n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                (source_id, target_id, part_num, color_id, 0, 'zero_transfer')\n            )\n            result = cur.fetchone()\n            print(f\"‚ùå FAIL: Zero transfer should have failed but succeeded: {result[0]}\")\n    except psycopg2.Error:\n        print(f\"‚úÖ PASS: Zero transfer correctly failed\")\n        test3_passed = True\n    except Exception as e:\n        print(f\"‚ùå FAIL: Zero transfer test failed with unexpected error: {e}\")\n    finally:\n        conn.rollback() # Rollback after third test\n\n    return test1_passed and test2_passed and test3_passed\n\n\ndef verify_insufficient_quantity_error(conn) -> bool:\n    \"\"\"Test that transfer fails when source has insufficient quantity.\"\"\"\n    print(\"\\n-- Verifying Insufficient Quantity Error --\")\n    passed = False\n    try:\n        source_id = 14469\n        target_id = 14686\n        part_num = '3024'\n        color_id = 15\n        transfer_qty = 99999  # Far more than available\n        reason = 'insufficient_test'\n        \n        source_initial = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        target_initial = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        print(f\"Initial quantities - Source: {source_initial}, Target: {target_initial}\")\n        \n        with conn.cursor() as cur:\n            try:\n                cur.execute(\n                    \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                    (source_id, target_id, part_num, color_id, transfer_qty, reason)\n                )\n                result = cur.fetchone()\n                print(f\"‚ùå FAIL: Transfer should have failed but succeeded: {result[0]}\")\n            except psycopg2.Error as e:\n                print(f\"‚úÖ PASS: Transfer correctly failed with an exception.\")\n                # After an exception, the transaction is in an aborted state. Must rollback before new queries.\n                conn.rollback()\n                \n                source_final = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n                target_final = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n                \n                if source_final != source_initial:\n                    print(f\"‚ùå FAIL: Source quantity changed from {source_initial} to {source_final}\")\n                elif target_final != target_initial:\n                    print(f\"‚ùå FAIL: Target quantity changed from {target_initial} to {target_final}\")\n                else:\n                    print(\"‚úÖ PASS: Database state unchanged after failed transfer\")\n                    passed = True\n    finally:\n        conn.rollback()\n    return passed\n\n\ndef verify_invalid_inventory_error(conn) -> bool:\n    \"\"\"Test that transfer fails with invalid inventory IDs.\"\"\"\n    print(\"\\n-- Verifying Invalid Inventory Error --\")\n    passed = False\n    try:\n        source_id = 99999  # Non-existent inventory\n        target_id = 14686\n        part_num = '3024'\n        color_id = 15\n        transfer_qty = 10\n        reason = 'invalid_test'\n        \n        target_initial = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        \n        with conn.cursor() as cur:\n            try:\n                cur.execute(\n                    \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                    (source_id, target_id, part_num, color_id, transfer_qty, reason)\n                )\n                result = cur.fetchone()\n                print(f\"‚ùå FAIL: Transfer should have failed but succeeded: {result[0]}\")\n            except psycopg2.Error as e:\n                print(f\"‚úÖ PASS: Transfer correctly failed with an exception.\")\n                # Rollback the aborted transaction\n                conn.rollback()\n                \n                target_final = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n                if target_final != target_initial:\n                    print(f\"‚ùå FAIL: Target quantity changed from {target_initial} to {target_final}\")\n                else:\n                    print(\"‚úÖ PASS: Database state unchanged after invalid inventory error\")\n                    passed = True\n    finally:\n        conn.rollback()\n    return passed\n\n\ndef verify_audit_logging(conn) -> bool:\n    \"\"\"\n    Test that audit logging captures both successful and failed transfers.\n    This function uses commits to separate test cases and work around the\n    transactional paradox of logging a failure within a transaction that\n    is about to be rolled back by the client.\n    \"\"\"\n    print(\"\\n-- Verifying Audit Logging --\")\n    \n    # Part 1: Test success logging\n    print(\"Part 1: Verifying success log entry...\")\n    success_passed = False\n    try:\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT COUNT(*) FROM inventory_transfer_log\")\n            initial_count = cur.fetchone()[0]\n\n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(14469, 14686, '3024', 15, 5, 'audit_test_success')\"\n            )\n        \n        # Check the log before committing/rolling back\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT COUNT(*) FROM inventory_transfer_log\")\n            final_count = cur.fetchone()[0]\n            if final_count == initial_count + 1:\n                print(\"‚úÖ PASS: Success log was correctly written within the transaction.\")\n                success_passed = True\n            else:\n                print(\"‚ùå FAIL: Success log was not created.\")\n\n    except Exception as e:\n        print(f\"‚ùå FAIL: Success logging test threw an unexpected error: {e}\")\n    finally:\n        conn.rollback() # Clean up the transaction for the next part\n\n    if not success_passed:\n        return False\n\n    # Part 2: Test failure logging\n    print(\"\\nPart 2: Verifying failure log entry...\")\n    failure_passed = False\n    try:\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT COUNT(*) FROM inventory_transfer_log\")\n            initial_count = cur.fetchone()[0]\n        \n        try:\n            with conn.cursor() as cur:\n                cur.execute(\n                    \"SELECT transfer_parts(14469, 14469, '3024', 15, 5, 'audit_test_fail')\"\n                )\n        except psycopg2.Error:\n            # This is the expected failure path.\n            # The function should have logged the failure before raising the error.\n            # Now, we check the log table.\n            pass\n        \n        # The transaction is now in an aborted state. We must rollback to issue new commands.\n        conn.rollback()\n\n        with conn.cursor() as cur:\n            cur.execute(\"SELECT COUNT(*) FROM inventory_transfer_log\")\n            final_count = cur.fetchone()[0]\n            if final_count == initial_count:\n                 print(\"‚úÖ PASS: Failure log was correctly rolled back as expected in a standard transaction.\")\n                 failure_passed = True\n            else:\n                print(\"‚ùå FAIL: Failure log was not rolled back. This implies a non-standard transaction behavior.\")\n                print(f\"Log count before: {initial_count}, Log count after: {final_count}\")\n\n    except Exception as e:\n        print(f\"‚ùå FAIL: Failure logging test threw an unexpected error: {e}\")\n    finally:\n        conn.rollback() # Ensure cleanup\n\n    return success_passed and failure_passed\n\n\ndef verify_exact_quantity_transfer(conn) -> bool:\n    \"\"\"Test transferring exact quantity (should delete source row when quantity becomes 0).\"\"\"\n    print(\"\\n-- Verifying Exact Quantity Transfer --\")\n    passed = False\n    target_id = 14686  # Use a fixed target inventory\n    \n    try:\n        # Find a part with a small quantity that doesn't conflict with the target inventory\n        with conn.cursor() as cur:\n            cur.execute(\n                \"\"\"\n                SELECT inventory_id, part_num, color_id, quantity\n                FROM public.lego_inventory_parts\n                WHERE quantity BETWEEN 5 AND 20 AND inventory_id != %s\n                LIMIT 1\n                \"\"\",\n                (target_id,)\n            )\n            result = cur.fetchone()\n            if not result:\n                print(\"‚ö†Ô∏è SKIP: No suitable part found for exact quantity test\")\n                return True\n            \n            source_id, part_num, color_id, exact_qty = result\n        \n        print(f\"Testing exact transfer: {exact_qty} parts of '{part_num}' from inventory {source_id} to {target_id}\")\n        \n        source_initial = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        target_initial = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        print(f\"Initial quantities - Source: {source_initial}, Target: {target_initial}\")\n\n        with conn.cursor() as cur:\n            cur.execute(\n                \"SELECT transfer_parts(%s, %s, %s, %s, %s, %s)\",\n                (source_id, target_id, part_num, color_id, exact_qty, 'exact_transfer')\n            )\n            print(f\"Transfer result: {cur.fetchone()[0]}\")\n        \n        source_final = get_inventory_part_quantity(conn, source_id, part_num, color_id)\n        target_final = get_inventory_part_quantity(conn, target_id, part_num, color_id)\n        print(f\"Final quantities - Source: {source_final}, Target: {target_final}\")\n        \n        expected_source = 0\n        expected_target = target_initial + exact_qty\n        \n        if source_final != expected_source:\n            print(f\"‚ùå FAIL: Source quantity should be 0 (row deleted), but got {source_final}\")\n        elif target_final != expected_target:\n            print(f\"‚ùå FAIL: Target quantity mismatch. Expected {expected_target}, got {target_final}\")\n        else:\n            print(\"‚úÖ PASS: Exact quantity transfer completed correctly (source row deleted)\")\n            passed = True\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå FAIL: Transfer failed unexpectedly with error: {e}\")\n    finally:\n        conn.rollback()\n    return passed\n\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 60)\n    print(\"LEGO Enhanced Inventory Transfer Function Verification Script\")\n    print(\"=\" * 60)\n\n    conn_params = get_connection_params()\n    if not conn_params.get(\"database\"):\n        print(\"‚ùå CRITICAL: POSTGRES_DATABASE environment variable not set.\")\n        sys.exit(1)\n\n    conn = None\n    try:\n        conn = psycopg2.connect(**conn_params)\n        conn.autocommit = False  # Ensure we can control transactions manually\n\n        # Run all verification steps\n        results = [\n            verify_system_components(conn),\n            verify_successful_transfer_with_audit(conn),\n            verify_new_part_transfer(conn),\n            verify_business_rule_validation(conn),\n            verify_insufficient_quantity_error(conn),\n            verify_invalid_inventory_error(conn),\n            verify_audit_logging(conn),\n            verify_exact_quantity_transfer(conn),\n        ]\n\n        if all(results):\n            print(\"\\nüéâ Overall Result: PASS - All verification steps completed successfully!\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Overall Result: FAIL - One or more verification steps failed.\")\n            sys.exit(1)\n\n    except psycopg2.OperationalError as e:\n        print(f\"‚ùå CRITICAL: Could not connect to the database. Details: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå CRITICAL: An unexpected error occurred. Details: {e}\")\n        sys.exit(1)\n    finally:\n        if conn:\n            conn.close()\n\n\nif __name__ == \"__main__\":\n    main()\n"
}