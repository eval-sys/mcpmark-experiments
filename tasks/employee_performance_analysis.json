{
  "task_id": "employee_performance_analysis",
  "task_name": "Employee Performance Analysis",
  "category_id": "employees",
  "category_name": "Employees",
  "description": "Create performance evaluation system analyzing career progression patterns and salary equity for promotion and compensation decisions.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-14",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "statistical aggregation",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Create a comprehensive employee performance evaluation system that analyzes career progression patterns and salary equity across our organization. The executive team needs data-driven insights for upcoming promotion decisions and salary adjustment planning.\n\n## Your Tasks:\n\n1. **Create the employee performance analysis table** ‚Äî build a table called `employee_performance_analysis` in the `employees` schema with these exact columns:\n   * `employee_id` (bigint) ‚Äî the employee's ID\n   * `performance_category` (varchar) ‚Äî classification of employee performance ('high_achiever', 'steady_performer', 'needs_attention')\n   * `salary_growth_rate` (decimal) ‚Äî percentage salary increase from first salary record to current\n   * `days_of_service` (integer) ‚Äî total days with the company\n   * `promotion_count` (integer) ‚Äî number of different titles held\n\n2. **Analyze only current employees** ‚Äî focus on employees who currently have active salary records (to_date = '9999-01-01').\n\n3. **Apply performance classification rules**:\n   * **High achievers**: Salary growth rate > 40% AND more than 1 title held\n   * **Needs attention**: Salary growth rate < 15% AND more than 3650 days of service (10 years)\n   * **Steady performers**: All other current employees (default category)\n\n4. **Create the department salary analysis table** ‚Äî build a table called `department_salary_analysis` in the `employees` schema with:\n   * `department_name` (varchar) ‚Äî the department name\n   * `avg_current_salary` (decimal) ‚Äî average current salary in the department (only current employees)\n   * `employee_count` (integer) ‚Äî total current employees in the department\n   * `salary_range_spread` (integer) ‚Äî difference between max and min salary (current employees only)\n\n5. **Calculate salary equity metrics** ‚Äî populate the department table with current salary statistics for active employees only to identify potential pay equity issues across departments.\n\nThe analysis should help leadership make informed decisions about promotions, salary adjustments, and talent retention strategies.",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 1: Employee Performance Analysis\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.1 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.1:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_performance_results(conn) -> bool:\n    \"\"\"Verify the employee performance analysis results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT employee_id, performance_category, salary_growth_rate, \n                   days_of_service, promotion_count\n            FROM employees.employee_performance_analysis \n            ORDER BY employee_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query - use first salary record as starting salary\n        cur.execute(\"\"\"\n            WITH current_salary AS (\n            SELECT employee_id, amount AS current_amount\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (PARTITION BY s.employee_id\n                                        ORDER BY s.from_date DESC, s.amount DESC) AS rn\n                FROM employees.salary s\n                WHERE s.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            first_salary AS (\n            SELECT employee_id, amount AS first_amount\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (PARTITION BY s.employee_id\n                                        ORDER BY s.from_date ASC, s.amount ASC) AS rn\n                FROM employees.salary s\n            ) x\n            WHERE rn = 1\n            ),\n            title_counts AS (\n            SELECT t.employee_id, COUNT(DISTINCT t.title) AS promotion_count\n            FROM employees.title t\n            GROUP BY t.employee_id\n            ),\n            base AS (\n            SELECT e.id AS employee_id,\n                    e.hire_date,\n                    cs.current_amount,\n                    fs.first_amount,\n                    COALESCE(tc.promotion_count, 0) AS promotion_count\n            FROM employees.employee e\n            JOIN current_salary cs ON cs.employee_id = e.id\n            JOIN first_salary  fs ON fs.employee_id = e.id\n            LEFT JOIN title_counts tc ON tc.employee_id = e.id\n            ),\n            scored AS (\n            SELECT\n                employee_id,\n                ((current_amount - first_amount) / NULLIF(first_amount, 0)::NUMERIC) * 100 AS salary_growth_rate,\n                (CURRENT_DATE - hire_date)::INTEGER AS days_of_service,\n                promotion_count\n            FROM base\n            )\n            SELECT\n            s.employee_id,\n            CASE\n                WHEN s.salary_growth_rate > 40 AND s.promotion_count > 1 THEN 'high_achiever'\n                WHEN s.salary_growth_rate < 15 AND s.days_of_service > 3650 THEN 'needs_attention'\n                ELSE 'steady_performer'\n            END AS performance_category,\n            s.salary_growth_rate,\n            s.days_of_service,\n            s.promotion_count AS promotion_count\n            FROM scored s\n            ORDER BY s.employee_id;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} performance results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Employee performance results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_department_results(conn) -> bool:\n    \"\"\"Verify the department salary analysis results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT department_name, avg_current_salary, employee_count, salary_range_spread\n            FROM employees.department_salary_analysis\n            ORDER BY department_name\n        \"\"\")\n        actual_results = cur.fetchall()\n\n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH current_salary AS (\n            SELECT employee_id, amount\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (PARTITION BY s.employee_id\n                                        ORDER BY s.from_date DESC, s.amount DESC) AS rn\n                FROM employees.salary s\n                WHERE s.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            current_dept AS (\n            SELECT DISTINCT de.employee_id, de.department_id\n            FROM employees.department_employee de\n            WHERE de.to_date = DATE '9999-01-01'\n            )\n            SELECT \n            d.dept_name AS department_name,\n            AVG(cs.amount)::DECIMAL AS avg_current_salary,\n            COUNT(DISTINCT cd.employee_id) AS employee_count,\n            (MAX(cs.amount) - MIN(cs.amount)) AS salary_range_spread\n            FROM employees.department d\n            JOIN current_dept cd ON cd.department_id = d.id\n            JOIN current_salary cs ON cs.employee_id = cd.employee_id\n            GROUP BY d.id, d.dept_name\n            ORDER BY d.dept_name;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} department results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Department salary results are correct ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify results\n        success = verify_performance_results(conn) and verify_department_results(conn)\n\n        conn.close()\n\n        if success:\n            print(\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}