{
  "task_id": "label_color_standardization",
  "task_name": "Label Color Standardization",
  "category_id": "claude-code",
  "category_name": "Claude Code",
  "description": "Standardize label colors from default gray to a comprehensive color scheme for better visual organization and issue triage.",
  "author": "Zijian Wu",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "issue management",
    "workflow automation"
  ],
  "mcp": [
    "github"
  ],
  "meta_data": {
    "stateType": "url",
    "stateContent": null,
    "stateUrl": "https://github.com/mcpmark-source/claude-code",
    "stateOriginalUrl": "https://github.com/anthropics/claude-code"
  },
  "instruction": "I need you to implement a comprehensive label documentation and organization workflow for the repository.\n\n**Step 1: Create Label Documentation Issue**\nCreate a new issue with:\n- Title containing: \"Document label organization for better visual organization\" and \"label guide\"\n- Body must include:\n  - A \"## Problem\" heading describing the need for better label documentation\n  - A \"## Proposed Solution\" heading about creating a comprehensive label guide for different label categories\n  - A \"## Benefits\" heading listing improved visual organization and easier issue triage\n  - Keywords: \"label documentation\", \"visual organization\", \"label guide\", \"organization\"\n- Labels: Initially add \"enhancement\" and \"documentation\" labels to the issue\n\n**Step 2: Create Feature Branch**\nCreate a new branch called 'feat/label-color-guide' from main.\n\n**Step 3: Create Label Documentation**\nOn the feature branch, create the file `docs/LABEL_COLORS.md` with:\n- A \"# Label Organization Guide\" title\n- A \"## Label Categories\" section with a table that MUST follow this exact format:\n```markdown\n| Label Name | Category | Description |\n|------------|----------|-------------|\n```\nThe table must include ALL existing labels in the repository. For each label:\n- Group labels by category (e.g., issue-type, platform, area, status, performance)\n- Include a description for each label\n\n- A \"## Usage Guidelines\" section explaining when to use each label category\n\n**Step 4: Apply ALL Labels to the Documentation Issue**\nUpdate the issue you created in Step 1 by adding ALL existing labels from the repository. This serves as a visual demonstration of the label organization. The issue should have every single label that exists in the repository applied to it.\n\n**Step 5: Create Pull Request**\nCreate a pull request from 'feat/label-color-guide' to 'main' with:\n- Title containing: \"Add label organization guide\" and \"visual organization\"  \n- Body must include:\n  - A \"## Summary\" heading explaining the label organization documentation\n  - A \"## Changes\" heading with a bullet list of what was added\n  - \"Fixes #[ISSUE_NUMBER]\" pattern linking to your created issue\n  - A \"## Verification\" section stating that all labels have been documented\n  - Keywords: \"label documentation\", \"organization guide\", \"visual improvement\", \"documentation\"\n- Labels: Add a reasonable subset of labels to the PR (at least 5-10 labels from different categories)\n\n**Step 6: Document Changes in Issue**\nAdd a comment to the original issue with:\n- Confirmation that the label documentation has been created\n- Total count of labels documented\n- Reference to the PR using \"PR #[NUMBER]\" pattern\n- Keywords: \"documentation created\", \"label guide complete\", \"organization complete\"",
  "verify": "import sys\nimport os\nimport requests\nfrom typing import Dict, List, Optional, Tuple\nfrom dotenv import load_dotenv\n\n\ndef _get_github_api(\n    endpoint: str, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> Tuple[bool, Optional[Dict]]:\n    \"\"\"Make a GET request to GitHub API and return (success, response).\"\"\"\n    url = f\"https://api.github.com/repos/{org}/{repo}/{endpoint}\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return True, response.json()\n        elif response.status_code == 404:\n            return False, None\n        else:\n            print(f\"API error for {endpoint}: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Exception for {endpoint}: {e}\", file=sys.stderr)\n        return False, None\n\n\n\ndef _check_branch_exists(\n    branch_name: str, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> bool:\n    \"\"\"Verify that a branch exists in the repository.\"\"\"\n    success, _ = _get_github_api(f\"branches/{branch_name}\", headers, org, repo)\n    return success\n\n\ndef _check_file_content(\n    branch: str,\n    file_path: str,\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"claude-code\",\n) -> Optional[str]:\n    \"\"\"Get file content from a branch.\"\"\"\n    import base64\n\n    success, result = _get_github_api(\n        f\"contents/{file_path}?ref={branch}\", headers, org, repo\n    )\n    if not success or not result:\n        return None\n\n    if result.get(\"content\"):\n        try:\n            content = base64.b64decode(result.get(\"content\", \"\")).decode(\"utf-8\")\n            return content\n        except Exception as e:\n            print(f\"Content decode error for {file_path}: {e}\", file=sys.stderr)\n            return None\n\n    return None\n\n\ndef _parse_label_table(content: str) -> List[str]:\n    \"\"\"Parse the label table from markdown content and return label names.\"\"\"\n    documented_labels = []\n\n    # Find the table in the content\n    lines = content.split(\"\\n\")\n    in_table = False\n\n    for line in lines:\n        # Skip header and separator lines\n        if \"| Label Name | Category |\" in line:\n            in_table = True\n            continue\n        if in_table and line.startswith(\"|---\"):\n            continue\n\n        # Parse table rows\n        if in_table and line.startswith(\"|\"):\n            parts = [p.strip() for p in line.split(\"|\")]\n            if len(parts) >= 3:  # Should have at least label, category\n                label_name = parts[1].strip()\n                if label_name:\n                    documented_labels.append(label_name)\n\n        # Stop at end of table\n        if in_table and line and not line.startswith(\"|\"):\n            break\n\n    return documented_labels\n\n\ndef _find_issue_by_title_keywords(\n    title_keywords: List[str],\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"claude-code\",\n) -> Optional[Dict]:\n    \"\"\"Find an issue by title keywords and return the issue data.\"\"\"\n    for state in [\"open\", \"closed\"]:\n        success, issues = _get_github_api(\n            f\"issues?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and issues:\n            for issue in issues:\n                # Skip pull requests\n                if \"pull_request\" in issue:\n                    continue\n                title = issue.get(\"title\", \"\").lower()\n                if all(keyword.lower() in title for keyword in title_keywords):\n                    return issue\n    return None\n\n\ndef _find_pr_by_title_keywords(\n    title_keywords: List[str],\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"claude-code\",\n) -> Optional[Dict]:\n    \"\"\"Find a PR by title keywords and return the PR data.\"\"\"\n    for state in [\"open\", \"closed\"]:\n        success, prs = _get_github_api(\n            f\"pulls?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and prs:\n            for pr in prs:\n                title = pr.get(\"title\", \"\").lower()\n                if all(keyword.lower() in title for keyword in title_keywords):\n                    return pr\n    return None\n\n\ndef _get_issue_comments(\n    issue_number: int, headers: Dict[str, str], org: str, repo: str = \"claude-code\"\n) -> List[Dict]:\n    \"\"\"Get all comments for an issue.\"\"\"\n    success, comments = _get_github_api(\n        f\"issues/{issue_number}/comments\", headers, org, repo\n    )\n    if success and comments:\n        return comments\n    return []\n\n\n\n\ndef verify() -> bool:\n    \"\"\"\n    Programmatically verify that the label color standardization workflow meets the\n    requirements described in description.md.\n    \"\"\"\n    # Load environment variables from .mcp_env\n    load_dotenv(\".mcp_env\")\n\n    # Get GitHub token and org\n    github_token = os.environ.get(\"MCP_GITHUB_TOKEN\")\n    github_org = os.environ.get(\"GITHUB_EVAL_ORG\")\n\n    if not github_token:\n        print(\"Error: MCP_GITHUB_TOKEN environment variable not set\", file=sys.stderr)\n        return False\n\n    if not github_org:\n        print(\"Error: GITHUB_EVAL_ORG environment variable not set\", file=sys.stderr)\n        return False\n\n    # Configuration constants\n    BRANCH_NAME = \"feat/label-color-guide\"\n\n    # Issue requirements\n    ISSUE_TITLE_KEYWORDS = [\"Document label organization\", \"label guide\"]\n    ISSUE_KEYWORDS = [\n        \"label documentation\",\n        \"visual organization\",\n        \"label guide\",\n        \"organization\",\n    ]\n\n    # PR requirements\n    PR_TITLE_KEYWORDS = [\"label organization guide\", \"visual organization\"]\n    PR_KEYWORDS = [\n        \"label documentation\",\n        \"organization guide\",\n        \"visual improvement\",\n        \"documentation\",\n    ]\n\n    # All expected labels in the repository that are actually used/discoverable via MCP tools\n    # Note: Excludes 'wontfix', 'invalid', 'good first issue', 'help wanted' as they exist\n    # in the repository but are not used by any issues (not discoverable via MCP search)\n    ALL_EXPECTED_LABELS = [\n        \"bug\",\n        \"enhancement\",\n        \"duplicate\",\n        \"question\",\n        \"documentation\",\n        \"platform:macos\",\n        \"platform:linux\",\n        \"platform:windows\",\n        \"area:core\",\n        \"area:tools\",\n        \"area:tui\",\n        \"area:ide\",\n        \"area:mcp\",\n        \"area:api\",\n        \"area:security\",\n        \"area:model\",\n        \"area:auth\",\n        \"area:packaging\",\n        \"has repro\",\n        \"memory\",\n        \"perf:memory\",\n        \"external\",\n    ]\n\n    headers = {\n        \"Authorization\": f\"token {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    # Run verification checks\n    print(\"Verifying label color standardization workflow completion...\")\n\n    # 1. Check that feature branch exists\n    print(\"1. Verifying feature branch exists...\")\n    if not _check_branch_exists(BRANCH_NAME, headers, github_org):\n        print(f\"Error: Branch '{BRANCH_NAME}' not found\", file=sys.stderr)\n        return False\n\n    # 2. Check documentation file exists and has correct format\n    print(\"2. Verifying label documentation file...\")\n    doc_content = _check_file_content(\n        BRANCH_NAME, \"docs/LABEL_COLORS.md\", headers, github_org\n    )\n    if not doc_content:\n        print(\"Error: docs/LABEL_COLORS.md not found\", file=sys.stderr)\n        return False\n\n    # Parse the label table from documentation\n    documented_labels = _parse_label_table(doc_content)\n    if len(documented_labels) < 20:\n        print(\n            f\"Error: Documentation table incomplete, found only {len(documented_labels)} labels\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 3. Verify labels are documented\n    print(\"3. Verifying expected labels are documented...\")\n    print(f\"  ✓ {len(ALL_EXPECTED_LABELS)} expected labels defined for verification\")\n\n    # 4. Find the created issue\n    print(\"4. Verifying issue creation...\")\n    issue = _find_issue_by_title_keywords(ISSUE_TITLE_KEYWORDS, headers, github_org)\n    if not issue:\n        print(\n            \"Error: Issue with title containing required keywords not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    issue_number = issue.get(\"number\")\n    issue_body = issue.get(\"body\", \"\")\n\n    # Check issue content has required sections and keywords\n    issue_required_sections = [\"## Problem\", \"## Proposed Solution\", \"## Benefits\"]\n    for section in issue_required_sections:\n        if section not in issue_body:\n            print(f\"Error: Issue body missing required section: {section}\", file=sys.stderr)\n            return False\n\n    # Check issue has required keywords\n    if not all(keyword.lower() in issue_body.lower() for keyword in ISSUE_KEYWORDS):\n        missing_keywords = [kw for kw in ISSUE_KEYWORDS if kw.lower() not in issue_body.lower()]\n        print(f\"Error: Issue body missing required keywords: {missing_keywords}\", file=sys.stderr)\n        return False\n\n    # Check issue has initial required labels (enhancement and documentation)\n    issue_label_names = [label[\"name\"] for label in issue.get(\"labels\", [])]\n    initial_required_labels = [\"enhancement\", \"documentation\"]\n    for required_label in initial_required_labels:\n        if required_label not in issue_label_names:\n            print(f\"Error: Issue missing initial required label: {required_label}\", file=sys.stderr)\n            return False\n\n    # 5. Find the created PR\n    print(\"5. Verifying pull request creation...\")\n    pr = _find_pr_by_title_keywords(PR_TITLE_KEYWORDS, headers, github_org)\n    if not pr:\n        print(\n            \"Error: PR with title containing required keywords not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    pr_number = pr.get(\"number\")\n    pr_body = pr.get(\"body\", \"\")\n    pr_labels = pr.get(\"labels\", [])\n\n    # Check PR references issue with correct pattern\n    if f\"Fixes #{issue_number}\" not in pr_body and f\"fixes #{issue_number}\" not in pr_body:\n        print(f\"Error: PR does not contain 'Fixes #{issue_number}' pattern\", file=sys.stderr)\n        return False\n\n    # Check PR body has required sections and keywords\n    pr_required_sections = [\"## Summary\", \"## Changes\", \"## Verification\"]\n    for section in pr_required_sections:\n        if section not in pr_body:\n            print(f\"Error: PR body missing required section: {section}\", file=sys.stderr)\n            return False\n\n    # Check PR has required keywords\n    if not all(keyword.lower() in pr_body.lower() for keyword in PR_KEYWORDS):\n        missing_keywords = [kw for kw in PR_KEYWORDS if kw.lower() not in pr_body.lower()]\n        print(f\"Error: PR body missing required keywords: {missing_keywords}\", file=sys.stderr)\n        return False\n\n    # Check PR has sufficient labels (at least 5 from different categories)\n    if len(pr_labels) < 5:\n        print(f\"Error: PR has only {len(pr_labels)} labels, needs at least 5\", file=sys.stderr)\n        return False\n\n    # 6. Verify issue has ALL expected/usable labels applied (demonstrates organization)\n    print(\"6. Verifying issue has all expected labels applied...\")\n    issue_label_names = [label[\"name\"] for label in issue.get(\"labels\", [])]\n    # Use our expected labels list instead of all repo labels (excludes unused labels)\n    expected_labels_to_check = ALL_EXPECTED_LABELS\n    missing_labels = []\n\n    for expected_label in expected_labels_to_check:\n        if expected_label not in issue_label_names:\n            missing_labels.append(expected_label)\n\n    if missing_labels:\n        print(\n            f\"Error: Issue missing {len(missing_labels)} expected labels: {missing_labels[:5]}...\",\n            file=sys.stderr,\n        )\n        return False\n\n    print(f\"  ✓ Issue has all {len(expected_labels_to_check)} expected labels applied\")\n\n    # 7. Verify issue has comment documenting changes\n    print(\"7. Verifying issue comment with documentation...\")\n    issue_comments = _get_issue_comments(issue_number, headers, github_org)\n\n    found_update_comment = False\n    comment_required_keywords = [\"documentation created\", \"label guide complete\", \"organization complete\"]\n    \n    for comment in issue_comments:\n        body = comment.get(\"body\", \"\")\n        # Check for PR reference and required keywords\n        if (f\"PR #{pr_number}\" in body and \n            any(keyword.lower() in body.lower() for keyword in comment_required_keywords) and\n            \"total\" in body.lower() and \"labels\" in body.lower()):\n            found_update_comment = True\n            break\n\n    if not found_update_comment:\n        print(\"Error: Issue missing comment documenting changes with required content\", file=sys.stderr)\n        print(\"  Comment should include: PR reference, label count, and completion keywords\", file=sys.stderr)\n        return False\n\n    # 8. Final verification of complete workflow\n    print(\"8. Final verification of workflow completion...\")\n    \n    # Skip repository label existence check - we trust that our expected labels \n    # are the ones actually discoverable/usable via MCP tools\n\n    # Ensure expected labels are documented (not all repo labels, since some are unused)\n    documented_label_count = len(documented_labels)\n    expected_label_count = len(ALL_EXPECTED_LABELS)\n\n    if documented_label_count < expected_label_count:\n        print(\n            f\"Error: Documentation incomplete - {documented_label_count} documented vs {expected_label_count} expected\",\n            file=sys.stderr,\n        )\n        return False\n\n    # Check that all expected labels are documented\n    missing_documented_labels = []\n    for expected_label in ALL_EXPECTED_LABELS:\n        if expected_label not in documented_labels:\n            missing_documented_labels.append(expected_label)\n\n    if missing_documented_labels:\n        print(\n            f\"Error: Documentation missing expected labels: {missing_documented_labels}\",\n            file=sys.stderr,\n        )\n        return False\n\n    print(f\"  ✓ All {expected_label_count} expected labels documented\")\n    print(f\"  ✓ All {len(ALL_EXPECTED_LABELS)} expected labels present and documented\")\n\n    print(\"\\n✓ All verification checks passed!\")\n    print(\"Label documentation workflow completed successfully:\")\n    print(\n        f\"  - Issue #{issue_number}: {issue.get('title')} (with all {len(issue_label_names)} labels)\"\n    )\n    print(f\"  - PR #{pr_number}: {pr.get('title')}\")\n    print(f\"  - Branch: {BRANCH_NAME}\")\n    print(\"  - Documentation: docs/LABEL_COLORS.md\")\n    print(f\"  - {expected_label_count} labels documented for better organization\")\n    return True\n\n\nif __name__ == \"__main__\":\n    success = verify()\n    sys.exit(0 if success else 1)\n"
}