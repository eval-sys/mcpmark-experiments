{
  "task_id": "sales_inventory_analysis",
  "task_name": "Sales Inventory Analysis",
  "category_id": "shopping_admin",
  "category_name": "Shopping Admin",
  "description": "Analyze sales patterns and inventory levels to optimize stock management, identify slow-moving items, predict demand trends, and generate restocking recommendations.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "comparative analysis",
    "inventory management"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "Perform a comprehensive sales and inventory analysis by extracting specific metrics from multiple sections of the Magento Admin panel.\n\n**Task Requirements:**\n\n1. Login with username 'admin' and password 'admin1234'\n\n2. To analyze product inventory and identify key items, check all products:\n   - Search for all products containing 'Sprite' in their name - count the exact number of results\n   - Clear the search and filter products by Quantity = 100.0000 - count how many products match\n   - Find the product with SKU 'WS12' - record its exact name and price\n\n3. To understand sales performance and order status, we need check all orders:\n   - Search for all orders with 'Pending' status - count the total number\n   - Find Grace Nguyen's Complete and the most cheap order - record the order ID (starts with \"000\")\n   - Find the order with the highest Grand Total - record the customer name and amount\n\n4. To examine bestselling products and search trends, from the main page:\n   - In the Bestsellers table, identify the product with most quantity but and lowest price - record its name and quantity sold\n   - Find 'Overnight Duffle' and record its exact price\n   - In the Top Search Terms table, find 'hollister' and record its position number (1st, 2nd, etc.)\n\n5. To analyze customer demographics and account information, go to All Customers:\n   - Search for customers with its email address containing 'costello' - count the results\n   - Find Sarah Miller's customer record - record her Group and extract Customer Since date\n\n6. To review payment status and billing information, navigate to Invoices:\n   - Find all invoices with 'Paid' status - count them\n   - Find the invoice for order #000000002 - record the Bill-to Name\n\n7. To provide a comprehensive report of all gathered data, compile all findings and output them in the following exact format:\n\n```\n<answer>\nSpriteProducts|count\nQuantity100Products|count\nWS12Info|name:price\nPendingOrders|count\nGraceOrderID|orderid\nHighestOrderInfo|customer:amount\nCheapProduct|name:quantity\nOvernightDufflePrice|price\nHollisterPosition|position\nCostelloCustomers|count\nSarahMillerInfo|group:date\nPaidInvoices|count\nInvoice002BillTo|name\n</answer>\n```\n\n**Example Output:**\n```\n<answer>\nSpriteProducts|XX\nQuantity100Products|XX\nWS12Info|Product Name Here:$XX.XX\nPendingOrders|X\nGraceOrderID|00000XXXX\nHighestOrderInfo|Customer Name:$XXX.XX\nCheapProduct|Product Name:XX\nOvernightDufflePrice|$XX.XX\nHollisterPosition|Xth\nCostelloCustomers|X\nSarahMillerInfo|Group Name:MMM DD, YYYY\nPaidInvoices|X\nInvoice002BillTo|Customer Name\n</answer>\n```",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nimport json\nfrom pathlib import Path\n\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n\n    try:\n        with open(messages_path, \"r\") as f:\n            messages = json.load(f)\n\n        # Find the last assistant message with type='message', status='completed'\n        for message in reversed(messages):\n            if (\n                message.get(\"role\") == \"assistant\"\n                and message.get(\"status\") == \"completed\"\n                and message.get(\"type\") == \"message\"\n            ):\n                content = message.get(\"content\", [])\n                for item in content:\n                    # Check for both 'text' and 'output_text' types\n                    if item.get(\"type\") in [\"text\", \"output_text\"]:\n                        return item.get(\"text\", \"\")\n\n        print(\"Warning: No assistant response found in messages\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef parse_answer_format(text):\n    \"\"\"\n    Parse the <answer>...</answer> format from the agent's output.\n    Returns a dictionary with the parsed values.\n    \"\"\"\n    if not text:\n        print(\"ERROR: No text provided to parse\", file=sys.stderr)\n        return None\n\n    # Look for <answer>...</answer> pattern\n    match = re.search(r\"<answer>(.*?)</answer>\", text, re.IGNORECASE | re.DOTALL)\n    if not match:\n        print(\"ERROR: No <answer>...</answer> tags found in the response\", file=sys.stderr)\n        print(\"Response text preview (first 200 chars):\", text[:200], file=sys.stderr)\n        return None\n\n    answer_content = match.group(1).strip()\n    print(f\"Found answer content with {len(answer_content)} characters\", file=sys.stderr)\n\n    # Parse each line\n    result = {}\n    lines = answer_content.split(\"\\n\")\n    \n    # Expected keys for this task\n    expected_keys = [\n        \"SpriteProducts\", \"Quantity100Products\", \"WS12Info\", \"PendingOrders\",\n        \"GraceOrderID\", \"HighestOrderInfo\", \"CheapProduct\", \"OvernightDufflePrice\",\n        \"HollisterPosition\", \"CostelloCustomers\", \"SarahMillerInfo\", \n        \"PaidInvoices\", \"Invoice002BillTo\"\n    ]\n\n    if len(lines) != 13:\n        print(f\"ERROR: Expected 13 lines in answer, got {len(lines)}\", file=sys.stderr)\n        print(f\"Lines found: {lines}\", file=sys.stderr)\n        return None\n\n    for i, line in enumerate(lines, 1):\n        if \"|\" not in line:\n            print(f\"ERROR: Line {i} does not contain pipe separator '|': '{line}'\", file=sys.stderr)\n            return None\n        \n        parts = line.split(\"|\", 1)\n        if len(parts) != 2:\n            print(f\"ERROR: Line {i} could not be split into key|value: '{line}'\", file=sys.stderr)\n            return None\n            \n        key, value = parts\n        result[key.strip()] = value.strip()\n    \n    # Check if all expected keys are present\n    missing_keys = set(expected_keys) - set(result.keys())\n    if missing_keys:\n        print(f\"ERROR: Missing expected keys: {missing_keys}\", file=sys.stderr)\n        print(f\"Keys found: {list(result.keys())}\", file=sys.stderr)\n        return None\n    \n    # Check for unexpected keys\n    extra_keys = set(result.keys()) - set(expected_keys)\n    if extra_keys:\n        print(f\"WARNING: Unexpected keys found: {extra_keys}\", file=sys.stderr)\n\n    return result\n\n\ndef load_expected_answer(label_path):\n    \"\"\"\n    Load the expected answer from label.txt file.\n    Returns a dictionary with the expected values.\n    \"\"\"\n    try:\n        with open(label_path, \"r\") as f:\n            lines = f.read().strip().split(\"\\n\")\n\n        expected = {}\n        for line in lines:\n            if \"|\" in line:\n                key, value = line.split(\"|\", 1)\n                expected[key.strip()] = value.strip()\n\n        return expected\n    except Exception as e:\n        print(f\"Error reading label file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef compare_answers(model_answer, expected_answer):\n    \"\"\"\n    Compare the model's answer with the expected answer.\n    Returns True if all key information matches, False otherwise.\n    \"\"\"\n    if not model_answer or not expected_answer:\n        return False\n\n    # Check each expected key\n    mismatches = []\n    for key, expected_value in expected_answer.items():\n        model_value = model_answer.get(key, \"\")\n\n        # Special handling for different types of values\n        if key == \"WS12Info\":\n            # Check if product name and price match (format: name:price)\n            if \":\" in expected_value and \":\" in model_value:\n                expected_name, expected_price = expected_value.rsplit(\":\", 1)\n                model_name, model_price = model_value.rsplit(\":\", 1)\n                # Normalize price format\n                expected_price_clean = expected_price.replace(\"$\", \"\").replace(\",\", \"\")\n                model_price_clean = model_price.replace(\"$\", \"\").replace(\",\", \"\")\n                if (\n                    expected_name != model_name\n                    or expected_price_clean != model_price_clean\n                ):\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n            else:\n                if expected_value != model_value:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n\n        elif key == \"GraceOrderID\":\n            # Order ID should start with \"000\" and match exactly\n            if not model_value.startswith(\"000\"):\n                mismatches.append(\n                    f\"{key}: expected to start with '000', got '{model_value}'\"\n                )\n            elif model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"HighestOrderInfo\":\n            # Check format customer:amount\n            if \":\" in expected_value and \":\" in model_value:\n                expected_customer, expected_amount = expected_value.rsplit(\":\", 1)\n                model_customer, model_amount = model_value.rsplit(\":\", 1)\n                # Normalize amount format\n                expected_amount_clean = expected_amount.replace(\"$\", \"\").replace(\n                    \",\", \"\"\n                )\n                model_amount_clean = model_amount.replace(\"$\", \"\").replace(\",\", \"\")\n                if (\n                    expected_customer != model_customer\n                    or expected_amount_clean != model_amount_clean\n                ):\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n            else:\n                if expected_value != model_value:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n\n        elif key == \"Position2Product\":\n            # Check if product name and quantity match\n            if \":\" in expected_value and \":\" in model_value:\n                expected_name, expected_qty = expected_value.rsplit(\":\", 1)\n                model_name, model_qty = model_value.rsplit(\":\", 1)\n                if expected_name != model_name or expected_qty != model_qty:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n            else:\n                if expected_value != model_value:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n\n        elif key == \"OvernightDufflePrice\":\n            # Normalize price format\n            expected_clean = expected_value.replace(\"$\", \"\").replace(\",\", \"\")\n            model_clean = model_value.replace(\"$\", \"\").replace(\",\", \"\")\n            if expected_clean != model_clean:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"HollisterPosition\":\n            # Position format (1st, 2nd, 3rd, etc.)\n            if model_value.lower() != expected_value.lower():\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"SarahMillerInfo\":\n            # Format: group:date\n            if \":\" in expected_value and \":\" in model_value:\n                expected_group, expected_date = expected_value.split(\":\", 1)\n                model_group, model_date = model_value.split(\":\", 1)\n                # Allow some flexibility in date format\n                if expected_group != model_group:\n                    mismatches.append(\n                        f\"{key}: expected group '{expected_group}', got '{model_group}'\"\n                    )\n                # For date, check if key parts match\n                if not (expected_date in model_date or model_date in expected_date):\n                    mismatches.append(\n                        f\"{key}: expected date '{expected_date}', got '{model_date}'\"\n                    )\n            else:\n                if expected_value != model_value:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n\n        elif key == \"Invoice002BillTo\":\n            # Name should match exactly\n            if model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        else:\n            # Exact match for count fields and other numeric values\n            if model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n    if mismatches:\n        print(\"\\n=== Answer Comparison Mismatches ===\", file=sys.stderr)\n        for mismatch in mismatches:\n            print(f\"✗ {mismatch}\", file=sys.stderr)\n        return False\n\n    print(\"\\n=== Answer Comparison ===\", file=sys.stderr)\n    print(\"✓ All key information matches the expected answer\", file=sys.stderr)\n    return True\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the sales and inventory analysis task has been completed correctly.\n    First checks the model's answer against the expected label,\n    then optionally verifies the actual state in the Magento Admin.\n    \"\"\"\n    print(\"\\n\" + \"=\"*60, file=sys.stderr)\n    print(\"Starting verification of Task 5\", file=sys.stderr)\n    print(\"=\"*60, file=sys.stderr)\n    \n    # Get the label file path\n    label_path = Path(__file__).parent / \"label.txt\"\n\n    # Load expected answer\n    print(\"\\n--- Loading Expected Answer ---\", file=sys.stderr)\n    expected_answer = load_expected_answer(label_path)\n    if not expected_answer:\n        print(\"FATAL ERROR: Could not load expected answer from label.txt\", file=sys.stderr)\n        return False\n    print(f\"Successfully loaded {len(expected_answer)} expected values\", file=sys.stderr)\n\n    # Get model's response from MCP_MESSAGES\n    print(\"\\n--- Loading Model Response ---\", file=sys.stderr)\n    model_response = get_model_response()\n    if not model_response:\n        print(\"FATAL ERROR: No model response found in MCP_MESSAGES\", file=sys.stderr)\n        return False\n    \n    print(f\"Found model response ({len(model_response)} characters)\", file=sys.stderr)\n    \n    print(\"\\n--- Parsing Answer Format ---\", file=sys.stderr)\n    model_answer = parse_answer_format(model_response)\n    \n    if not model_answer:\n        print(\"\\nFATAL ERROR: Could not parse answer format from model response\", file=sys.stderr)\n        print(\"Verification FAILED\", file=sys.stderr)\n        return False\n    \n    print(\"\\n=== Model Answer Successfully Parsed ===\", file=sys.stderr)\n    for key, value in model_answer.items():\n        print(f\"  {key}: {value}\", file=sys.stderr)\n\n    # Compare answers\n    print(\"\\n--- Comparing Answers ---\", file=sys.stderr)\n    answer_match = compare_answers(model_answer, expected_answer)\n    \n    if not answer_match:\n        print(\"\\n\" + \"=\"*60, file=sys.stderr)\n        print(\"VERIFICATION FAILED: Model answer does not match expected answer\", file=sys.stderr)\n        print(\"=\"*60, file=sys.stderr)\n        return False\n    \n    print(\"\\n\" + \"=\"*60, file=sys.stderr)\n    print(\"✓ VERIFICATION PASSED: Model answer matches expected answer\", file=sys.stderr)\n    print(\"=\"*60, file=sys.stderr)\n    return True\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}