{
  "task_id": "fitness_promotion_strategy",
  "task_name": "Fitness Promotion Strategy",
  "category_id": "shopping_admin",
  "category_name": "Shopping Admin",
  "description": "Develop fitness product promotion campaigns by analyzing sales data, creating targeted offers, configuring promotional rules, and implementing cross-selling strategies in admin dashboard.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "comparative analysis",
    "inventory management",
    "content submission"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "Our marketing team is planning a new promotion for our bestselling fitness products. We need to analyze the current performance of our top-selling items and their related promotions to optimize our strategy.\n\n**Task Requirements:**\n\n1. If need to login, login with username 'admin' and password 'admin1234'\n\n2. Start by checking our current bestsellers:\n   - Identify the top 3 bestselling products based on their Price\tand Quantity - record their names, prices, and quantities sold\n   - Note the total Revenue amount displayed\n   - Check if any of these bestsellers appear in the Top Search Terms table - if yes, record the search term and its usage count, else output 'No:0'\n\n3. Investigate these bestselling products in detail:\n   - For each of the top 3 bestsellers identified, search for them by name and record:\n     - Their SKU\n     - Current inventory quantity\n     - Whether they are 'Enabled' or 'Disabled'\n\n4. Check if we have existing promotions for these products:\n   - Look for any active rules that might apply to fitness/yoga products\n   - Find if there's a rule offering percentage discount - record the rule name and discount percentage\n   - Count total number of active rules\n\n5. Analyze customer purchasing patterns:\n   - Count total number of orders in the system\n   - Note the ID of the most recent order\n\n6. Review our top customers who might be interested:\n   - Find the customer who appears in the Last Orders section of the dashboard with the highest total\n   - Look up this customer in the All Customers list and record his email and customer group\n   - Count how many other customers are in the same group\n\n7. Compile your findings and output them in the following exact format:\n\n```\n<answer>\nBestseller1|name:price:quantity:sku:inventory:status\nBestseller2|name:price:quantity:sku:inventory:status\nBestseller3|name:price:quantity:sku:inventory:status\nTotalRevenue|amount\nBestsellerInSearch|term:count\nPercentageDiscountRule|name:percentage\nActiveRulesCount|count\nTotalOrders|count\nMostRecentOrderID|id\nTopCustomer|name:email:group\nSameGroupCustomers|count\n</answer>\n```\n\n**Example Output:**\n```\n<answer>\nBestseller1|Product Name:$XX.XX:X:XXX(SKU):X:Enabled/Disabled\nBestseller2|Product Name:$XX.XX:X:XXX(SKU):X:Enabled/Disabled\nBestseller3|Product Name:$XX.XX:X:XXX(SKU):X:Enabled/Disabled\nTotalRevenue|$XX.XX\nBestsellerInSearch|Term:X or None:0\nPercentageDiscountRule|Rule Name:XX%\nActiveRulesCount|X\nTotalOrders|X\nMostRecentOrderID|X or None\nTopCustomer|Customer Name:email@example.com:Group Name\nSameGroupCustomers|X\n</answer>\n```\n\n",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nimport json\nfrom pathlib import Path\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n    \n    try:\n        with open(messages_path, 'r') as f:\n            messages = json.load(f)\n        \n        # Find the last assistant message\n        for message in reversed(messages):\n            if message.get('role') == 'assistant' and message.get('status') == 'completed':\n                content = message.get('content', [])\n                for item in content:\n                    if item.get('type') == 'output_text':\n                        return item.get('text', '')\n        \n        print(\"Warning: No assistant response found in messages\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\ndef parse_answer_format(text):\n    \"\"\"\n    Parse the <answer>...</answer> format from the agent's output.\n    Returns a dictionary with the parsed values.\n    \"\"\"\n    if not text:\n        return None\n    \n    # Look for <answer>...</answer> pattern\n    match = re.search(r'<answer>(.*?)</answer>', text, re.IGNORECASE | re.DOTALL)\n    if not match:\n        return None\n    \n    answer_content = match.group(1).strip()\n    \n    # Parse each line\n    result = {}\n    lines = answer_content.split('\\n')\n    \n    # Skip the check for exact number of lines - just parse what we have\n    # if len(lines) != 13:\n    #     print(f\"Error: Expected 13 lines in answer, got {len(lines)}\", file=sys.stderr)\n    #     return None\n    \n    for line in lines:\n        if '|' in line:\n            key, value = line.split('|', 1)\n            result[key.strip()] = value.strip()\n    \n    return result\n\ndef load_expected_answer(label_path):\n    \"\"\"\n    Load the expected answer from label.txt file.\n    Returns a dictionary with the expected values.\n    \"\"\"\n    try:\n        with open(label_path, 'r') as f:\n            lines = f.read().strip().split('\\n')\n        \n        expected = {}\n        for line in lines:\n            if '|' in line:\n                key, value = line.split('|', 1)\n                expected[key.strip()] = value.strip()\n        \n        return expected\n    except Exception as e:\n        print(f\"Error reading label file: {str(e)}\", file=sys.stderr)\n        return None\n\ndef compare_answers(model_answer, expected_answer):\n    \"\"\"\n    Compare the model's answer with the expected answer.\n    Returns True if all key information matches, False otherwise.\n    \"\"\"\n    if not model_answer or not expected_answer:\n        return False\n    \n    # Check each expected key\n    mismatches = []\n    for key, expected_value in expected_answer.items():\n        model_value = model_answer.get(key, '')\n        \n        # Special handling for different types of values\n        if key in ['Bestseller1', 'Bestseller2', 'Bestseller3']:\n            # Check if all parts match (name:price:quantity:sku:inventory:status)\n            if ':' in expected_value and ':' in model_value:\n                expected_parts = expected_value.split(':')\n                model_parts = model_value.split(':')\n                if len(expected_parts) == 6 and len(model_parts) == 6:\n                    # Compare each part\n                    for i, (exp, mod) in enumerate(zip(expected_parts, model_parts)):\n                        if i == 1:  # Price field\n                            exp_clean = exp.replace('$', '').replace(',', '')\n                            mod_clean = mod.replace('$', '').replace(',', '')\n                            if exp_clean != mod_clean:\n                                mismatches.append(f\"{key} price: expected '{exp}', got '{mod}'\")\n                        elif i == 4:  # Inventory field (may have decimal places)\n                            exp_float = float(exp.replace(',', ''))\n                            mod_float = float(mod.replace(',', ''))\n                            if abs(exp_float - mod_float) > 0.0001:\n                                mismatches.append(f\"{key} inventory: expected '{exp}', got '{mod}'\")\n                        else:\n                            if exp.lower() != mod.lower():\n                                mismatches.append(f\"{key} part {i}: expected '{exp}', got '{mod}'\")\n                else:\n                    mismatches.append(f\"{key}: format mismatch - expected '{expected_value}', got '{model_value}'\")\n            else:\n                if expected_value != model_value:\n                    mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        elif key == 'LowestInventoryProduct':\n            # Check product name and inventory\n            if ':' in expected_value and ':' in model_value:\n                expected_name, expected_inv = expected_value.rsplit(':', 1)\n                model_name, model_inv = model_value.rsplit(':', 1)\n                if expected_name.lower() != model_name.lower():\n                    mismatches.append(f\"{key} name: expected '{expected_name}', got '{model_name}'\")\n                exp_float = float(expected_inv.replace(',', ''))\n                mod_float = float(model_inv.replace(',', ''))\n                if abs(exp_float - mod_float) > 0.0001:\n                    mismatches.append(f\"{key} inventory: expected '{expected_inv}', got '{model_inv}'\")\n            else:\n                if expected_value != model_value:\n                    mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        elif key in ['TotalRevenue', 'MinimumPurchaseRule']:\n            # For price/amount fields, normalize format\n            expected_clean = expected_value.replace('$', '').replace(',', '')\n            model_clean = model_value.replace('$', '').replace(',', '')\n            if expected_clean != model_clean:\n                mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        elif key == 'BestsellerInSearch':\n            # Check search term and count\n            if expected_value.lower() != model_value.lower():\n                mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        elif key == 'PercentageDiscountRule':\n            # Check rule name and percentage\n            if ':' in expected_value and ':' in model_value:\n                expected_name, expected_pct = expected_value.rsplit(':', 1)\n                model_name, model_pct = model_value.rsplit(':', 1)\n                if expected_name != model_name:\n                    mismatches.append(f\"{key} name: expected '{expected_name}', got '{model_name}'\")\n                # Normalize percentage (20% vs 20 vs 0.20)\n                exp_pct_clean = expected_pct.replace('%', '').strip()\n                mod_pct_clean = model_pct.replace('%', '').strip()\n                if exp_pct_clean != mod_pct_clean:\n                    mismatches.append(f\"{key} percentage: expected '{expected_pct}', got '{model_pct}'\")\n            else:\n                if expected_value != model_value:\n                    mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        elif key == 'TopCustomer':\n            # Check name:email:group\n            if ':' in expected_value and ':' in model_value:\n                expected_parts = expected_value.split(':')\n                model_parts = model_value.split(':')\n                if len(expected_parts) == 3 and len(model_parts) == 3:\n                    exp_name, exp_email, exp_group = expected_parts\n                    mod_name, mod_email, mod_group = model_parts\n                    if exp_name != mod_name:\n                        mismatches.append(f\"{key} name: expected '{exp_name}', got '{mod_name}'\")\n                    if exp_email.lower() != mod_email.lower():\n                        mismatches.append(f\"{key} email: expected '{exp_email}', got '{mod_email}'\")\n                    if exp_group.lower() != mod_group.lower():\n                        mismatches.append(f\"{key} group: expected '{exp_group}', got '{mod_group}'\")\n                else:\n                    mismatches.append(f\"{key}: format mismatch - expected '{expected_value}', got '{model_value}'\")\n            else:\n                if expected_value != model_value:\n                    mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        elif key == 'MostRecentOrderDate':\n            # Date format may vary, do flexible comparison\n            if expected_value.lower() == 'none' and model_value.lower() == 'none':\n                continue\n            elif expected_value != model_value:\n                # Could add more flexible date parsing here if needed\n                mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n        \n        else:\n            # Exact match for other fields (counts, etc.)\n            if str(model_value) != str(expected_value):\n                mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n    \n    if mismatches:\n        print(\"\\n=== Answer Comparison Mismatches ===\", file=sys.stderr)\n        for mismatch in mismatches:\n            print(f\"✗ {mismatch}\", file=sys.stderr)\n        return False\n    \n    print(\"\\n=== Answer Comparison ===\", file=sys.stderr)\n    print(\"✓ All key information matches the expected answer\", file=sys.stderr)\n    return True\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the bestseller analysis and promotion task has been completed correctly.\n    First checks the model's answer against the expected label,\n    then optionally verifies the actual state in the Magento Admin.\n    \"\"\"\n    # Get the label file path\n    label_path = Path(__file__).parent / \"label.txt\"\n    \n    # Load expected answer\n    expected_answer = load_expected_answer(label_path)\n    if not expected_answer:\n        print(\"Error: Could not load expected answer from label.txt\", file=sys.stderr)\n        return False\n    \n    # Get model's response from MCP_MESSAGES\n    model_response = get_model_response()\n    if model_response:\n        print(\"Found model response, parsing answer format...\", file=sys.stderr)\n        model_answer = parse_answer_format(model_response)\n        \n        if model_answer:\n            print(\"\\n=== Model Answer Parsed ===\", file=sys.stderr)\n            for key, value in model_answer.items():\n                print(f\"{key}: {value}\", file=sys.stderr)\n            \n            # Compare answers\n            answer_match = compare_answers(model_answer, expected_answer)\n            if not answer_match:\n                print(\"\\nModel answer does not match expected answer\", file=sys.stderr)\n                return False\n            print(\"\\n✓ Model answer matches expected answer\", file=sys.stderr)\n            return True\n        else:\n            print(\"Warning: Could not parse answer format from model response\", file=sys.stderr)\n            return False\n    else:\n        print(\"No model response found\", file=sys.stderr)\n        return False\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\nif __name__ == \"__main__\":\n    main()"
}