{
  "task_id": "employee_demographics_report",
  "task_name": "Employee Demographics Report",
  "category_id": "employees",
  "category_name": "Employees",
  "description": "Generate comprehensive employee demographics report with gender statistics, age groups, birth months, and hiring trends.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-14",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "statistical aggregation"
  ],
  "mcp": [
    "postgres"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "Enum \"employees\".\"employee_gender\" {\n  \"M\"\n  \"F\"\n}\n\nTable \"employees\".\"department\" {\n  \"id\" bpchar(4) [pk, not null]\n  \"dept_name\" varchar(40) [unique, not null]\n}\n\nTable \"employees\".\"department_employee\" {\n  \"employee_id\" int8 [not null]\n  \"department_id\" bpchar(4) [not null]\n  \"from_date\" date [not null]\n  \"to_date\" date [not null]\n\n  Indexes {\n    (employee_id, department_id) [type: btree, name: \"idx_16982_primary\"]\n    department_id [type: btree, name: \"idx_16982_dept_no\"]\n  }\n}\n\nTable \"employees\".\"department_manager\" {\n  \"employee_id\" int8 [not null]\n  \"department_id\" bpchar(4) [not null]\n  \"from_date\" date [not null]\n  \"to_date\" date [not null]\n\n  Indexes {\n    (employee_id, department_id) [type: btree, name: \"idx_16985_primary\"]\n    department_id [type: btree, name: \"idx_16985_dept_no\"]\n  }\n}\n\nTable \"employees\".\"employee\" {\n  \"id\" int8 [pk, not null, increment]\n  \"birth_date\" date [not null]\n  \"first_name\" varchar(14) [not null]\n  \"last_name\" varchar(16) [not null]\n  \"gender\" employees.employee_gender [not null]\n  \"hire_date\" date [not null]\n}\n\nTable \"employees\".\"salary\" {\n  \"employee_id\" int8 [not null]\n  \"amount\" int8 [not null]\n  \"from_date\" date [not null]\n  \"to_date\" date [not null]\n\n  Indexes {\n    (employee_id, from_date) [type: btree, name: \"idx_16991_primary\"]\n  }\n}\n\nTable \"employees\".\"title\" {\n  \"employee_id\" int8 [not null]\n  \"title\" varchar(50) [not null]\n  \"from_date\" date [not null]\n  \"to_date\" date\n\n  Indexes {\n    (employee_id, title, from_date) [type: btree, name: \"idx_16994_primary\"]\n  }\n}\n\nRef \"dept_emp_ibfk_1\":\"employees\".\"employee\".\"id\" < \"employees\".\"department_employee\".\"employee_id\" [update: restrict, delete: cascade]\n\nRef \"dept_emp_ibfk_2\":\"employees\".\"department\".\"id\" < \"employees\".\"department_employee\".\"department_id\" [update: restrict, delete: cascade]\n\nRef \"dept_manager_ibfk_1\":\"employees\".\"employee\".\"id\" < \"employees\".\"department_manager\".\"employee_id\" [update: restrict, delete: cascade]\n\nRef \"dept_manager_ibfk_2\":\"employees\".\"department\".\"id\" < \"employees\".\"department_manager\".\"department_id\" [update: restrict, delete: cascade]\n\nRef \"salaries_ibfk_1\":\"employees\".\"employee\".\"id\" < \"employees\".\"salary\".\"employee_id\" [update: restrict, delete: cascade]\n\nRef \"titles_ibfk_1\":\"employees\".\"employee\".\"id\" < \"employees\".\"title\".\"employee_id\" [update: restrict, delete: cascade]\n",
    "stateUrl": null,
    "stateOriginalUrl": "https://github.com/neondatabase-labs/postgres-sample-dbs/blob/main/employees.sql.gz"
  },
  "instruction": "Generate a comprehensive employee demographics and basic statistics report for the annual company overview. The HR team needs simple, clear statistical summaries about our workforce composition to include in the annual report and diversity initiatives.\n\n## Your Tasks:\n\n1. **Create the gender statistics table** ‚Äî build a table called `gender_statistics` in the `employees` schema with these exact columns:\n   * `gender` (varchar) ‚Äî gender ('M' or 'F')\n   * `total_employees` (integer) ‚Äî total number of employees of this gender\n   * `current_employees` (integer) ‚Äî current employees of this gender (have active salary)\n   * `percentage_of_workforce` (decimal) ‚Äî percentage of current workforce\n\n2. **Create the age group analysis table** ‚Äî build a table called `age_group_analysis` in the `employees` schema with:\n   * `age_group` (varchar) ‚Äî age range ('20-29', '30-39', '40-49', '50-59', '60+')\n   * `employee_count` (integer) ‚Äî number of current employees in age group\n   * `avg_salary` (decimal) ‚Äî average current salary for age group\n   * `avg_tenure_days` (decimal) ‚Äî average days of service\n\n3. **Create the birth month distribution table** ‚Äî build a table called `birth_month_distribution` in the `employees` schema with:\n   * `birth_month` (integer) ‚Äî month number (1-12)\n   * `month_name` (varchar) ‚Äî month name ('January', 'February', etc.)\n   * `employee_count` (integer) ‚Äî total employees born in this month\n   * `current_employee_count` (integer) ‚Äî current employees born in this month\n\n4. **Create the hiring year summary table** ‚Äî build a table called `hiring_year_summary` in the `employees` schema with:\n   * `hire_year` (integer) ‚Äî year employees were hired\n   * `employees_hired` (integer) ‚Äî number of employees hired that year\n   * `still_employed` (integer) ‚Äî how many from that year are still employed\n   * `retention_rate` (decimal) ‚Äî percentage still employed (still_employed/employees_hired * 100)\n\n5. **Apply age group classification** based on current age:\n   * **20-29**: Ages 20-29\n   * **30-39**: Ages 30-39  \n   * **40-49**: Ages 40-49\n   * **50-59**: Ages 50-59\n   * **60+**: Ages 60 and above\n\n6. **Calculate workforce composition** ‚Äî determine current workforce demographics using employees with active salary records (to_date = '9999-01-01').\n\n7. **Focus on basic statistics** ‚Äî create simple counts, averages, and percentages that are easy to understand and verify.\n\nThe analysis will provide clear demographic insights for HR reporting and workforce planning.\n",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 3: Employee Demographics Report\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.1 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.1:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_gender_statistics_results(conn) -> bool:\n    \"\"\"Verify the gender statistics results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT gender, total_employees, current_employees, percentage_of_workforce\n            FROM employees.gender_statistics\n            ORDER BY gender\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH current_emp AS (\n            SELECT DISTINCT s.employee_id\n            FROM employees.salary s\n            WHERE s.to_date = DATE '9999-01-01'\n            ),\n            total_current AS (\n            SELECT COUNT(*) AS cnt\n            FROM current_emp\n            )\n            SELECT\n            e.gender::varchar AS gender,\n            COUNT(*) AS total_employees,\n            COUNT(*) FILTER (WHERE ce.employee_id IS NOT NULL) AS current_employees,\n            (COUNT(*) FILTER (WHERE ce.employee_id IS NOT NULL))::DECIMAL\n                / NULLIF((SELECT cnt FROM total_current), 0) * 100 AS percentage_of_workforce\n            FROM employees.employee e\n            LEFT JOIN current_emp ce ON ce.employee_id = e.id\n            WHERE e.gender IN ('M','F')\n            GROUP BY e.gender\n            ORDER BY gender;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} gender statistics results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Gender statistics results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_age_group_results(conn) -> bool:\n    \"\"\"Verify the age group analysis results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT age_group, employee_count, avg_salary, avg_tenure_days\n            FROM employees.age_group_analysis\n            ORDER BY age_group\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\nWITH current_salary AS (\n  SELECT employee_id, amount\n  FROM (\n    SELECT s.*,\n           ROW_NUMBER() OVER (\n             PARTITION BY s.employee_id\n             ORDER BY s.from_date DESC, s.amount DESC\n           ) AS rn\n    FROM employees.salary s\n    WHERE s.to_date = DATE '9999-01-01'\n  ) x\n  WHERE rn = 1\n),\nemp_age AS (\n  SELECT\n    e.id AS employee_id,\n    e.hire_date,\n    EXTRACT(YEAR FROM AGE(CURRENT_DATE, e.birth_date))::INT AS age_years\n  FROM employees.employee e\n  WHERE e.birth_date IS NOT NULL\n)\nSELECT\n  CASE\n    WHEN a.age_years BETWEEN 20 AND 29 THEN '20-29'\n    WHEN a.age_years BETWEEN 30 AND 39 THEN '30-39'\n    WHEN a.age_years BETWEEN 40 AND 49 THEN '40-49'\n    WHEN a.age_years BETWEEN 50 AND 59 THEN '50-59'\n    WHEN a.age_years >= 60 THEN '60+'\n  END AS age_group,\n  COUNT(*)::INT AS employee_count,\n  AVG(cs.amount) AS avg_salary,\n  AVG((CURRENT_DATE - a.hire_date)::INT) AS avg_tenure_days\nFROM emp_age a\nJOIN current_salary cs ON cs.employee_id = a.employee_id\nWHERE a.age_years >= 20\nGROUP BY 1\nORDER BY 1;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} age group results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Age group analysis results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_birth_month_results(conn) -> bool:\n    \"\"\"Verify the birth month distribution results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT birth_month, month_name, employee_count, current_employee_count\n            FROM employees.birth_month_distribution\n            ORDER BY birth_month\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH current_emp AS (\n            SELECT DISTINCT s.employee_id\n            FROM employees.salary s\n            WHERE s.to_date = DATE '9999-01-01'\n            ),\n            months AS (\n            SELECT gs AS birth_month\n            FROM generate_series(1, 12) AS gs\n            )\n            SELECT\n            m.birth_month::INTEGER AS birth_month,\n            CASE m.birth_month\n                WHEN 1 THEN 'January'   WHEN 2 THEN 'February' WHEN 3 THEN 'March'\n                WHEN 4 THEN 'April'     WHEN 5 THEN 'May'      WHEN 6 THEN 'June'\n                WHEN 7 THEN 'July'      WHEN 8 THEN 'August'   WHEN 9 THEN 'September'\n                WHEN 10 THEN 'October'  WHEN 11 THEN 'November'WHEN 12 THEN 'December'\n            END AS month_name,\n            COUNT(e.id)::INTEGER AS employee_count,\n            COUNT(ce.employee_id)::INTEGER AS current_employee_count\n            FROM months m\n            LEFT JOIN employees.employee e\n            ON EXTRACT(MONTH FROM e.birth_date) = m.birth_month\n            LEFT JOIN current_emp ce\n            ON ce.employee_id = e.id\n            GROUP BY m.birth_month\n            ORDER BY m.birth_month;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} birth month results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Birth month distribution results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_hiring_year_results(conn) -> bool:\n    \"\"\"Verify the hiring year summary results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT hire_year, employees_hired, still_employed, retention_rate\n            FROM employees.hiring_year_summary\n            ORDER BY hire_year\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH current_emp AS (\n            SELECT DISTINCT s.employee_id\n            FROM employees.salary s\n            WHERE s.to_date = DATE '9999-01-01'\n            ),\n            base AS (\n            SELECT e.id, EXTRACT(YEAR FROM e.hire_date)::INT AS hire_year\n            FROM employees.employee e\n            WHERE e.hire_date IS NOT NULL\n            )\n            SELECT\n            b.hire_year,\n            COUNT(*)::INT AS employees_hired,\n            COUNT(*) FILTER (WHERE ce.employee_id IS NOT NULL)::INT AS still_employed,\n            (COUNT(*) FILTER (WHERE ce.employee_id IS NOT NULL))::DECIMAL\n                / NULLIF(COUNT(*), 0) * 100 AS retention_rate\n            FROM base b\n            LEFT JOIN current_emp ce ON ce.employee_id = b.id\n            GROUP BY b.hire_year\n            ORDER BY b.hire_year;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} hiring year results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Hiring year summary results are correct ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify all four analysis results\n        success = (\n            verify_gender_statistics_results(conn) and \n            verify_age_group_results(conn) and \n            verify_birth_month_results(conn) and\n            verify_hiring_year_results(conn)\n        )\n\n        conn.close()\n\n        if success:\n            print(\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}