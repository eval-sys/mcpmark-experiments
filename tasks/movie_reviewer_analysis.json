{
  "task_id": "movie_reviewer_analysis",
  "task_name": "Movie Reviewer Analysis",
  "category_id": "reddit",
  "category_name": "Reddit",
  "description": "Analyze movie review patterns by creating reviewer profile, collecting ratings data, tracking review trends, and generating analytical report on community movie preferences and discussions.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "user interaction",
    "data extraction",
    "comparative analysis",
    "content submission"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "I need you to analyze wonderful movie discussions on Postmill and create a summary post. This analysis will help me understand the community's engagement with movie topics.\n\n**Task Requirements:**\n\n1. Register a new account with username 'movie_reviewer_2024' and password 'movie_reviewer_2024'\n\n2. After successful registration, navigate to the movies forum and analyze the posts on the first page:\n   - Count all posts that have 4-digit years in their titles\n\n3. Identify the top 3 posts with the highest upvote counts from ALL posts on the first page and record their complete details\n\n4. Find these specific posts and record their data:\n   - The 'Rittenhouse Square' poster post (record exact upvotes and comments)\n\n5. Navigate through the first 5 pages of movies forum and count the total number of image/poster submissions across all 5 pages\n\n6. Create a new submission in the movies forum with:\n   - Title: \"Wonderful Movies Analysis: Community Favorites [2024]\"\n   - Body text must be EXACTLY these lines without anything (keep the keys as-is, only replace the values after the pipe, follow the markdown format):\n\n```\n- Total_Year_Posts|FILL_VALUE\n- Top1_Title|FILL_VALUE\n- Top1_Upvotes|FILL_VALUE\n- Top1_Comments|FILL_VALUE\n- Top2_Title|FILL_VALUE\n- Top2_Upvotes|FILL_VALUE\n- Top2_Comments|FILL_VALUE\n- Top3_Title|FILL_VALUE\n- Top3_Upvotes|FILL_VALUE\n- Top3_Comments|FILL_VALUE\n- Rittenhouse_Upvotes|FILL_VALUE\n- Rittenhouse_Comments|FILL_VALUE\n- Total_Image_Posts_5Pages|FILL_VALUE\n```",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nfrom pathlib import Path\nfrom playwright.async_api import (\n    async_playwright,\n    TimeoutError as PlaywrightTimeoutError,\n)\n\n# 从环境变量读取 base_url，默认回退到原地址\nBASE_URL = os.getenv(\"WEBARENA_BASE_URL\", \"http://localhost:9999\").rstrip(\"/\")\nprint(f\"Using base URL: {BASE_URL}\")\n\ndef parse_key_value_format(text):\n    \"\"\"\n    Parse the Key|Value format from the submission body using regex.\n    Works regardless of line breaks.\n    \"\"\"\n    data = {}\n\n    # Define patterns for each field with the pipe separator\n    patterns = {\n        \"Total_Year_Posts\": r\"Total_Year_Posts\\s*\\|\\s*(\\d+)\",\n        \"Top1_Title\": r\"Top1_Title\\s*\\|\\s*(.+?)(?=\\nTop1_Upvotes|$)\",\n        \"Top1_Upvotes\": r\"Top1_Upvotes\\s*\\|\\s*(\\d+)\",\n        \"Top1_Comments\": r\"Top1_Comments\\s*\\|\\s*(\\d+)\",\n        \"Top2_Title\": r\"Top2_Title\\s*\\|\\s*(.+?)(?=\\nTop2_Upvotes|$)\",\n        \"Top2_Upvotes\": r\"Top2_Upvotes\\s*\\|\\s*(\\d+)\",\n        \"Top2_Comments\": r\"Top2_Comments\\s*\\|\\s*(\\d+)\",\n        \"Top3_Title\": r\"Top3_Title\\s*\\|\\s*(.+?)(?=\\nTop3_Upvotes|$)\",\n        \"Top3_Upvotes\": r\"Top3_Upvotes\\s*\\|\\s*(\\d+)\",\n        \"Top3_Comments\": r\"Top3_Comments\\s*\\|\\s*(\\d+)\",\n        \"Rittenhouse_Upvotes\": r\"Rittenhouse_Upvotes\\s*\\|\\s*(\\d+)\",\n        \"Rittenhouse_Comments\": r\"Rittenhouse_Comments\\s*\\|\\s*(\\d+)\",\n        \"Total_Image_Posts_5Pages\": r\"Total_Image_Posts_5Pages\\s*\\|\\s*(\\d+)\",\n    }\n\n    # Extract each field using regex\n    for key, pattern in patterns.items():\n        match = re.search(pattern, text, re.DOTALL | re.MULTILINE)\n        if match:\n            # For title fields, clean up newlines and extra spaces\n            value = match.group(1).strip()\n            if \"Title\" in key:\n                # Replace newlines with spaces and normalize whitespace\n                value = \" \".join(value.split())\n            data[key] = value\n\n    return data\n\n\ndef normalize_text(text):\n    \"\"\"\n    Normalize text for comparison by handling different quote styles and whitespace.\n    \"\"\"\n    if not isinstance(text, str):\n        return str(text)\n\n    # Replace various quote styles with standard quotes\n    text = text.replace(\"\"\", \"'\").replace(\"\"\", \"'\")\n    text = text.replace('\"', '\"').replace('\"', '\"')\n    text = text.replace(\"&amp;\", \"&\")\n\n    # Normalize whitespace\n    text = \" \".join(text.split())\n\n    return text.strip()\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the wonderful movies analysis task has been completed correctly.\n    \"\"\"\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=True)\n        context = await browser.new_context()\n        page = await context.new_page()\n\n        try:\n            # Navigate to the main page\n            print(\"Navigating to forum...\", file=sys.stderr)\n            await page.goto(f\"{BASE_URL}/\", wait_until=\"networkidle\")\n\n            # Check if logged in as movie_reviewer_2024\n            user_button = page.locator('button:has-text(\"movie_reviewer_2024\")')\n            if not await user_button.count():\n                # Try to login\n                print(\"Not logged in, attempting to login...\", file=sys.stderr)\n\n                await page.click('a:has-text(\"Log in\")')\n                await page.wait_for_load_state(\"networkidle\")\n\n                await page.fill('input[name=\"_username\"]', \"movie_reviewer_2024\")\n                await page.fill('input[name=\"_password\"]', \"movie_reviewer_2024\")\n\n                await page.click('button:has-text(\"Log in\")')\n                await page.wait_for_load_state(\"networkidle\")\n\n                user_button = page.locator('button:has-text(\"movie_reviewer_2024\")')\n                if not await user_button.count():\n                    print(\n                        \"Error: Login failed for movie_reviewer_2024\", file=sys.stderr\n                    )\n                    return False\n\n                print(\"Successfully logged in as movie_reviewer_2024\", file=sys.stderr)\n            else:\n                print(\"Already logged in as movie_reviewer_2024\", file=sys.stderr)\n\n            # Navigate to movies forum\n            print(\"Navigating to movies forum...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/f/movies\", wait_until=\"networkidle\"\n            )\n\n            # Look for the submission with our specific title\n            print(\n                \"Looking for submission 'Wonderful Movies Analysis: Community Favorites [2024]'...\",\n                file=sys.stderr,\n            )\n            post_link = page.locator(\n                'a:has-text(\"Wonderful Movies Analysis: Community Favorites [2024]\")'\n            )\n\n            if not await post_link.count():\n                print(\n                    \"Error: Could not find submission with required title\",\n                    file=sys.stderr,\n                )\n                return False\n\n            # Click on the submission to view its content\n            await post_link.first.click()\n            await page.wait_for_load_state(\"networkidle\")\n\n            # Extract the submission body content\n            # Try multiple possible selectors for the post body\n            post_content = None\n            selectors = [\n                \".submission__body\",\n                \".post-body\",\n                \".RichText\",\n                '[class*=\"RichText\"]',\n                'div:has(> p:has-text(\"Total_Year_Posts\"))',\n                'div:has-text(\"Total_Year_Posts\"):has-text(\"Total_Image_Posts_5Pages\")',\n            ]\n\n            for selector in selectors:\n                content_element = page.locator(selector)\n                if await content_element.count():\n                    post_content = await content_element.first.inner_text()\n                    if \"Total_Year_Posts\" in post_content:\n                        print(\n                            f\"Found submission content using selector: {selector}\",\n                            file=sys.stderr,\n                        )\n                        break\n\n            if not post_content or \"Total_Year_Posts\" not in post_content:\n                print(\n                    \"Error: Could not find submission body with required format\",\n                    file=sys.stderr,\n                )\n                return False\n\n            print(\"Submission content found, parsing data...\", file=sys.stderr)\n            print(f\"Raw content: {post_content[:200]}...\", file=sys.stderr)\n\n            # Parse the Key: Value format\n            extracted_data = parse_key_value_format(post_content)\n            print(f\"Extracted data: {extracted_data}\", file=sys.stderr)\n\n            # Load expected values from label.txt\n            label_path = Path(__file__).parent / \"label.txt\"\n            if label_path.exists():\n                with open(label_path, \"r\") as f:\n                    expected_text = f.read().strip()\n                expected_data = parse_key_value_format(expected_text)\n                print(\"Loaded expected values from label.txt\", file=sys.stderr)\n\n            # Verify all required keys are present\n            required_keys = [\n                \"Total_Year_Posts\",\n                \"Top1_Title\",\n                \"Top1_Upvotes\",\n                \"Top1_Comments\",\n                \"Top2_Title\",\n                \"Top2_Upvotes\",\n                \"Top2_Comments\",\n                \"Top3_Title\",\n                \"Top3_Upvotes\",\n                \"Top3_Comments\",\n                \"Rittenhouse_Upvotes\",\n                \"Rittenhouse_Comments\",\n                \"Total_Image_Posts_5Pages\",\n            ]\n\n            missing_keys = []\n            for key in required_keys:\n                if key not in extracted_data:\n                    missing_keys.append(key)\n\n            if missing_keys:\n                print(\n                    f\"Error: Missing required keys: {', '.join(missing_keys)}\",\n                    file=sys.stderr,\n                )\n                return False\n\n            # Validate data format and content\n            errors = []\n\n            # Check Total_Year_Posts is a number and matches expected\n            try:\n                total_posts = int(extracted_data[\"Total_Year_Posts\"])\n                if \"expected_data\" in locals() and \"Total_Year_Posts\" in expected_data:\n                    expected_total = int(expected_data[\"Total_Year_Posts\"])\n                    if total_posts != expected_total:\n                        errors.append(\n                            f\"Total_Year_Posts mismatch: got {total_posts}, expected {expected_total}\"\n                        )\n            except ValueError:\n                errors.append(\n                    f\"Total_Year_Posts must be a number, got: {extracted_data['Total_Year_Posts']}\"\n                )\n\n            # If we have expected data, compare against it\n            if \"expected_data\" in locals():\n                # Compare each field\n                for key in required_keys:\n                    if key in expected_data and key in extracted_data:\n                        expected_val = normalize_text(expected_data[key])\n                        actual_val = normalize_text(extracted_data[key])\n\n                        # For numeric fields, compare as integers\n                        if (\n                            \"Upvotes\" in key\n                            or \"Comments\" in key\n                            or key == \"Total_Year_Posts\"\n                            or key == \"Total_Image_Posts_5Pages\"\n                        ):\n                            try:\n                                expected_int = int(expected_val)\n                                actual_int = int(actual_val)\n                                if expected_int != actual_int:\n                                    errors.append(\n                                        f\"{key} mismatch: got {actual_int}, expected {expected_int}\"\n                                    )\n                            except ValueError:\n                                errors.append(\n                                    f\"{key} should be numeric: got '{actual_val}'\"\n                                )\n                        else:\n                            # For text fields, compare normalized text\n                            if expected_val != actual_val:\n                                errors.append(\n                                    f\"{key} mismatch: got '{actual_val}', expected '{expected_val}'\"\n                                )\n\n            else:\n                # If no expected data, just do basic validation\n                for key in required_keys:\n                    if key not in extracted_data:\n                        errors.append(f\"Missing required key: {key}\")\n                    elif (\n                        not extracted_data[key] or extracted_data[key] == \"[FILL_VALUE]\"\n                    ):\n                        errors.append(f\"{key} was not filled in\")\n\n            if errors:\n                print(\n                    \"Error: Validation failed with the following issues:\",\n                    file=sys.stderr,\n                )\n                for error in errors:\n                    print(f\"  - {error}\", file=sys.stderr)\n                return False\n\n            # All checks passed\n            print(\"Success: Wonderful movies analysis task completed successfully.\")\n            print(\"- Account movie_reviewer_2024 verified\")\n            print(\n                \"- Submission 'Wonderful Movies Analysis: Community Favorites [2024]' found\"\n            )\n            print(f\"- Total posts with years: {extracted_data['Total_Year_Posts']}\")\n            print(\"- Top 3 posts by upvotes identified and documented\")\n            print(\n                f\"- Rittenhouse Square data: {extracted_data['Rittenhouse_Upvotes']} upvotes, {extracted_data['Rittenhouse_Comments']} comments\"\n            )\n            print(\n                f\"- Total image posts across 5 pages: {extracted_data['Total_Image_Posts_5Pages']}\"\n            )\n            print(\"- All data in correct Key|Value format\")\n            return True\n\n        except PlaywrightTimeoutError as e:\n            print(f\"Error: Timeout occurred - {str(e)}\", file=sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"Error: Unexpected error - {str(e)}\", file=sys.stderr)\n            return False\n        finally:\n            await browser.close()\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}