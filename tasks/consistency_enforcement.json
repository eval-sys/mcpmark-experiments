{
  "task_id": "consistency_enforcement",
  "task_name": "Consistency Enforcement",
  "category_id": "lego",
  "category_name": "Lego",
  "description": "Implement data consistency system ensuring reported part counts match actual inventory using triggers and constraint enforcement.",
  "author": "Jiawei Wang",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "data integrity enforcement",
    "stored procedures and functions",
    "transactional operations"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Implement a data consistency enforcement system for the LEGO database. The system must ensure that the reported part count in the `lego_sets` table matches the actual sum of non-spare parts in the latest inventory version. This involves a three-step process: identifying existing inconsistencies, fixing them, and creating a trigger-based constraint system to prevent future issues.\n\n### Consistency Rule\nFor any given `set_num`, the following invariant must be maintained:\n`lego_sets.num_parts = SUM(quantity)` FROM `lego_inventory_parts` WHERE `inventory_id` IN (latest inventory for that set) AND `is_spare` = false\n\n**Important**: If a set has no inventory records, the consistency check should be skipped.\n\n# Your Tasks:\n\n## Task 1: Identify Data Inconsistencies\n\n### Objective\nWrite a single `SELECT` query to find all sets where the stored `num_parts` does not match the actual calculated number of parts from the latest inventory.\n\n1.  **Find the Latest Inventory**: For each `set_num`, find its latest inventory id by getting the `MAX(version)` from the `lego_inventories` table.\n2.  **Calculate Actual Part Count**: For these latest inventories, join with `lego_inventory_parts` and calculate the `SUM(quantity)`, but only for parts where `is_spare` is false.\n3.  **Compare and Filter**: Join this calculated result back to the `lego_sets` table and return the rows where `lego_sets.num_parts` is different from your calculated sum.\n\n## Task 2: Fix Existing Inconsistencies\n\n### Objective\nCorrect all mismatched `num_parts` values using a clear, multi-step process with a temporary table. This approach is designed to be robust against all edge cases.\n\n#### Step 1: Create a Temporary Table\nCreate a temporary table (e.g., `correct_counts`) with two columns: `set_num` (text) and `actual_parts` (integer).\n\n#### Step 2: Populate the Temporary Table\nThis is the most critical step. Write an `INSERT` statement that calculates the correct part count for every single set listed in the `lego_sets` table.\n\n-   The query must start by selecting from `public.lego_sets`.\n-   It must then `LEFT JOIN` to a subquery that contains the part-counting logic (finding the latest inventory version and summing the non-spare parts).\n-   Use `COALESCE` on the final result from the subquery to ensure that any set without parts or without an inventory record gets a value of `0`, not `NULL`.\n\n#### Step 3: Update from the Temporary Table\n\nWrite a final, simple `UPDATE` statement that joins the `lego_sets` table with your temporary table on `set_num` and sets `num_parts` to the `actual_parts` value.\n\n## Task 3: Create Constraint Enforcement System\n\n### Objective\n\nImplement a deferrable constraint trigger system to enforce the consistency rule automatically for all future `INSERT` and `UPDATE` operations.\n\n### Part A: Create the Trigger Function\n\nCreate a single PL/pgSQL function, preferably named `check_set_parts_consistency()`, that performs the core validation.\n\n**Function Requirements**:\n\n  - Returns `trigger`.\n  - Accepts no arguments.\n  - Contains the core validation logic:\n      - **Identify the `set_num` to check**. This is the most critical part. The `set_num` must be retrieved based on which table fired the trigger (`TG_TABLE_NAME`):\n          - If `lego_sets` or `lego_inventories`: get the `set_num` directly from `NEW.set_num`.\n          - If `lego_inventory_parts`: you must first query `lego_inventories` using `NEW.inventory_id` to find the corresponding `set_num`.\n      - **Perform the check**. For the identified `set_num`, execute the same core logic from Task 1 to get the `actual_parts` count and the `stored_num_parts` from the `lego_sets` table.\n      - **Raise an exception on failure**. If `actual_parts` does not equal `stored_num_parts`, the function must raise an exception to block the transaction (e.g., `RAISE EXCEPTION 'Inconsistent part count for set %', relevant_set_num;`).\n      - **Return `NEW` on success**. If the check passes or is skipped, the function should `RETURN NEW`.\n\n### Part B: Create the Constraint Triggers\n\nCreate three separate `CONSTRAINT TRIGGER` statements that attach the function from Part A to the following tables:\n\n  - `public.lego_sets`\n  - `public.lego_inventories`\n  - `public.lego_inventory_parts`\n\n**Crucial Trigger Requirements**:\n\n  - Each trigger must fire `AFTER INSERT OR UPDATE`.\n  - Each trigger **MUST** be `DEFERRABLE` and `INITIALLY IMMEDIATE`. This is non-negotiable for the verification to pass.\n  - Each trigger must execute the function `FOR EACH ROW`.",
  "verify": "\"\"\"\nVerification script for PostgreSQL LEGO Task 1: Parts Consistency Fix & Constraints\nVersion 2.1: Relaxed consistency check to allow for one known corner case mismatch.\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nimport psycopg2.errors\nfrom typing import Optional, Tuple, List\n\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters from environment variables.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\"),\n    }\n\n\ndef fetch_candidate_part_row(cur) -> Optional[Tuple[int, str, str, int]]:\n    \"\"\"\n    Picks a concrete, non-spare inventory part from the latest inventory of any set.\n    This provides a reliable target for testing update and insert triggers.\n\n    Returns a tuple: (inventory_id, set_num, part_num, color_id) or None.\n    \"\"\"\n    cur.execute(\n        \"\"\"\n        WITH latest_inv AS (\n            SELECT set_num, MAX(version) AS max_version\n            FROM public.lego_inventories\n            GROUP BY set_num\n        ), inv AS (\n            SELECT li.id, li.set_num\n            FROM public.lego_inventories li\n            JOIN latest_inv lv ON lv.set_num = li.set_num AND lv.max_version = li.version\n        )\n        SELECT i.id AS inventory_id, i.set_num, lip.part_num, lip.color_id\n        FROM inv i\n        JOIN public.lego_inventory_parts lip ON lip.inventory_id = i.id\n        WHERE lip.is_spare = false AND lip.quantity > 0\n        LIMIT 1;\n        \"\"\"\n    )\n    return cur.fetchone()\n\n\ndef get_mismatch_count(cur) -> int:\n    \"\"\"Returns the number of sets where num_parts mismatches the computed actual sum.\"\"\"\n    cur.execute(\n        \"\"\"\n        WITH latest_inv AS (\n            SELECT set_num, MAX(version) AS max_version\n            FROM public.lego_inventories\n            GROUP BY set_num\n        ), inv_latest AS (\n            SELECT li.set_num, li.id\n            FROM public.lego_inventories li\n            JOIN latest_inv lv ON lv.set_num = li.set_num AND lv.max_version = li.version\n        ), parts_agg AS (\n            SELECT\n                i.set_num,\n                SUM(lip.quantity) AS actual_parts\n            FROM inv_latest i\n            JOIN public.lego_inventory_parts lip ON lip.inventory_id = i.id\n            WHERE lip.is_spare = false\n            GROUP BY i.set_num\n        )\n        SELECT COUNT(*)\n        FROM public.lego_sets s\n        LEFT JOIN parts_agg pa ON s.set_num = pa.set_num\n        WHERE s.num_parts <> COALESCE(pa.actual_parts, 0);\n        \"\"\"\n    )\n    return cur.fetchone()[0]\n\n\ndef verify_data_consistency(conn) -> bool:\n    \"\"\"\n    TASK 1 VERIFICATION: Checks if the initial data fix was successful.\n    (Relaxed: Allows for one corner-case mismatch).\n    \"\"\"\n    print(\"\\n-- Verifying Task 1: Data Consistency Fix (Relaxed) --\")\n    with conn.cursor() as cur:\n        count = get_mismatch_count(cur)\n        # RELAXED CONDITION: Allow 0 or 1 mismatch to pass.\n        if count > 1:\n            print(f\"❌ FAIL: Found {count} sets with inconsistent part counts. Expected 0 or 1 after fix.\")\n            return False\n        \n        print(\"✅ PASS: Data consistency check passed (allowing for one known mismatch).\")\n        return True\n\n\ndef verify_constraint_triggers_exist(conn) -> bool:\n    \"\"\"\n    TASK 2 VERIFICATION (Part A): Checks if constraint triggers are attached to all required tables.\n    This is more robust than checking names or a total count.\n    \"\"\"\n    print(\"\\n-- Verifying Task 2: Constraint Trigger Existence --\")\n    tables_to_check = [\n        'public.lego_inventory_parts',\n        'public.lego_inventories',\n        'public.lego_sets'\n    ]\n    all_triggers_found = True\n    with conn.cursor() as cur:\n        for table in tables_to_check:\n            cur.execute(\n                \"\"\"\n                SELECT COUNT(*)\n                FROM pg_trigger\n                WHERE tgrelid = %s::regclass AND tgconstraint <> 0;\n                \"\"\",\n                (table,)\n            )\n            trigger_count = cur.fetchone()[0]\n            if trigger_count == 0:\n                print(f\"❌ FAIL: No constraint trigger found on table '{table}'.\")\n                all_triggers_found = False\n            else:\n                print(f\"✅ OK: Found constraint trigger(s) on table '{table}'.\")\n\n    if all_triggers_found:\n        print(\"✅ PASS: Constraint triggers are attached to all required tables.\")\n    return all_triggers_found\n\n\ndef verify_violation_is_blocked(conn) -> bool:\n    \"\"\"\n    TASK 2 VERIFICATION (Part B): Checks if triggers block a direct, inconsistent write.\n    An attempt to increment a part quantity without updating the set's total should fail.\n    \"\"\"\n    print(\"\\n-- Verifying Task 2: Immediate Constraint Enforcement --\")\n    with conn.cursor() as cur:\n        candidate = fetch_candidate_part_row(cur)\n        if not candidate:\n            print(\"⚠️ SKIP: No candidate part row found to test constraints. Cannot verify.\")\n            return True # Skip if no data to test\n\n        inventory_id, _, part_num, color_id = candidate\n        try:\n            # This transaction should fail due to the trigger\n            cur.execute(\n                \"\"\"\n                UPDATE public.lego_inventory_parts\n                SET quantity = quantity + 1\n                WHERE inventory_id = %s AND part_num = %s AND color_id = %s;\n                \"\"\",\n                (inventory_id, part_num, color_id),\n            )\n            # If we reach here, the trigger failed to block the update.\n            conn.rollback()\n            print(\"❌ FAIL: An inconsistent write was NOT blocked by the trigger.\")\n            return False\n        except psycopg2.Error as e:\n            # We expect an error. Specifically, a constraint violation error.\n            conn.rollback()\n            # 23514 is check_violation, but custom triggers might raise others.\n            # Any error here is considered a success as the transaction was blocked.\n            print(f\"✅ PASS: Inconsistent write was correctly blocked by the trigger. (Error: {e.pgcode})\")\n            return True\n\n\ndef verify_deferred_transaction_is_allowed(conn) -> bool:\n    \"\"\"\n    TASK 2 VERIFICATION (Part C): Checks if a coordinated, consistent update is allowed\n    when constraints are deferred.\n    \"\"\"\n    print(\"\\n-- Verifying Task 2: Deferred Constraint Enforcement --\")\n    with conn.cursor() as cur:\n        candidate = fetch_candidate_part_row(cur)\n        if not candidate:\n            print(\"⚠️ SKIP: No candidate part row found. Cannot test deferred transaction.\")\n            return True # Skip if no data to test\n\n    inventory_id, set_num, part_num, color_id = candidate\n\n    try:\n        # This multi-statement transaction should succeed with deferred constraints\n        with conn.cursor() as cur:\n            cur.execute(\"BEGIN;\")\n            cur.execute(\"SET CONSTRAINTS ALL DEFERRED;\")\n            cur.execute(\n                \"UPDATE public.lego_inventory_parts SET quantity = quantity + 1 WHERE inventory_id = %s AND part_num = %s AND color_id = %s;\",\n                (inventory_id, part_num, color_id),\n            )\n            cur.execute(\n                \"UPDATE public.lego_sets SET num_parts = num_parts + 1 WHERE set_num = %s;\",\n                (set_num,),\n            )\n            cur.execute(\"COMMIT;\") # This will fail if constraints are not deferrable or logic is wrong\n        print(\"✅ PASS: Coordinated update with deferred constraints committed successfully.\")\n\n        # Revert changes to leave DB in its original state\n        with conn.cursor() as cur:\n            cur.execute(\"BEGIN;\")\n            cur.execute(\"SET CONSTRAINTS ALL DEFERRED;\")\n            cur.execute(\n                \"UPDATE public.lego_inventory_parts SET quantity = quantity - 1 WHERE inventory_id = %s AND part_num = %s AND color_id = %s;\",\n                (inventory_id, part_num, color_id),\n            )\n            cur.execute(\n                \"UPDATE public.lego_sets SET num_parts = num_parts - 1 WHERE set_num = %s;\",\n                (set_num,),\n            )\n            cur.execute(\"COMMIT;\")\n        print(\"INFO: Test changes were successfully reverted.\")\n        return True\n\n    except psycopg2.Error as e:\n        conn.rollback()\n        print(f\"❌ FAIL: Deferred transaction failed to commit. Error: {e}\")\n        return False\n\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 60)\n    print(\"LEGO Database Consistency Verification Script\")\n    print(\"=\" * 60)\n\n    conn_params = get_connection_params()\n    if not conn_params.get(\"database\"):\n        print(\"❌ CRITICAL: POSTGRES_DATABASE environment variable not set.\")\n        sys.exit(1)\n\n    try:\n        with psycopg2.connect(**conn_params) as conn:\n            conn.autocommit = False # Ensure we control transactions\n\n            # Run all verification steps\n            results = [\n                verify_data_consistency(conn),\n                verify_constraint_triggers_exist(conn),\n                verify_violation_is_blocked(conn),\n                verify_deferred_transaction_is_allowed(conn),\n            ]\n\n            if all(results):\n                print(\"\\n🎉 Overall Result: PASS - All tasks verified successfully!\")\n                sys.exit(0)\n            else:\n                print(\"\\n❌ Overall Result: FAIL - One or more verification steps failed.\")\n                sys.exit(1)\n\n    except psycopg2.OperationalError as e:\n        print(f\"❌ CRITICAL: Could not connect to the database. Details: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"❌ CRITICAL: An unexpected error occurred during verification. Details: {e}\")\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}