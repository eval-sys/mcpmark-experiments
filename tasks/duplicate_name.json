{
  "task_id": "duplicate_name",
  "task_name": "Duplicate Name",
  "category_id": "student_database",
  "category_name": "Student Database",
  "description": "Identify students with identical names from a 150-student database and generate a formatted namesake grouping report file.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-10",
  "difficulty": "L3",
  "tags": [
    "pattern analysis",
    "data extraction"
  ],
  "mcp": [
    "filesystem"
  ],
  "metadata": {},
  "instruction": "Please help me identify duplicate names from the list of all the 150 students. Do not use python code. Then generate a `namesake.txt` file to record the results in the following format, with each group written in three lines:\n\nname: xxx\ncount: xxx\nids: xxx, xxx, ...\n\nLeave one blank line between every two groups. If there are multiple duplicates, just list all corresponding IDs in the third line.\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Student Database Task: Find Duplicate Names\nSimplified version that only checks against expected results without folder validation\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_namesake_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the namesake.txt file exists.\"\"\"\n    namesake_file = test_dir / \"namesake.txt\"\n    \n    if not namesake_file.exists():\n        print(\"‚ùå File 'namesake.txt' not found\")\n        return False\n    \n    print(\"‚úÖ Namesake file found\")\n    return True\n\ndef parse_namesake_file(test_dir: Path) -> dict:\n    \"\"\"Parse the namesake.txt file and return structured data.\"\"\"\n    namesake_file = test_dir / \"namesake.txt\"\n    \n    try:\n        content = namesake_file.read_text()\n        lines = content.strip().split('\\n')\n        \n        namesakes = {}\n        current_line = 0\n        \n        while current_line < len(lines):\n            # Skip blank lines\n            if not lines[current_line].strip():\n                current_line += 1\n                continue\n            \n            # Check if we have enough lines for a complete group\n            if current_line + 2 >= len(lines):\n                print(f\"‚ùå Incomplete group at line {current_line + 1}\")\n                return {}\n            \n            # Parse group\n            name_line = lines[current_line].strip()\n            count_line = lines[current_line + 1].strip()\n            ids_line = lines[current_line + 2].strip()\n            \n            # Extract name\n            if not name_line.startswith(\"name: \"):\n                print(f\"‚ùå Invalid name line format at line {current_line + 1}: {name_line}\")\n                return {}\n            name = name_line.replace(\"name: \", \"\").strip()\n            \n            # Extract count\n            if not count_line.startswith(\"count: \"):\n                print(f\"‚ùå Invalid count line format at line {current_line + 2}: {count_line}\")\n                return {}\n            count_str = count_line.replace(\"count: \", \"\").strip()\n            try:\n                count = int(count_str)\n            except ValueError:\n                print(f\"‚ùå Invalid count format: {count_str}\")\n                return {}\n            \n            # Extract IDs\n            if not ids_line.startswith(\"ids: \"):\n                print(f\"‚ùå Invalid ids line format at line {current_line + 3}: {ids_line}\")\n                return {}\n            ids_str = ids_line.replace(\"ids: \", \"\").strip()\n            ids = [id.strip() for id in ids_str.split(\",\")]\n            \n            namesakes[name] = {\n                'count': count,\n                'ids': ids\n            }\n            \n            current_line += 4  # Skip to next group (after blank line)\n        \n        return namesakes\n        \n    except Exception as e:\n        print(f\"‚ùå Error parsing namesake file: {e}\")\n        return {}\n\ndef verify_against_expected_results(namesakes: dict) -> bool:\n    \"\"\"Verify that the results match the expected answer.md content exactly.\"\"\"\n    \n    # Expected duplicate names from answer.md (hardcoded)\n    expected_duplicates = {\n        'Isabella Smith': ['20132026', '20133697'],\n        'Ava Lopez': ['20166564', '20166998'],\n        'James Moore': ['20159695', '20188937'],\n        'William Taylor': ['20175314', '20189854'],\n        'Ethan Wilson': ['20182390', '20196998'],\n        'Christopher Taylor': ['20128879', '20187892'],\n        'William Anderson': ['20142085', '20146277'],\n        'James Anderson': ['20147789', '20153606'],\n        'Olivia Jones': ['20189192', '20196896'],\n        'Mason Johnson': ['20115252', '20199735'],\n        'Benjamin Jackson': ['20153174', '20194160'],\n        'John Taylor': ['20194525', '20201385'],\n        'Susan Anderson': ['20148778', '20173517'],\n        'Christopher Moore': ['20112439', '20146279'],\n        'Sarah Wilson': ['20158819', '20204611'],\n        'Sarah Brown': ['20104498', '20108742']\n    }\n    \n    # Check if exactly 16 duplicate names are found\n    if len(namesakes) != 16:\n        print(f\"‚ùå Expected exactly 16 duplicate names, but found {len(namesakes)}\")\n        return False\n    \n    # Check if all expected duplicate names are present\n    for expected_name in expected_duplicates:\n        if expected_name not in namesakes:\n            print(f\"‚ùå Missing expected duplicate name: '{expected_name}'\")\n            return False\n    \n    # Check if all namesakes in the file are actually duplicates\n    for name, data in namesakes.items():\n        if name not in expected_duplicates:\n            print(f\"‚ùå Unexpected duplicate name found: '{name}' (not in expected list)\")\n            return False\n        \n        expected_ids = set(expected_duplicates[name])\n        stated_ids = set(data['ids'])\n        \n        if expected_ids != stated_ids:\n            print(f\"‚ùå ID mismatch for '{name}':\")\n            print(f\"   Expected: {sorted(expected_ids)}\")\n            print(f\"   Stated: {sorted(stated_ids)}\")\n            return False\n        \n        # Verify count matches\n        if data['count'] != 2:\n            print(f\"‚ùå Count mismatch for '{name}': expected 2, got {data['count']}\")\n            return False\n    \n    print(\"‚úÖ All 16 expected duplicate names are correctly identified\")\n    print(\"‚úÖ All student IDs match expected results\")\n    print(\"‚úÖ All counts are correct (2 for each duplicate name)\")\n    return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"üîç Verifying Student Database Task: Find Duplicate Names...\")\n    \n    # Check if namesake file exists\n    print(\"\\n--- File Existence Check ---\")\n    if not verify_namesake_file_exists(test_dir):\n        print(\"\\n‚ùå Basic verification failed, cannot proceed with content verification\")\n        sys.exit(1)\n    \n    # Parse the file and run content verification\n    print(\"\\n--- Content Verification ---\")\n    namesakes = parse_namesake_file(test_dir)\n    \n    if not namesakes:\n        print(\"‚ùå Failed to parse namesake file\")\n        sys.exit(1)\n    \n    # Verify against expected results\n    print(\"\\n--- Results Verification ---\")\n    if not verify_against_expected_results(namesakes):\n        print(\"\\n‚ùå Task verification: FAIL\")\n        sys.exit(1)\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    print(\"‚úÖ Namesake identification completed correctly!\")\n    print(f\"üéâ Found exactly {len(namesakes)} duplicate names (16 expected)\")\n    print(\"üéâ Task verification: PASS\")\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()"
}