{
  "task_id": "organize_legacy_papers",
  "task_name": "Organize Legacy Papers",
  "category_id": "papers",
  "category_name": "Papers",
  "description": "Structure and organize older academic papers from 2023 and earlier into a year-based hierarchical directory system with proper documentation.",
  "author": "Xiangyan Liu",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "file organization",
    "data extraction",
    "cross-referencing"
  ],
  "mcp": [
    "filesystem"
  ],
  "metadata": {},
  "instruction": "# Papers Collection Cleanup and Organization\n\n## üìã Task Description\n\nYou are given a directory containing multiple paper files. You have a collection of arXiv papers saved as HTML files in the papers directory, along with a BibTeX file. Your task is to organize the older papers (2023 and earlier) into a structured year-based hierarchy with proper documentation, while leaving newer papers in the original location.\n\n## üéØ Task Objectives\n\n1. **Organize by year**: Create a year-based directory structure for papers from 2023 and earlier\n2. **Generate documentation**: Create INDEX.md files for each year with paper metadata\n3. **Create summary**: Build a master SUMMARY.md file linking to all year indexes\n\n## üìù Detailed Requirements\n\n### Step 1: Organization\n- Create directory structure: `organized/{year}/` where year is extracted from the arXiv ID\n  - Example: `1707.06347.html` ‚Üí `organized/2017/1707.06347.html`\n- Move each HTML file from 2023 and earlier to its corresponding year folder, keeping original filenames\n- Papers from 2024 onwards (arXiv IDs starting with `24` or `25`) should remain in the original papers directory\n\n### Step 2: Year Index Files\nFor each year folder, create an `INDEX.md` file containing:\n- A markdown table with three columns: `ArXiv ID | Authors | Local Path`\n- Extract authors from `<meta name=\"citation_author\" content=\"...\"/>` tags, keeping only the first 3 authors\n- If there are more than 3 authors, list the first 3 followed by \"et al.\"\n- Format authors as: \"Author1, Author2, Author3\" or \"Author1, Author2, Author3, et al.\"\n- Local Path should be just the filename (e.g., `1707.06347.html`)\n- Sort entries by arXiv ID in ascending order\n\n### Step 3: Master Summary\nCreate `organized/SUMMARY.md` with:\n- A markdown table with columns: `Year | Paper Count | Index Link`\n- Index Link should be a relative markdown link (e.g., `[View Index](2017/INDEX.md)`)\n- Sort by year in ascending order\n\n## üìÅ Expected Output Structure\n\n```\npapers/\n‚îú‚îÄ‚îÄ arxiv_2025.bib (remains here)\n‚îú‚îÄ‚îÄ (2024+ HTML files remain here)\n‚îî‚îÄ‚îÄ organized/\n    ‚îú‚îÄ‚îÄ SUMMARY.md\n    ‚îú‚îÄ‚îÄ 2017/\n    ‚îÇ   ‚îú‚îÄ‚îÄ INDEX.md\n    ‚îÇ   ‚îî‚îÄ‚îÄ 1707.06347.html\n    ‚îú‚îÄ‚îÄ 2021/\n    ‚îÇ   ‚îú‚îÄ‚îÄ INDEX.md\n    ‚îÇ   ‚îî‚îÄ‚îÄ 2105.04165.html\n    ‚îú‚îÄ‚îÄ 2022/\n    ‚îÇ   ‚îú‚îÄ‚îÄ INDEX.md\n    ‚îÇ   ‚îî‚îÄ‚îÄ 2201.11903.html\n    ‚îî‚îÄ‚îÄ 2023/\n        ‚îú‚îÄ‚îÄ INDEX.md\n        ‚îú‚îÄ‚îÄ 2303.08774.html\n        ‚îú‚îÄ‚îÄ 2306.08640.html\n        ‚îú‚îÄ‚îÄ 2310.02255.html\n        ‚îú‚îÄ‚îÄ 2310.08446.html\n        ‚îú‚îÄ‚îÄ 2312.00849.html\n        ‚îú‚îÄ‚îÄ 2312.07533.html\n        ‚îî‚îÄ‚îÄ 2312.11805.html\n```",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Papers Collection Cleanup and Organization Task\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport re\nimport os\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_papers_remain(test_dir: Path) -> bool:\n    \"\"\"Verify that BibTeX and 2024+ papers remain in original directory.\"\"\"\n    papers_dir = test_dir\n    \n    # Check BibTeX file still exists\n    bib_file = papers_dir / \"arxiv_2025.bib\"\n    if not bib_file.exists():\n        print(\"‚ùå BibTeX file arxiv_2025.bib not found\")\n        return False\n    print(\"‚úÖ BibTeX file remains in place\")\n    \n    # Check that 2024+ papers remain in original directory\n    found_2024_plus = False\n    if papers_dir.exists():\n        for html_file in papers_dir.glob(\"*.html\"):\n            arxiv_id = html_file.stem\n            year_part = arxiv_id[:2] if len(arxiv_id) >= 2 else \"\"\n            if year_part.isdigit():\n                year = int(year_part)\n                if year >= 24:\n                    found_2024_plus = True\n                    break\n    \n    if found_2024_plus:\n        print(\"‚úÖ 2024+ papers remain in original directory\")\n    else:\n        print(\"‚ö†Ô∏è No 2024+ papers found (this may be expected if none existed)\")\n    \n    # Check that pre-2024 papers are NOT in original directory\n    pre_2024_found = []\n    if papers_dir.exists():\n        for html_file in papers_dir.glob(\"*.html\"):\n            arxiv_id = html_file.stem\n            year_part = arxiv_id[:2] if len(arxiv_id) >= 2 else \"\"\n            if year_part.isdigit():\n                year = int(year_part)\n                if year < 24:\n                    pre_2024_found.append(html_file.name)\n    \n    if pre_2024_found:\n        print(f\"‚ùå Pre-2024 papers still in original directory: {pre_2024_found[:3]}...\")\n        return False\n    \n    print(\"‚úÖ Pre-2024 papers have been moved\")\n    return True\n\ndef verify_directory_structure(test_dir: Path) -> bool:\n    \"\"\"Verify the organized directory structure exists.\"\"\"\n    organized_dir = test_dir / \"organized\"\n    \n    if not organized_dir.exists():\n        print(\"‚ùå organized/ directory not found\")\n        return False\n    print(\"‚úÖ organized/ directory exists\")\n    \n    # Expected years based on pre-2024 papers\n    expected_years = [\"2017\", \"2021\", \"2022\", \"2023\"]\n    found_years = []\n    \n    for year in expected_years:\n        year_dir = organized_dir / year\n        if year_dir.exists() and year_dir.is_dir():\n            found_years.append(year)\n    \n    if len(found_years) != len(expected_years):\n        print(f\"‚ùå Expected year directories {expected_years}, found {found_years}\")\n        return False\n    \n    print(f\"‚úÖ All expected year directories exist: {found_years}\")\n    return True\n\ndef verify_papers_moved(test_dir: Path) -> bool:\n    \"\"\"Verify papers are correctly moved to year folders.\"\"\"\n    organized_dir = test_dir / \"organized\"\n    \n    # Expected paper distribution\n    expected_papers = {\n        \"2017\": [\"1707.06347.html\"],\n        \"2021\": [\"2105.04165.html\"],\n        \"2022\": [\"2201.11903.html\"],\n        \"2023\": [\"2303.08774.html\", \"2306.08640.html\", \"2310.02255.html\", \n                 \"2310.08446.html\", \"2312.00849.html\", \"2312.07533.html\", \n                 \"2312.11805.html\"]\n    }\n    \n    all_correct = True\n    for year, papers in expected_papers.items():\n        year_dir = organized_dir / year\n        if not year_dir.exists():\n            print(f\"‚ùå Year directory {year} doesn't exist\")\n            return False\n        \n        actual_papers = sorted([f.name for f in year_dir.glob(\"*.html\")])\n        expected_sorted = sorted(papers)\n        \n        if actual_papers != expected_sorted:\n            print(f\"‚ùå Papers in {year}/: expected {expected_sorted}, found {actual_papers}\")\n            all_correct = False\n        else:\n            print(f\"‚úÖ Correct papers in {year}/: {len(actual_papers)} files\")\n    \n    return all_correct\n\ndef verify_index_files(test_dir: Path) -> bool:\n    \"\"\"Verify INDEX.md files exist and have correct format.\"\"\"\n    organized_dir = test_dir / \"organized\"\n    years = [\"2017\", \"2021\", \"2022\", \"2023\"]\n    \n    for year in years:\n        index_file = organized_dir / year / \"INDEX.md\"\n        \n        if not index_file.exists():\n            print(f\"‚ùå INDEX.md missing in {year}/\")\n            return False\n        \n        content = index_file.read_text()\n        \n        # Check for table format\n        if \"ArXiv ID\" not in content or \"Authors\" not in content or \"Local Path\" not in content:\n            print(f\"‚ùå INDEX.md in {year}/ missing required columns\")\n            return False\n        \n        \n        # Check that papers are listed\n        year_dir = organized_dir / year\n        html_files = list(year_dir.glob(\"*.html\"))\n        for html_file in html_files:\n            arxiv_id = html_file.stem\n            if arxiv_id not in content:\n                print(f\"‚ùå INDEX.md in {year}/ missing paper {arxiv_id}\")\n                return False\n        \n        print(f\"‚úÖ INDEX.md in {year}/ has correct format\")\n    \n    return True\n\ndef verify_author_extraction(test_dir: Path) -> bool:\n    \"\"\"Verify that authors are correctly extracted from HTML metadata (max 3 authors).\"\"\"\n    organized_dir = test_dir / \"organized\"\n    \n    # Check a sample paper's authors\n    sample_file = organized_dir / \"2017\" / \"1707.06347.html\"\n    if not sample_file.exists():\n        print(\"‚ùå Cannot verify author extraction - sample file missing\")\n        return False\n    \n    # Read the HTML to get expected authors\n    html_content = sample_file.read_text()\n    author_pattern = r'<meta name=\"citation_author\" content=\"([^\"]+)\"'\n    all_authors = re.findall(author_pattern, html_content)\n    \n    if not all_authors:\n        print(\"‚ùå No authors found in sample HTML file\")\n        return False\n    \n    # Build expected author string (max 3 authors)\n    if len(all_authors) <= 3:\n        expected_author_str = \", \".join(all_authors)\n    else:\n        expected_author_str = \", \".join(all_authors[:3]) + \", et al.\"\n    \n    # Check if INDEX.md contains these authors\n    index_file = organized_dir / \"2017\" / \"INDEX.md\"\n    index_content = index_file.read_text()\n    \n    # Find the line with this paper\n    found = False\n    for line in index_content.split('\\n'):\n        if \"1707.06347\" in line:\n            found = True\n            # Check if authors are correctly formatted\n            if len(all_authors) > 3:\n                # Should have first 3 authors and \"et al.\"\n                if \"et al.\" not in line:\n                    print(\"‚ùå Missing 'et al.' for paper with >3 authors\")\n                    return False\n                # Check first 3 authors are present\n                for author in all_authors[:3]:\n                    if author not in line:\n                        print(f\"‚ùå Author '{author}' not found in INDEX.md\")\n                        return False\n                # Check that 4th author is NOT present\n                if len(all_authors) > 3 and all_authors[3] in line:\n                    print(f\"‚ùå Fourth author '{all_authors[3]}' should not be in INDEX.md\")\n                    return False\n            else:\n                # Should have all authors, no \"et al.\"\n                if \"et al.\" in line:\n                    print(\"‚ùå Should not have 'et al.' for paper with ‚â§3 authors\")\n                    return False\n                for author in all_authors:\n                    if author not in line:\n                        print(f\"‚ùå Author '{author}' not found in INDEX.md\")\n                        return False\n            break\n    \n    if not found:\n        print(\"‚ùå Paper 1707.06347 not found in INDEX.md\")\n        return False\n    \n    print(\"‚úÖ Authors correctly extracted (max 3) from HTML metadata\")\n    \n    # Additional check: verify 3-author limit across all papers\n    print(\"\\nVerifying 3-author limit across all papers...\")\n    years = [\"2017\", \"2021\", \"2022\", \"2023\"]\n    for year in years:\n        year_dir = organized_dir / year\n        if not year_dir.exists():\n            continue\n            \n        index_file = year_dir / \"INDEX.md\"\n        if not index_file.exists():\n            continue\n            \n        index_content = index_file.read_text()\n        \n        # Check each HTML file in the year directory\n        for html_file in year_dir.glob(\"*.html\"):\n            arxiv_id = html_file.stem\n            \n            # Get actual authors from HTML\n            html_content = html_file.read_text()\n            authors = re.findall(r'<meta name=\"citation_author\" content=\"([^\"]+)\"', html_content)\n            \n            # Find corresponding line in INDEX.md\n            for line in index_content.split('\\n'):\n                if arxiv_id in line and '|' in line and 'ArXiv ID' not in line:\n                    # Count authors in the line (split by comma)\n                    author_parts = line.split('|')[1] if '|' in line else \"\"\n                    \n                    # Check et al. usage\n                    if len(authors) > 3:\n                        if \"et al.\" not in line:\n                            print(f\"‚ùå {year}/{arxiv_id}: Missing 'et al.' for {len(authors)} authors\")\n                            return False\n                    elif \"et al.\" in line:\n                        print(f\"‚ùå {year}/{arxiv_id}: Unexpected 'et al.' for {len(authors)} authors\")\n                        return False\n                    \n                    # Verify no more than 3 authors are listed\n                    author_count = author_parts.count(',') + 1 if author_parts.strip() else 0\n                    if \"et al.\" in author_parts:\n                        author_count -= 1  # Don't count \"et al.\" as an author\n                    \n                    if author_count > 3:\n                        print(f\"‚ùå {year}/{arxiv_id}: More than 3 authors listed\")\n                        return False\n                    \n                    break\n    \n    print(\"‚úÖ All papers respect the 3-author limit\")\n    return True\n\ndef verify_summary_file(test_dir: Path) -> bool:\n    \"\"\"Verify SUMMARY.md exists and has correct content.\"\"\"\n    summary_file = test_dir / \"organized\" / \"SUMMARY.md\"\n    \n    if not summary_file.exists():\n        print(\"‚ùå SUMMARY.md not found\")\n        return False\n    \n    content = summary_file.read_text()\n    \n    # Check for required columns\n    if \"Year\" not in content or \"Paper Count\" not in content or \"Index Link\" not in content:\n        print(\"‚ùå SUMMARY.md missing required columns\")\n        return False\n    \n    \n    # Check for year entries\n    expected_years = [\"2017\", \"2021\", \"2022\", \"2023\"]\n    for year in expected_years:\n        if year not in content:\n            print(f\"‚ùå SUMMARY.md missing year {year}\")\n            return False\n    \n    # Check for links to INDEX.md files\n    expected_links = [\n        f\"{year}/INDEX.md\" for year in expected_years\n    ]\n    for link in expected_links:\n        if link not in content:\n            print(f\"‚ùå SUMMARY.md missing link to {link}\")\n            return False\n    \n    # Check paper counts\n    expected_counts = {\n        \"2017\": 1,\n        \"2021\": 1,\n        \"2022\": 1,\n        \"2023\": 7\n    }\n    \n    for year, count in expected_counts.items():\n        # Look for the row with this year\n        for line in content.split('\\n'):\n            if f\"| {year}\" in line or f\"|{year}\" in line:\n                if str(count) not in line:\n                    print(f\"‚ùå SUMMARY.md has incorrect paper count for {year}\")\n                    return False\n                break\n    \n    print(\"‚úÖ SUMMARY.md has correct format and content\")\n    return True\n\ndef verify_sorting(test_dir: Path) -> bool:\n    \"\"\"Verify that entries are sorted correctly.\"\"\"\n    organized_dir = test_dir / \"organized\"\n    \n    # Check SUMMARY.md year sorting\n    summary_file = organized_dir / \"SUMMARY.md\"\n    content = summary_file.read_text()\n    \n    # Extract years from table rows\n    years_in_summary = []\n    for line in content.split('\\n'):\n        if '|' in line and any(year in line for year in [\"2017\", \"2021\", \"2022\", \"2023\"]):\n            # Extract year from the line\n            for year in [\"2017\", \"2021\", \"2022\", \"2023\"]:\n                if year in line:\n                    years_in_summary.append(year)\n                    break\n    \n    if years_in_summary != sorted(years_in_summary):\n        print(f\"‚ùå SUMMARY.md years not sorted: {years_in_summary}\")\n        return False\n    \n    print(\"‚úÖ SUMMARY.md years sorted correctly\")\n    \n    # Check INDEX.md arxiv ID sorting for one year\n    index_file = organized_dir / \"2023\" / \"INDEX.md\"\n    if index_file.exists():\n        content = index_file.read_text()\n        arxiv_ids = []\n        for line in content.split('\\n'):\n            if '|' in line and '23' in line and 'ArXiv ID' not in line and '---' not in line:\n                # Extract arxiv ID\n                match = re.search(r'23\\d{2}\\.\\d{5}', line)\n                if match:\n                    arxiv_ids.append(match.group())\n        \n        if arxiv_ids != sorted(arxiv_ids):\n            print(f\"‚ùå INDEX.md arxiv IDs not sorted in 2023/\")\n            return False\n        \n        print(\"‚úÖ INDEX.md entries sorted by arxiv ID\")\n    \n    return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"üîç Verifying Papers Collection Cleanup and Organization...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Papers Remain/Move Verification\", verify_papers_remain),\n        (\"Directory Structure\", verify_directory_structure),\n        (\"Papers Moved Correctly\", verify_papers_moved),\n        (\"Index Files Format\", verify_index_files),\n        (\"Author Extraction\", verify_author_extraction),\n        (\"Summary File\", verify_summary_file),\n        (\"Sorting Verification\", verify_sorting),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        try:\n            if not verify_func(test_dir):\n                all_passed = False\n        except Exception as e:\n            print(f\"‚ùå Error in {step_name}: {e}\")\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"‚úÖ Papers organized correctly!\")\n        print(\"üéâ Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"‚ùå Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()",
  "model_results": {
    "gemini-2-5-pro": 1,
    "deepseek-chat": 1,
    "qwen-3-coder": 0,
    "o3": 0,
    "gpt-5": 0,
    "k2": 0,
    "claude-4-sonnet": 0
  }
}