{
  "task_id": "management_structure_analysis",
  "task_name": "Management Structure Analysis",
  "category_id": "employees",
  "category_name": "Employees",
  "description": "Analyze management structure evaluating leadership effectiveness, span of control, and management transitions for succession planning.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "statistical aggregation"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Conduct a comprehensive management structure analysis to evaluate leadership effectiveness and organizational hierarchy. The executive team needs insights into management tenure, span of control, and leadership transitions to optimize the management structure and succession planning.\n\n## Your Tasks:\n\n1. **Create the manager profile table** — build a table called `manager_profile` in the `employees` schema with these exact columns:\n   * `manager_id` (bigint) — the manager's employee ID\n   * `manager_name` (varchar) — concatenated first and last name\n   * `current_department` (varchar) — current department they manage (NULL if not current)\n   * `management_periods` (integer) — total number of management assignments (including multiple periods in same department)\n   * `current_manager` (boolean) — whether they are currently a manager\n\n2. **Create the department leadership table** — build a table called `department_leadership` in the `employees` schema with:\n   * `department_name` (varchar) — the department name\n   * `current_manager_name` (varchar) — current manager's full name\n   * `manager_start_date` (date) — when current manager started\n   * `total_historical_managers` (integer) — total number of managers this department has had\n\n3. **Create the management transition table** — build a table called `management_transitions` in the `employees` schema with:\n   * `department_name` (varchar) — the department name\n   * `transition_year` (integer) — year when management changed\n   * `outgoing_manager` (varchar) — previous manager's name\n   * `incoming_manager` (varchar) — new manager's name ('No Successor' if department had no immediate replacement)\n   * `transition_gap_days` (integer) — days between managers (0 if immediate or no successor)\n\n4. **Create the span of control table** — build a table called `span_of_control` in the `employees` schema with:\n   * `manager_id` (bigint) — the manager's employee ID\n   * `manager_name` (varchar) — manager's full name\n   * `department_name` (varchar) — department they manage\n   * `total_employees` (integer) — total employees in their department\n   * `current_employees` (integer) — current active employees in department\n   * `management_load` (varchar) — assessment ('light', 'moderate', 'heavy') based on current employees\n\n5. **Apply management load classification**:\n   * **Light**: < 5,000 current employees\n   * **Moderate**: 5,000 - 15,000 current employees\n   * **Heavy**: > 15,000 current employees\n\n6. **Focus on current managers only** for span of control analysis — use managers with active management roles (to_date = '9999-01-01').\n\n7. **Track all management history** for profiles and transitions — include both current and former managers to understand complete leadership evolution.\n\nThe analysis will provide insights into management effectiveness, departmental stability, and organizational structure optimization opportunities.\n",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 4: Management Structure Analysis\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.1 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.1:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_manager_profile_results(conn) -> bool:\n    \"\"\"Verify the manager profile results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT manager_id, manager_name, current_department, \n                   management_periods, current_manager\n            FROM employees.manager_profile\n            ORDER BY manager_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH dm AS (\n            SELECT dm.employee_id,\n                    dm.department_id,\n                    dm.from_date,\n                    dm.to_date\n            FROM employees.department_manager dm\n            ),\n            manager_periods AS (\n            SELECT employee_id, COUNT(*)::INT AS management_periods\n            FROM dm\n            GROUP BY employee_id\n            ),\n            current_assignment AS (\n            SELECT employee_id, department_id\n            FROM (\n                SELECT d.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY d.employee_id\n                        ORDER BY d.from_date DESC, d.department_id\n                    ) AS rn\n                FROM dm d\n                WHERE d.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            manager_names AS (\n            SELECT e.id AS manager_id,\n                    CONCAT(e.first_name, ' ', e.last_name) AS manager_name\n            FROM employees.employee e\n            WHERE EXISTS (SELECT 1 FROM dm WHERE employee_id = e.id)\n            )\n            SELECT\n            mn.manager_id,\n            mn.manager_name,\n            d.dept_name AS current_department,\n            mp.management_periods,\n            (d.dept_name IS NOT NULL) AS current_manager\n            FROM manager_names mn\n            JOIN manager_periods mp ON mp.employee_id = mn.manager_id\n            LEFT JOIN current_assignment ca ON ca.employee_id = mn.manager_id\n            LEFT JOIN employees.department d ON d.id = ca.department_id\n            ORDER BY mn.manager_id;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} manager profile results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Manager profile results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_department_leadership_results(conn) -> bool:\n    \"\"\"Verify the department leadership results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT department_name, current_manager_name, manager_start_date, \n                   total_historical_managers\n            FROM employees.department_leadership\n            ORDER BY department_name\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH current_mgr AS (\n            SELECT department_id,\n                    CONCAT(e.first_name, ' ', e.last_name) AS current_manager_name,\n                    dm.from_date AS manager_start_date\n            FROM (\n                SELECT dm.*,\n                    ROW_NUMBER() OVER (\n                        PARTITION BY dm.department_id\n                        ORDER BY dm.from_date DESC, dm.employee_id\n                    ) AS rn\n                FROM employees.department_manager dm\n                WHERE dm.to_date = DATE '9999-01-01'\n            ) dm\n            JOIN employees.employee e ON e.id = dm.employee_id\n            WHERE dm.rn = 1\n            ),\n            hist AS (\n            SELECT dm.department_id, COUNT(DISTINCT dm.employee_id)::INT AS total_historical_managers\n            FROM employees.department_manager dm\n            GROUP BY dm.department_id\n            )\n            SELECT\n            d.dept_name                              AS department_name,\n            cm.current_manager_name,\n            cm.manager_start_date,\n            COALESCE(h.total_historical_managers,0)  AS total_historical_managers\n            FROM employees.department d\n            LEFT JOIN current_mgr cm ON cm.department_id = d.id\n            LEFT JOIN hist        h  ON h.department_id = d.id\n            ORDER BY d.dept_name;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} department leadership results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Department leadership results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_management_transitions_results(conn) -> bool:\n    \"\"\"Verify the management transitions results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT department_name, transition_year, outgoing_manager, incoming_manager, transition_gap_days\n            FROM employees.management_transitions\n            ORDER BY department_name, transition_year\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH mgr AS (\n            SELECT\n                d.id AS department_id,\n                d.dept_name,\n                dm.employee_id,\n                dm.from_date,\n                dm.to_date,\n                CONCAT(e.first_name, ' ', e.last_name) AS manager_name\n            FROM employees.department_manager dm\n            JOIN employees.department d ON d.id = dm.department_id\n            JOIN employees.employee  e ON e.id = dm.employee_id\n            ),\n            ordered AS (\n            SELECT\n                department_id,\n                dept_name,\n                employee_id,\n                manager_name,\n                from_date,\n                to_date,\n                ROW_NUMBER() OVER (\n                PARTITION BY department_id\n                ORDER BY from_date, to_date, employee_id\n                ) AS rn,\n                LEAD(manager_name) OVER (\n                PARTITION BY department_id\n                ORDER BY from_date, to_date, employee_id\n                ) AS next_manager_name,\n                LEAD(from_date) OVER (\n                PARTITION BY department_id\n                ORDER BY from_date, to_date, employee_id\n                ) AS next_from_date\n            FROM mgr\n            )\n            SELECT\n            o.dept_name                                   AS department_name,\n            EXTRACT(YEAR FROM o.to_date)::INT             AS transition_year,\n            o.manager_name                                AS outgoing_manager,\n            COALESCE(o.next_manager_name, 'No Successor') AS incoming_manager,\n            COALESCE(GREATEST((o.next_from_date - o.to_date - 1), 0), 0)::INT AS transition_gap_days\n            FROM ordered o\n            WHERE o.to_date <> DATE '9999-01-01'\n            ORDER BY department_name, transition_year;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} management transitions results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Management transitions results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_span_of_control_results(conn) -> bool:\n    \"\"\"Verify the span of control results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT manager_id, manager_name, department_name, total_employees, \n                   current_employees, management_load\n            FROM employees.span_of_control\n            ORDER BY manager_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH dept_total AS (\n            SELECT de.department_id, COUNT(DISTINCT de.employee_id)::INT AS total_employees\n            FROM employees.department_employee de\n            GROUP BY de.department_id\n            ),\n            dept_current AS (\n            SELECT de.department_id, COUNT(DISTINCT de.employee_id)::INT AS current_employees\n            FROM employees.department_employee de\n            JOIN employees.salary s\n                ON s.employee_id = de.employee_id\n            AND s.to_date = DATE '9999-01-01'\n            WHERE de.to_date = DATE '9999-01-01'\n            GROUP BY de.department_id\n            )\n            SELECT\n            dm.employee_id AS manager_id,\n            CONCAT(e.first_name, ' ', e.last_name) AS manager_name,\n            d.dept_name AS department_name,\n            COALESCE(dt.total_employees, 0)  AS total_employees,\n            COALESCE(dc.current_employees, 0) AS current_employees,\n            CASE\n                WHEN COALESCE(dc.current_employees, 0) < 5000  THEN 'light'\n                WHEN COALESCE(dc.current_employees, 0) <= 15000 THEN 'moderate'\n                ELSE 'heavy'\n            END AS management_load\n            FROM employees.department_manager dm\n            JOIN employees.employee  e ON e.id = dm.employee_id\n            JOIN employees.department d ON d.id = dm.department_id\n            LEFT JOIN dept_total  dt ON dt.department_id = dm.department_id\n            LEFT JOIN dept_current dc ON dc.department_id = dm.department_id\n            WHERE dm.to_date = DATE '9999-01-01'\n            ORDER BY dm.employee_id, d.dept_name;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} span of control results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Span of control results are correct ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"❌ No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify all four analysis results\n        success = (\n            verify_manager_profile_results(conn) and \n            verify_department_leadership_results(conn) and \n            verify_management_transitions_results(conn) and\n            verify_span_of_control_results(conn)\n        )\n\n        conn.close()\n\n        if success:\n            print(\"\\n🎉 Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n❌ Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"❌ Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"❌ Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}