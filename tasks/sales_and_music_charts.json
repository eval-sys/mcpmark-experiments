{
  "task_id": "sales_and_music_charts",
  "task_name": "Sales and Music Charts",
  "category_id": "chinook",
  "category_name": "Chinook",
  "description": "Create monthly sales dashboard and top music charts system for tracking business performance and trending content.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "statistical aggregation",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "Table \"Album\" {\n  \"AlbumId\" int4 [pk, not null]\n  \"Title\" varchar(160) [not null]\n  \"ArtistId\" int4 [not null]\n\n  Indexes {\n    ArtistId [type: btree, name: \"IFK_AlbumArtistId\"]\n  }\n}\n\nTable \"Artist\" {\n  \"ArtistId\" int4 [pk, not null]\n  \"Name\" varchar(120)\n}\n\nTable \"Customer\" {\n  \"CustomerId\" int4 [pk, not null]\n  \"FirstName\" varchar(40) [not null]\n  \"LastName\" varchar(20) [not null]\n  \"Company\" varchar(80)\n  \"Address\" varchar(70)\n  \"City\" varchar(40)\n  \"State\" varchar(40)\n  \"Country\" varchar(40)\n  \"PostalCode\" varchar(10)\n  \"Phone\" varchar(24)\n  \"Fax\" varchar(24)\n  \"Email\" varchar(60) [not null]\n  \"SupportRepId\" int4\n\n  Indexes {\n    SupportRepId [type: btree, name: \"IFK_CustomerSupportRepId\"]\n  }\n}\n\nTable \"Employee\" {\n  \"EmployeeId\" int4 [pk, not null]\n  \"LastName\" varchar(20) [not null]\n  \"FirstName\" varchar(20) [not null]\n  \"Title\" varchar(30)\n  \"ReportsTo\" int4\n  \"BirthDate\" timestamp\n  \"HireDate\" timestamp\n  \"Address\" varchar(70)\n  \"City\" varchar(40)\n  \"State\" varchar(40)\n  \"Country\" varchar(40)\n  \"PostalCode\" varchar(10)\n  \"Phone\" varchar(24)\n  \"Fax\" varchar(24)\n  \"Email\" varchar(60)\n\n  Indexes {\n    ReportsTo [type: btree, name: \"IFK_EmployeeReportsTo\"]\n  }\n}\n\nTable \"Genre\" {\n  \"GenreId\" int4 [pk, not null]\n  \"Name\" varchar(120)\n}\n\nTable \"Invoice\" {\n  \"InvoiceId\" int4 [pk, not null]\n  \"CustomerId\" int4 [not null]\n  \"InvoiceDate\" timestamp [not null]\n  \"BillingAddress\" varchar(70)\n  \"BillingCity\" varchar(40)\n  \"BillingState\" varchar(40)\n  \"BillingCountry\" varchar(40)\n  \"BillingPostalCode\" varchar(10)\n  \"Total\" numeric(10,2) [not null]\n\n  Indexes {\n    CustomerId [type: btree, name: \"IFK_InvoiceCustomerId\"]\n  }\n}\n\nTable \"InvoiceLine\" {\n  \"InvoiceLineId\" int4 [pk, not null]\n  \"InvoiceId\" int4 [not null]\n  \"TrackId\" int4 [not null]\n  \"UnitPrice\" numeric(10,2) [not null]\n  \"Quantity\" int4 [not null]\n\n  Indexes {\n    InvoiceId [type: btree, name: \"IFK_InvoiceLineInvoiceId\"]\n    TrackId [type: btree, name: \"IFK_InvoiceLineTrackId\"]\n  }\n}\n\nTable \"MediaType\" {\n  \"MediaTypeId\" int4 [pk, not null]\n  \"Name\" varchar(120)\n}\n\nTable \"Playlist\" {\n  \"PlaylistId\" int4 [pk, not null]\n  \"Name\" varchar(120)\n}\n\nTable \"PlaylistTrack\" {\n  \"PlaylistId\" int4 [not null]\n  \"TrackId\" int4 [not null]\n\n  Indexes {\n    (PlaylistId, TrackId) [type: btree, name: \"PK_PlaylistTrack\"]\n    TrackId [type: btree, name: \"IFK_PlaylistTrackTrackId\"]\n  }\n}\n\nTable \"Track\" {\n  \"TrackId\" int4 [pk, not null]\n  \"Name\" varchar(200) [not null]\n  \"AlbumId\" int4\n  \"MediaTypeId\" int4 [not null]\n  \"GenreId\" int4\n  \"Composer\" varchar(220)\n  \"Milliseconds\" int4 [not null]\n  \"Bytes\" int4\n  \"UnitPrice\" numeric(10,2) [not null]\n\n  Indexes {\n    AlbumId [type: btree, name: \"IFK_TrackAlbumId\"]\n    GenreId [type: btree, name: \"IFK_TrackGenreId\"]\n    MediaTypeId [type: btree, name: \"IFK_TrackMediaTypeId\"]\n  }\n}\n\nRef \"FK_AlbumArtistId\":\"Artist\".\"ArtistId\" < \"Album\".\"ArtistId\"\n\nRef \"FK_CustomerSupportRepId\":\"Employee\".\"EmployeeId\" < \"Customer\".\"SupportRepId\"\n\nRef \"FK_EmployeeReportsTo\":\"Employee\".\"EmployeeId\" < \"Employee\".\"ReportsTo\"\n\nRef \"FK_InvoiceCustomerId\":\"Customer\".\"CustomerId\" < \"Invoice\".\"CustomerId\"\n\nRef \"FK_InvoiceLineInvoiceId\":\"Invoice\".\"InvoiceId\" < \"InvoiceLine\".\"InvoiceId\"\n\nRef \"FK_InvoiceLineTrackId\":\"Track\".\"TrackId\" < \"InvoiceLine\".\"TrackId\"\n\nRef \"FK_PlaylistTrackPlaylistId\":\"Playlist\".\"PlaylistId\" < \"PlaylistTrack\".\"PlaylistId\"\n\nRef \"FK_PlaylistTrackTrackId\":\"Track\".\"TrackId\" < \"PlaylistTrack\".\"TrackId\"\n\nRef \"FK_TrackAlbumId\":\"Album\".\"AlbumId\" < \"Track\".\"AlbumId\"\n\nRef \"FK_TrackGenreId\":\"Genre\".\"GenreId\" < \"Track\".\"GenreId\"\n\nRef \"FK_TrackMediaTypeId\":\"MediaType\".\"MediaTypeId\" < \"Track\".\"MediaTypeId\"\n",
    "stateUrl": null,
    "stateOriginalUrl": "https://github.com/neondatabase-labs/postgres-sample-dbs/blob/main/chinook.sql"
  },
  "instruction": "Create a monthly sales dashboard and top music charts system for Chinook's management team to track business performance and identify trending music content.\n\n## Your Tasks:\n\n1. **Build the monthly sales summary table** ‚Äî create a table called `monthly_sales_summary` in the `public` schema with:\n   * `year_month` (varchar) ‚Äî format as 'YYYY-MM' (e.g., '2009-01')\n   * `total_invoices` (integer) ‚Äî number of invoices in that month\n   * `total_revenue` (decimal) ‚Äî sum of all invoice totals for the month\n   * `total_tracks_sold` (integer) ‚Äî total quantity of individual tracks sold\n   * `average_invoice_value` (decimal) ‚Äî average invoice amount for the month\n   * `unique_customers` (integer) ‚Äî count of distinct customers who made purchases\n\n2. **Create the music charts table** ‚Äî build a table called `top_music_charts` in the `public` schema with:\n   * `chart_type` (varchar) ‚Äî either 'top_tracks', 'top_albums', or 'top_artists'\n   * `rank_position` (integer) ‚Äî ranking from 1 to 10\n   * `item_id` (integer) ‚Äî ID of the track, album, or artist\n   * `item_name` (varchar) ‚Äî name of the track, album, or artist\n   * `total_revenue` (decimal) ‚Äî total revenue generated by this item\n\n3. **Populate the monthly sales data**:\n   * Calculate metrics for each month that has invoice data\n   * Use invoice date to determine the month\n   * **Note**: Each invoice can contain multiple invoice lines (tracks)\n\n4. **Generate the top 10 charts**:\n   * **Top Tracks**: Rank tracks by total quantity sold across all invoices\n   * **Top Albums**: Rank albums by total revenue generated from their tracks\n   * **Top Artists**: Rank artists by total revenue from all their tracks across all albums\n\n5. **Business rules to follow**:\n   * Only include months where at least one invoice exists\n   * For album rankings, sum revenue from all tracks in each album\n   * For artist rankings, sum revenue from all tracks across all their albums\n   * Handle ties by using item name alphabetically as tiebreaker\n   * Exclude any items with zero sales\n\nThis system will provide clear, actionable business intelligence for monthly reporting and music trend analysis.",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 1: Monthly Sales Dashboard and Music Charts\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.01 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.01:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_monthly_sales_results(conn) -> bool:\n    \"\"\"Verify the monthly sales summary results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT year_month, total_invoices, total_revenue, \n                   total_tracks_sold, average_invoice_value, unique_customers\n            FROM monthly_sales_summary \n            ORDER BY year_month\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH invoice_metrics AS (\n            SELECT\n                DATE_TRUNC('month', i.\"InvoiceDate\") AS ym,\n                COUNT(*)::INT                       AS total_invoices,\n                SUM(i.\"Total\")::DECIMAL             AS total_revenue,\n                AVG(i.\"Total\")::DECIMAL             AS average_invoice_value,\n                COUNT(DISTINCT i.\"CustomerId\")::INT AS unique_customers\n            FROM \"Invoice\" i\n            GROUP BY 1\n            ),\n            track_metrics AS (         \n            SELECT\n                DATE_TRUNC('month', i.\"InvoiceDate\") AS ym,\n                SUM(il.\"Quantity\")::INT              AS total_tracks_sold\n            FROM \"Invoice\" i\n            JOIN \"InvoiceLine\" il ON il.\"InvoiceId\" = i.\"InvoiceId\"\n            WHERE il.\"Quantity\" > 0                \n            GROUP BY 1\n            )\n            SELECT\n            TO_CHAR(im.ym, 'YYYY-MM')          AS year_month,\n            im.total_invoices,\n            im.total_revenue,\n            COALESCE(tm.total_tracks_sold, 0)  AS total_tracks_sold,\n            im.average_invoice_value,\n            im.unique_customers\n            FROM invoice_metrics im\n            LEFT JOIN track_metrics tm USING (ym)\n            ORDER BY year_month;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} monthly sales records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Monthly sales row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total monthly sales mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Monthly sales results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_music_charts_results(conn) -> bool:\n    \"\"\"Verify the music charts results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT chart_type, rank_position, item_id, item_name, total_revenue\n            FROM top_music_charts\n            ORDER BY chart_type, rank_position\n        \"\"\")\n        actual_results = cur.fetchall()\n\n        # Execute ground truth queries for each chart type\n        cur.execute(\"\"\"\n            WITH track_stats AS (\n            SELECT\n                'top_tracks'::varchar AS chart_type,\n                t.\"TrackId\"           AS item_id,\n                t.\"Name\"              AS item_name,\n                SUM(il.\"UnitPrice\" * il.\"Quantity\")::DECIMAL AS total_revenue,\n                SUM(il.\"Quantity\")::INT                      AS total_quantity\n            FROM \"Track\" t\n            JOIN \"InvoiceLine\" il ON il.\"TrackId\" = t.\"TrackId\"\n            GROUP BY t.\"TrackId\", t.\"Name\"\n            HAVING SUM(il.\"Quantity\") > 0\n            ),\n            track_ranked AS (\n            SELECT\n                chart_type, item_id, item_name, total_revenue,\n                ROW_NUMBER() OVER (ORDER BY total_quantity DESC, item_name, item_id) AS rank_position\n            FROM track_stats\n            ),\n            album_rev AS (\n            SELECT\n                'top_albums'::varchar AS chart_type,\n                a.\"AlbumId\"           AS item_id,\n                a.\"Title\"             AS item_name,\n                SUM(il.\"UnitPrice\" * il.\"Quantity\")::DECIMAL AS total_revenue\n            FROM \"Album\" a\n            JOIN \"Track\" t        ON t.\"AlbumId\"  = a.\"AlbumId\"\n            JOIN \"InvoiceLine\" il ON il.\"TrackId\" = t.\"TrackId\"\n            GROUP BY a.\"AlbumId\", a.\"Title\"\n            HAVING SUM(il.\"UnitPrice\" * il.\"Quantity\") > 0\n            ),\n            album_ranked AS (\n            SELECT\n                chart_type, item_id, item_name, total_revenue,\n                ROW_NUMBER() OVER (ORDER BY total_revenue DESC, item_name, item_id) AS rank_position\n            FROM album_rev\n            ),\n            artist_rev AS (\n            SELECT\n                'top_artists'::varchar AS chart_type,\n                ar.\"ArtistId\"          AS item_id,\n                ar.\"Name\"              AS item_name,\n                SUM(il.\"UnitPrice\" * il.\"Quantity\")::DECIMAL AS total_revenue\n            FROM \"Artist\" ar\n            JOIN \"Album\"  a       ON a.\"ArtistId\" = ar.\"ArtistId\"\n            JOIN \"Track\"  t       ON t.\"AlbumId\"  = a.\"AlbumId\"\n            JOIN \"InvoiceLine\" il ON il.\"TrackId\" = t.\"TrackId\"\n            GROUP BY ar.\"ArtistId\", ar.\"Name\"\n            HAVING SUM(il.\"UnitPrice\" * il.\"Quantity\") > 0\n            ),\n            artist_ranked AS (\n            SELECT\n                chart_type, item_id, item_name, total_revenue,\n                ROW_NUMBER() OVER (ORDER BY total_revenue DESC, item_name, item_id) AS rank_position\n            FROM artist_rev\n            )\n            SELECT chart_type, rank_position, item_id, item_name, total_revenue\n            FROM (\n            SELECT * FROM track_ranked  WHERE rank_position <= 10\n            UNION ALL\n            SELECT * FROM album_ranked  WHERE rank_position <= 10\n            UNION ALL\n            SELECT * FROM artist_ranked WHERE rank_position <= 10\n            ) x\n            ORDER BY chart_type, rank_position;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} music chart records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Music chart row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total music chart mismatches: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Music chart results are correct ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify results\n        success = verify_monthly_sales_results(conn) and verify_music_charts_results(conn)\n\n        conn.close()\n\n        if success:\n            print(\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}