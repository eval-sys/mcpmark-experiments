{
  "task_id": "sales_and_music_charts",
  "task_name": "Sales and Music Charts",
  "category_id": "chinook",
  "category_name": "Chinook",
  "description": "Create monthly sales dashboard and top music charts system for tracking business performance and trending content.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "statistical aggregation",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Create a monthly sales dashboard and top music charts system for Chinook's management team to track business performance and identify trending music content.\n\n## Your Tasks:\n\n1. **Build the monthly sales summary table** — create a table called `monthly_sales_summary` in the `public` schema with:\n   * `year_month` (varchar) — format as 'YYYY-MM' (e.g., '2009-01')\n   * `total_invoices` (integer) — number of invoices in that month\n   * `total_revenue` (decimal) — sum of all invoice totals for the month\n   * `total_tracks_sold` (integer) — total quantity of individual tracks sold\n   * `average_invoice_value` (decimal) — average invoice amount for the month\n   * `unique_customers` (integer) — count of distinct customers who made purchases\n\n2. **Create the music charts table** — build a table called `top_music_charts` in the `public` schema with:\n   * `chart_type` (varchar) — either 'top_tracks', 'top_albums', or 'top_artists'\n   * `rank_position` (integer) — ranking from 1 to 10\n   * `item_id` (integer) — ID of the track, album, or artist\n   * `item_name` (varchar) — name of the track, album, or artist\n   * `total_revenue` (decimal) — total revenue generated by this item\n\n3. **Populate the monthly sales data**:\n   * Calculate metrics for each month that has invoice data\n   * Use invoice date to determine the month\n   * **Note**: Each invoice can contain multiple invoice lines (tracks)\n\n4. **Generate the top 10 charts**:\n   * **Top Tracks**: Rank tracks by total quantity sold across all invoices\n   * **Top Albums**: Rank albums by total revenue generated from their tracks\n   * **Top Artists**: Rank artists by total revenue from all their tracks across all albums\n\n5. **Business rules to follow**:\n   * Only include months where at least one invoice exists\n   * For album rankings, sum revenue from all tracks in each album\n   * For artist rankings, sum revenue from all tracks across all their albums\n   * Handle ties by using item name alphabetically as tiebreaker\n   * Exclude any items with zero sales\n\nThis system will provide clear, actionable business intelligence for monthly reporting and music trend analysis.",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 1: Monthly Sales Dashboard and Music Charts\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.01 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.01:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_monthly_sales_results(conn) -> bool:\n    \"\"\"Verify the monthly sales summary results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT year_month, total_invoices, total_revenue, \n                   total_tracks_sold, average_invoice_value, unique_customers\n            FROM monthly_sales_summary \n            ORDER BY year_month\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH invoice_metrics AS (\n            SELECT\n                DATE_TRUNC('month', i.\"InvoiceDate\") AS ym,\n                COUNT(*)::INT                       AS total_invoices,\n                SUM(i.\"Total\")::DECIMAL             AS total_revenue,\n                AVG(i.\"Total\")::DECIMAL             AS average_invoice_value,\n                COUNT(DISTINCT i.\"CustomerId\")::INT AS unique_customers\n            FROM \"Invoice\" i\n            GROUP BY 1\n            ),\n            track_metrics AS (         \n            SELECT\n                DATE_TRUNC('month', i.\"InvoiceDate\") AS ym,\n                SUM(il.\"Quantity\")::INT              AS total_tracks_sold\n            FROM \"Invoice\" i\n            JOIN \"InvoiceLine\" il ON il.\"InvoiceId\" = i.\"InvoiceId\"\n            WHERE il.\"Quantity\" > 0                \n            GROUP BY 1\n            )\n            SELECT\n            TO_CHAR(im.ym, 'YYYY-MM')          AS year_month,\n            im.total_invoices,\n            im.total_revenue,\n            COALESCE(tm.total_tracks_sold, 0)  AS total_tracks_sold,\n            im.average_invoice_value,\n            im.unique_customers\n            FROM invoice_metrics im\n            LEFT JOIN track_metrics tm USING (ym)\n            ORDER BY year_month;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} monthly sales records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Monthly sales row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total monthly sales mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Monthly sales results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_music_charts_results(conn) -> bool:\n    \"\"\"Verify the music charts results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT chart_type, rank_position, item_id, item_name, total_revenue\n            FROM top_music_charts\n            ORDER BY chart_type, rank_position\n        \"\"\")\n        actual_results = cur.fetchall()\n\n        # Execute ground truth queries for each chart type\n        cur.execute(\"\"\"\n            WITH track_stats AS (\n            SELECT\n                'top_tracks'::varchar AS chart_type,\n                t.\"TrackId\"           AS item_id,\n                t.\"Name\"              AS item_name,\n                SUM(il.\"UnitPrice\" * il.\"Quantity\")::DECIMAL AS total_revenue,\n                SUM(il.\"Quantity\")::INT                      AS total_quantity\n            FROM \"Track\" t\n            JOIN \"InvoiceLine\" il ON il.\"TrackId\" = t.\"TrackId\"\n            GROUP BY t.\"TrackId\", t.\"Name\"\n            HAVING SUM(il.\"Quantity\") > 0\n            ),\n            track_ranked AS (\n            SELECT\n                chart_type, item_id, item_name, total_revenue,\n                ROW_NUMBER() OVER (ORDER BY total_quantity DESC, item_name, item_id) AS rank_position\n            FROM track_stats\n            ),\n            album_rev AS (\n            SELECT\n                'top_albums'::varchar AS chart_type,\n                a.\"AlbumId\"           AS item_id,\n                a.\"Title\"             AS item_name,\n                SUM(il.\"UnitPrice\" * il.\"Quantity\")::DECIMAL AS total_revenue\n            FROM \"Album\" a\n            JOIN \"Track\" t        ON t.\"AlbumId\"  = a.\"AlbumId\"\n            JOIN \"InvoiceLine\" il ON il.\"TrackId\" = t.\"TrackId\"\n            GROUP BY a.\"AlbumId\", a.\"Title\"\n            HAVING SUM(il.\"UnitPrice\" * il.\"Quantity\") > 0\n            ),\n            album_ranked AS (\n            SELECT\n                chart_type, item_id, item_name, total_revenue,\n                ROW_NUMBER() OVER (ORDER BY total_revenue DESC, item_name, item_id) AS rank_position\n            FROM album_rev\n            ),\n            artist_rev AS (\n            SELECT\n                'top_artists'::varchar AS chart_type,\n                ar.\"ArtistId\"          AS item_id,\n                ar.\"Name\"              AS item_name,\n                SUM(il.\"UnitPrice\" * il.\"Quantity\")::DECIMAL AS total_revenue\n            FROM \"Artist\" ar\n            JOIN \"Album\"  a       ON a.\"ArtistId\" = ar.\"ArtistId\"\n            JOIN \"Track\"  t       ON t.\"AlbumId\"  = a.\"AlbumId\"\n            JOIN \"InvoiceLine\" il ON il.\"TrackId\" = t.\"TrackId\"\n            GROUP BY ar.\"ArtistId\", ar.\"Name\"\n            HAVING SUM(il.\"UnitPrice\" * il.\"Quantity\") > 0\n            ),\n            artist_ranked AS (\n            SELECT\n                chart_type, item_id, item_name, total_revenue,\n                ROW_NUMBER() OVER (ORDER BY total_revenue DESC, item_name, item_id) AS rank_position\n            FROM artist_rev\n            )\n            SELECT chart_type, rank_position, item_id, item_name, total_revenue\n            FROM (\n            SELECT * FROM track_ranked  WHERE rank_position <= 10\n            UNION ALL\n            SELECT * FROM album_ranked  WHERE rank_position <= 10\n            UNION ALL\n            SELECT * FROM artist_ranked WHERE rank_position <= 10\n            ) x\n            ORDER BY chart_type, rank_position;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} music chart records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Music chart row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total music chart mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Music chart results are correct ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"❌ No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify results\n        success = verify_monthly_sales_results(conn) and verify_music_charts_results(conn)\n\n        conn.close()\n\n        if success:\n            print(\"\\n🎉 Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n❌ Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"❌ Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"❌ Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}