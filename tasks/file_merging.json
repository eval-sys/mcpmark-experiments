{
  "task_id": "file_merging",
  "task_name": "File Merging",
  "category_id": "file_context",
  "category_name": "File Context",
  "description": "Identify the 10 smallest text files in the directory, then merge their content in alphabetical order into a single consolidated file.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-07",
  "difficulty": "L3",
  "tags": [
    "content transformation",
    "file organization"
  ],
  "mcp": [
    "filesystem"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "file_context/\n    ‚îú‚îÄ‚îÄ file_01.txt\n    ‚îú‚îÄ‚îÄ file_02.txt\n    ‚îú‚îÄ‚îÄ file_03.txt\n    ‚îú‚îÄ‚îÄ file_04.txt\n    ‚îú‚îÄ‚îÄ file_05.txt\n    ‚îú‚îÄ‚îÄ file_06.txt\n    ‚îú‚îÄ‚îÄ file_07.txt\n    ‚îú‚îÄ‚îÄ file_08.txt\n    ‚îú‚îÄ‚îÄ file_09.txt\n    ‚îú‚îÄ‚îÄ file_10.txt\n    ‚îú‚îÄ‚îÄ file_11.txt\n    ‚îú‚îÄ‚îÄ file_12.txt\n    ‚îú‚îÄ‚îÄ file_13.txt\n    ‚îú‚îÄ‚îÄ file_14.txt\n    ‚îú‚îÄ‚îÄ file_15.txt\n    ‚îú‚îÄ‚îÄ file_16.txt\n    ‚îú‚îÄ‚îÄ file_17.txt\n    ‚îú‚îÄ‚îÄ file_18.txt\n    ‚îú‚îÄ‚îÄ file_19.txt\n    ‚îú‚îÄ‚îÄ file_20.txt\n    ‚îî‚îÄ‚îÄ large_file.txt",
    "stateUrl": "https://storage.mcpmark.ai/filesystem/file_context.zip",
    "stateOriginalUrl": null
  },
  "instruction": "Please use FileSystem tools to finish the following task:\n\n### Task Description\n\nYou are given a directory containing multiple text files of varying sizes. Your task is to identify the 10 smallest .txt files, merge their content in alphabetical order, and create a consolidated file called \"merged_content.txt\" with proper formatting.\n\n### Task Objectives\n\n1. **Identify the 10 smallest .txt files** in the test directory\n2. **Sort the selected files alphabetically** by filename\n3. **Merge the content** of these files into a single file\n4. **Add file headers** (file name) before each file's content\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for File Merging Task\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef get_expected_files() -> list:\n    \"\"\"Get the expected 10 files in alphabetical order.\"\"\"\n    # The 10 smallest files (excluding file_12.txt) in alphabetical order\n    expected_files = [\n        \"file_10.txt\",\n        \"file_11.txt\", \n        \"file_13.txt\",\n        \"file_14.txt\",\n        \"file_15.txt\",\n        \"file_16.txt\",\n        \"file_17.txt\",\n        \"file_18.txt\",\n        \"file_19.txt\",\n        \"file_20.txt\"\n    ]\n    return expected_files\n\ndef verify_merged_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the merged_content.txt file exists.\"\"\"\n    merged_file = test_dir / \"merged_content.txt\"\n    \n    if not merged_file.exists():\n        print(\"‚ùå File 'merged_content.txt' not found\")\n        return False\n    \n    print(\"‚úÖ Merged content file found\")\n    return True\n\n\n\ndef verify_correct_files_selected(test_dir: Path) -> bool:\n    \"\"\"Verify that the correct 10 files were selected and included.\"\"\"\n    expected_files = get_expected_files()\n    merged_file = test_dir / \"merged_content.txt\"\n    \n    try:\n        content = merged_file.read_text()\n        \n        # Check if all expected files are present\n        for expected_file in expected_files:\n            if expected_file not in content:\n                print(f\"‚ùå Expected file '{expected_file}' not found in merged content\")\n                return False\n        \n        # Check if file_12.txt is NOT present (should be excluded)\n        if \"file_12.txt\" in content:\n            print(\"‚ùå file_12.txt should be excluded but was found in merged content\")\n            return False\n        \n        print(\"‚úÖ Correct files selected and included\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying file selection: {e}\")\n        return False\n\ndef verify_alphabetical_order(test_dir: Path) -> bool:\n    \"\"\"Verify that files are in alphabetical order.\"\"\"\n    expected_files = get_expected_files()\n    merged_file = test_dir / \"merged_content.txt\"\n    \n    try:\n        content = merged_file.read_text()\n        lines = content.split('\\n')\n        \n        # Extract filenames from the content (lines that contain .txt)\n        found_files = []\n        for line in lines:\n            line = line.strip()\n            # Check if this line contains any of the expected filenames\n            for expected_file in expected_files:\n                if expected_file in line:\n                    found_files.append(expected_file)\n                    break\n        \n        # Check if files are in alphabetical order\n        if found_files != expected_files:\n            print(f\"‚ùå Files not in correct alphabetical order\")\n            print(f\"   Expected: {expected_files}\")\n            print(f\"   Found: {found_files}\")\n            return False\n        \n        print(\"‚úÖ Files are in correct alphabetical order\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying alphabetical order: {e}\")\n        return False\n\ndef verify_file_content_integrity(test_dir: Path) -> bool:\n    \"\"\"Verify that the content of each file is preserved correctly.\"\"\"\n    expected_files = get_expected_files()\n    merged_file = test_dir / \"merged_content.txt\"\n    \n    try:\n        content = merged_file.read_text()\n        lines = content.split('\\n')\n        \n        for expected_file in expected_files:\n            # Get the original file content\n            original_file = test_dir / expected_file\n            original_content = original_file.read_text().strip()\n            \n            # Find the line index where this file's header appears\n            header_line_index = -1\n            for i, line in enumerate(lines):\n                if expected_file in line:\n                    header_line_index = i\n                    break\n            \n            if header_line_index == -1:\n                print(f\"‚ùå Could not find header for {expected_file}\")\n                return False\n            \n            # Find the next header line or end of file\n            next_header_index = len(lines)\n            for i in range(header_line_index + 1, len(lines)):\n                for other_file in expected_files:\n                    if other_file != expected_file and other_file in lines[i]:\n                        next_header_index = i\n                        break\n                if next_header_index != len(lines):\n                    break\n            \n            # Extract content lines (from header + 1 to next header)\n            content_lines = lines[header_line_index + 1:next_header_index]\n            merged_content = '\\n'.join(content_lines).strip()\n            \n            if merged_content != original_content:\n                print(f\"‚ùå Content mismatch for {expected_file}\")\n                print(f\"   Expected: {original_content}\")\n                print(f\"   Found: {merged_content}\")\n                return False\n        \n        print(\"‚úÖ All file contents preserved correctly\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying content integrity: {e}\")\n        return False\n\ndef verify_filename_headers(test_dir: Path) -> bool:\n    \"\"\"Verify that each file section starts with the correct filename header.\"\"\"\n    expected_files = get_expected_files()\n    merged_file = test_dir / \"merged_content.txt\"\n    \n    try:\n        content = merged_file.read_text()\n        \n        for expected_file in expected_files:\n            # Check if the filename appears anywhere in the content (as part of a line)\n            if expected_file not in content:\n                print(f\"‚ùå Filename header '{expected_file}' not found\")\n                return False\n        \n        print(\"‚úÖ All filename headers present and correctly formatted\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying filename headers: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"üîç Verifying File Merging Task...\")\n    \n    # Show expected files for debugging\n    expected_files = get_expected_files()\n    print(f\"üìã Expected files (10 smallest, excluding file_12.txt): {expected_files}\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Merged File Exists\", verify_merged_file_exists),\n        (\"Correct Files Selected\", verify_correct_files_selected),\n        (\"Alphabetical Order\", verify_alphabetical_order),\n        (\"Filename Headers\", verify_filename_headers),\n        (\"Content Integrity\", verify_file_content_integrity),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"‚úÖ File merging task completed correctly!\")\n        print(\"üéâ Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"‚ùå Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}