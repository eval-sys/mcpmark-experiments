{
  "task_id": "customer_analysis_fix",
  "task_name": "Customer Analysis Fix",
  "category_id": "dvdrental",
  "category_name": "DVD Rental",
  "description": "Debug and fix customer behavior analysis query producing incorrect rental counts and spending calculations.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-20",
  "difficulty": "L3",
  "tags": [
    "performance optimization",
    "data integrity enforcement"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Fix the customer analysis query that is producing incorrect results.\n\n## Background\n\nThe data analytics team attempted to create a customer behavior analysis query to identify active customers and analyze their spending patterns and preferences. The requirements are:\n- Only count rentals that have associated payment records (paid rentals)\n- Only include customers with at least 15 paid rentals\n- Only include customers with valid email addresses\n\nHowever, they're getting incorrect results - the query is over-counting rentals and calculating wrong spending amounts. \n\nYour task is to fix this query to produce accurate results.\n\n## The Problematic Query\n\nHere's the buggy query that needs to be fixed:\n\n```sql\nWITH customer_basic_stats AS (\n    SELECT \n        c.customer_id,\n        c.first_name || ' ' || c.last_name as customer_name,\n        ci.city as customer_city,\n        co.country as customer_country,\n        COUNT(r.rental_id) as total_rentals,\n        COUNT(DISTINCT i.film_id) as unique_films,\n        SUM(p.amount) as total_spent,\n        AVG(EXTRACT(days FROM (r.return_date - r.rental_date))) as avg_rental_duration\n    FROM customer c\n    JOIN address a ON c.address_id = a.address_id\n    JOIN city ci ON a.city_id = ci.city_id\n    JOIN country co ON ci.country_id = co.country_id\n    JOIN rental r ON c.customer_id = r.customer_id\n    JOIN inventory i ON r.inventory_id = i.inventory_id\n    JOIN payment p ON r.rental_id = p.rental_id\n    WHERE c.email IS NOT NULL\n    GROUP BY c.customer_id, c.first_name, c.last_name, ci.city, co.country\n    HAVING COUNT(r.rental_id) >= 15\n),\ncustomer_categories AS (\n    SELECT \n        c.customer_id,\n        cat.name as category_name,\n        COUNT(*) as category_count,\n        ROW_NUMBER() OVER (PARTITION BY c.customer_id ORDER BY COUNT(*) DESC, cat.name ASC) as rn\n    FROM customer c\n    JOIN rental r ON c.customer_id = r.customer_id\n    JOIN inventory i ON r.inventory_id = i.inventory_id\n    JOIN film f ON i.film_id = f.film_id\n    JOIN film_category fc ON f.film_id = fc.film_id\n    JOIN category cat ON fc.category_id = cat.category_id\n    JOIN payment p ON r.rental_id = p.rental_id\n    WHERE c.email IS NOT NULL\n    GROUP BY c.customer_id, cat.name\n),\ncustomer_actors AS (\n    SELECT \n        c.customer_id,\n        a.first_name || ' ' || a.last_name as actor_name,\n        COUNT(*) as actor_count,\n        ROW_NUMBER() OVER (PARTITION BY c.customer_id ORDER BY COUNT(*) DESC, (a.first_name || ' ' || a.last_name) ASC) as rn\n    FROM customer c\n    JOIN rental r ON c.customer_id = r.customer_id\n    JOIN inventory i ON r.inventory_id = i.inventory_id\n    JOIN film f ON i.film_id = f.film_id\n    JOIN film_actor fa ON f.film_id = fa.film_id\n    JOIN actor a ON fa.actor_id = a.actor_id\n    JOIN payment p ON r.rental_id = p.rental_id\n    WHERE c.email IS NOT NULL\n    GROUP BY c.customer_id, a.first_name, a.last_name\n),\nregional_popular_films AS (\n    SELECT \n        co.country,\n        f.title,\n        COUNT(*) as rental_count,\n        ROW_NUMBER() OVER (PARTITION BY co.country ORDER BY COUNT(*) DESC, f.title ASC) as rn\n    FROM rental r\n    JOIN inventory i ON r.inventory_id = i.inventory_id\n    JOIN film f ON i.film_id = f.film_id\n    JOIN customer c ON r.customer_id = c.customer_id\n    JOIN address a ON c.address_id = a.address_id\n    JOIN city ci ON a.city_id = ci.city_id\n    JOIN country co ON ci.country_id = co.country_id\n    JOIN payment p ON r.rental_id = p.rental_id\n    WHERE c.email IS NOT NULL\n    GROUP BY co.country, f.title\n)\nSELECT \n    cbs.customer_id,\n    cbs.customer_name,\n    cbs.customer_city,\n    cbs.customer_country,\n    cbs.total_rentals,\n    cbs.unique_films,\n    cbs.total_spent,\n    cc.category_name as favorite_category,\n    ca.actor_name as favorite_actor,\n    cbs.avg_rental_duration,\n    CASE \n        WHEN cbs.total_spent >= 150 THEN 'Premium'\n        WHEN cbs.total_spent >= 75 THEN 'Standard'\n        ELSE 'Basic'\n    END as customer_tier,\n    rpf.title as most_popular_film_in_region,\n    rpf.rental_count as regional_film_rental_count\nFROM customer_basic_stats cbs\nLEFT JOIN customer_categories cc ON cbs.customer_id = cc.customer_id AND cc.rn = 1\nLEFT JOIN customer_actors ca ON cbs.customer_id = ca.customer_id AND ca.rn = 1\nLEFT JOIN regional_popular_films rpf ON cbs.customer_country = rpf.country AND rpf.rn = 1\nORDER BY cbs.total_spent DESC, cbs.total_rentals DESC, cbs.customer_name ASC;\n```\n\n## Known Issues\n\nWhen comparing the problematic query results with the expected correct values, the following discrepancies are observed:\n\n1. **Rental count discrepancies**: Many customers show higher `total_rentals` counts than expected\n\n2. **Spending amount errors**: The `total_spent` values don't match the correct calculations \n\n3. **Incorrect favorite categories and actors**: Many customers show wrong favorite categories and actors compared to the expected results\n\n4. **Time calculation inconsistencies**: The `avg_rental_duration` values differ significantly from the correct calculations\n    - Example: Customer ID 1 shows 3.90 days instead of the expected 4.27 days\n    - Example: Customer ID 2 shows 5.23 days instead of the expected 5.69 days\n\n## Your Task\n\nDebug and fix the query to produce accurate results. Then create a table with your corrected results.\n\n1. **Fix the query** to ensure:\n   - Accurate customer spending and rental counts\n   - Correct favorite categories and actors\n   - Proper regional popular films\n\n2. **Create a table** called `customer_analysis_fixed` in the `public` schema with your corrected query results. The table should have the same columns as the original query output.\n\n**Important**: The business logic and output columns should remain the same - only fix the data accuracy issues.",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 3: Fix Customer Analysis Query\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"Compare two rows with appropriate tolerance for decimals and floats.\"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, (Decimal, float)) and isinstance(expected, (Decimal, float)):\n            # Use higher tolerance for floating point comparisons\n            if abs(float(actual) - float(expected)) > 0.1:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef verify_customer_analysis_fixed_table(conn) -> bool:\n    \"\"\"Verify the customer_analysis_fixed table results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT customer_id, customer_name, customer_city, customer_country,\n                   total_rentals, unique_films, total_spent, favorite_category,\n                   favorite_actor, avg_rental_duration, customer_tier,\n                   most_popular_film_in_region, regional_film_rental_count\n            FROM customer_analysis_fixed\n            ORDER BY total_spent DESC, total_rentals DESC, customer_name ASC\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query (the corrected version)\n        cur.execute(\"\"\"\n            WITH paid_rentals AS (\n            SELECT DISTINCT\n                    r.rental_id,\n                    r.customer_id,\n                    r.inventory_id,\n                    r.rental_date,\n                    r.return_date\n            FROM rental r\n            JOIN payment p ON p.rental_id = r.rental_id\n            ),\n            payments_by_customer AS (\n            SELECT pr.customer_id, SUM(p.amount) AS total_spent\n            FROM paid_rentals pr\n            JOIN payment p ON p.rental_id = pr.rental_id\n            GROUP BY pr.customer_id\n            ),\n            customer_basic_stats AS (\n            SELECT\n                c.customer_id,\n                c.first_name || ' ' || c.last_name AS customer_name,\n                ci.city AS customer_city,\n                co.country AS customer_country,\n                COUNT(DISTINCT pr.rental_id) AS total_rentals,\n                COUNT(DISTINCT i.film_id) AS unique_films,\n                pbc.total_spent,\n                AVG(EXTRACT(EPOCH FROM (pr.return_date - pr.rental_date)) / 86400.0) AS avg_rental_duration\n            FROM customer c\n            JOIN address a ON c.address_id = a.address_id\n            JOIN city ci ON a.city_id = ci.city_id\n            JOIN country co ON ci.country_id = co.country_id\n            JOIN paid_rentals pr ON pr.customer_id = c.customer_id\n            JOIN inventory i ON pr.inventory_id = i.inventory_id\n            JOIN payments_by_customer pbc ON pbc.customer_id = c.customer_id\n            WHERE c.email IS NOT NULL\n            GROUP BY c.customer_id, c.first_name, c.last_name, ci.city, co.country, pbc.total_spent\n            HAVING COUNT(DISTINCT pr.rental_id) >= 15\n            ),\n            customer_categories AS (\n            SELECT\n                pr.customer_id,\n                cat.name AS category_name,\n                COUNT(*) AS category_count,\n                ROW_NUMBER() OVER (\n                    PARTITION BY pr.customer_id\n                    ORDER BY COUNT(*) DESC, cat.name ASC\n                ) AS rn\n            FROM paid_rentals pr\n            JOIN inventory i ON pr.inventory_id = i.inventory_id\n            JOIN film f ON i.film_id = f.film_id\n            JOIN film_category fc ON f.film_id = fc.film_id\n            JOIN category cat ON fc.category_id = cat.category_id\n            JOIN customer c ON pr.customer_id = c.customer_id\n            WHERE c.email IS NOT NULL\n            GROUP BY pr.customer_id, cat.name\n            ),\n            customer_actors AS (\n            SELECT\n                pr.customer_id,\n                (a.first_name || ' ' || a.last_name) AS actor_name,\n                COUNT(*) AS actor_count,\n                ROW_NUMBER() OVER (\n                    PARTITION BY pr.customer_id\n                    ORDER BY COUNT(*) DESC, (a.first_name || ' ' || a.last_name) ASC\n                ) AS rn\n            FROM paid_rentals pr\n            JOIN inventory i ON pr.inventory_id = i.inventory_id\n            JOIN film f ON i.film_id = f.film_id\n            JOIN film_actor fa ON f.film_id = fa.film_id\n            JOIN actor a ON fa.actor_id = a.actor_id\n            JOIN customer c ON pr.customer_id = c.customer_id\n            WHERE c.email IS NOT NULL\n            GROUP BY pr.customer_id, a.first_name, a.last_name\n            ),\n            regional_popular_films AS (\n            SELECT\n                co.country,\n                f.title,\n                COUNT(DISTINCT pr.rental_id) AS rental_count,\n                ROW_NUMBER() OVER (\n                    PARTITION BY co.country\n                    ORDER BY COUNT(DISTINCT pr.rental_id) DESC, f.title ASC\n                ) AS rn\n            FROM paid_rentals pr\n            JOIN customer c ON pr.customer_id = c.customer_id\n            JOIN address a ON c.address_id = a.address_id\n            JOIN city ci ON a.city_id = ci.city_id\n            JOIN country co ON ci.country_id = co.country_id\n            JOIN inventory i ON pr.inventory_id = i.inventory_id\n            JOIN film f ON i.film_id = f.film_id\n            WHERE c.email IS NOT NULL\n            GROUP BY co.country, f.title\n            )\n            SELECT\n                cbs.customer_id,\n                cbs.customer_name,\n                cbs.customer_city,\n                cbs.customer_country,\n                cbs.total_rentals,\n                cbs.unique_films,\n                cbs.total_spent,\n                cc.category_name AS favorite_category,\n                ca.actor_name AS favorite_actor,\n                cbs.avg_rental_duration,\n                CASE\n                WHEN cbs.total_spent >= 150 THEN 'Premium'\n                WHEN cbs.total_spent >= 75  THEN 'Standard'\n                ELSE 'Basic'\n                END AS customer_tier,\n                rpf.title AS most_popular_film_in_region,\n                rpf.rental_count AS regional_film_rental_count\n            FROM customer_basic_stats cbs\n            LEFT JOIN customer_categories cc\n            ON cbs.customer_id = cc.customer_id AND cc.rn = 1\n            LEFT JOIN customer_actors ca\n            ON cbs.customer_id = ca.customer_id AND ca.rn = 1\n            LEFT JOIN regional_popular_films rpf\n            ON cbs.customer_country = rpf.country AND rpf.rn = 1\n            ORDER BY cbs.total_spent DESC, cbs.total_rentals DESC, cbs.customer_name ASC;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} rows, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch:\")\n                    print(f\"   Expected: {expected}\")\n                    print(f\"   Actual:   {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Query results are correct ({len(actual_results)} rows)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 70)\n    print(\"PostgreSQL Task 3 Verification: Fix Customer Analysis Query\")\n    print(\"=\" * 70)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"❌ No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n\n        # Verify results\n        success = verify_customer_analysis_fixed_table(conn)\n\n        conn.close()\n\n        if success:\n            print(\"\\n🎉 Task verification: PASS\")\n            print(\"   - Query was successfully debugged and fixed\")\n            print(\"   - All 587 rows match the expected results\")\n            sys.exit(0)\n        else:\n            print(\"\\n❌ Task verification: FAIL\")\n            print(\"   - The query still has issues\")\n            print(\"   - Please review the duplicate counting problem\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"❌ Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"❌ Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}