{
  "task_id": "structure_analysis",
  "task_name": "Structure Analysis",
  "category_id": "folder_structure",
  "category_name": "Folder Structure",
  "description": "Perform thorough analysis of complex folder hierarchy to generate a detailed structural summary report with comprehensive file statistics.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-16",
  "difficulty": "L3",
  "tags": [
    "pattern analysis",
    "data extraction"
  ],
  "mcp": [
    "filesystem"
  ],
  "metadata": {},
  "instruction": "# Directory Structure Analysis Task\n\nYou need to recursively traverse the entire folder structure under the main directory and generate a detailed statistical report in a file named `structure_analysis.txt`.\n\nIn all tasks, ignore `.DS_Store` files.\n\nIn any tasks, you should not change or delete any existed files.\n\nDo not try to use python code.\n\n---\n\n## 1. File Statistics\n\nCount the following information for the entire directory structure:\n\n- total number of files\n- total number of folders\n- total size of the hole folder (in bytes, include .DS_Store only in this subtask)\n\n**Format (one item per line):**\n\ntotal number of files: X\ntotal number of folders: Y\ntotal size of all files: Z\n\n---\n\n## 2. Depth Analysis\n\nIdentify the deepest folder path(s) in the directory and calculate its depth level.\n\n- Use relative paths based on main directory.\n- **Write the folder path only up to the folder, not including the file name.For example, if the file path is `./complex_structure/A/B/C/def.txt`, then the path in your report should be `complex_structure/A/B/C`, and the depth is `4`.**\n- If multiple deepest paths exist, list only one.\n\n**Format (one item per line):**\n\ndepth: N\nPATH\n\n---\n\n## 3. File Type Classification\n\nCategorize files by their extensions and count the number of files for each type.\nFiles without extensions should also be included.\n\n**Format (one extension per line):**\n\ntxt: count\npy: count\njpg: count\nmov: count\n(no extension): count\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Directory Structure Analysis Task\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\nimport re\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_structure_analysis_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the structure_analysis.txt file exists.\"\"\"\n    analysis_file = test_dir / \"structure_analysis.txt\"\n    \n    if not analysis_file.exists():\n        print(\"‚ùå File 'structure_analysis.txt' not found\")\n        return False\n    \n    print(\"‚úÖ structure_analysis.txt file found\")\n    return True\n\ndef verify_structure_analysis_file_readable(test_dir: Path) -> bool:\n    \"\"\"Verify that the structure_analysis.txt file is readable.\"\"\"\n    analysis_file = test_dir / \"structure_analysis.txt\"\n    \n    try:\n        content = analysis_file.read_text()\n        if not content.strip():\n            print(\"‚ùå structure_analysis.txt file is empty\")\n            return False\n        \n        print(\"‚úÖ structure_analysis.txt file is readable\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error reading structure_analysis.txt file: {e}\")\n        return False\n\ndef verify_subtask1_file_statistics(test_dir: Path) -> bool:\n    \"\"\"Verify subtask 1: File Statistics - files must be 69, folders must be 51, 58097 allows +-1000.\"\"\"\n    analysis_file = test_dir / \"structure_analysis.txt\"\n    \n    try:\n        content = analysis_file.read_text()\n        \n        # Extract numbers from the content\n        file_count_match = re.search(r'total number of files:\\s*(\\d+)', content)\n        folder_count_match = re.search(r'total number of folders:\\s*(\\d+)', content)\n        size_match = re.search(r'total size of all files:\\s*(\\d+)', content)\n        \n        if not file_count_match or not folder_count_match or not size_match:\n            print(\"‚ùå Could not extract file statistics from structure_analysis.txt\")\n            return False\n        \n        file_count = int(file_count_match.group(1))\n        folder_count = int(folder_count_match.group(1))\n        total_size = int(size_match.group(1))\n        \n        print(f\"üìä Found: files={file_count}, folders={folder_count}, size={total_size}\")\n        \n        # Check if file count is exactly 69\n        if file_count != 69:\n            print(f\"‚ùå File count must be 69, found: {file_count}\")\n            return False\n        \n        # Check if folder count is exactly 51\n        if folder_count != 51:\n            print(f\"‚ùå Folder count must be 51, found: {folder_count}\")\n            return False\n        \n        # Check if size is within acceptable range (58097 ¬± 1000)\n        expected_size = 58097\n        size_tolerance = 1000\n        if abs(total_size - expected_size) > size_tolerance:\n            print(f\"‚ùå Total size ({total_size}) is not within acceptable range ({expected_size} ¬± {size_tolerance})\")\n            return False\n        \n        print(f\"‚úÖ File statistics verified: files={file_count}, folders={folder_count}, size={total_size} (within tolerance)\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying file statistics: {e}\")\n        return False\n\ndef verify_subtask2_depth_analysis(test_dir: Path) -> bool:\n    \"\"\"Verify subtask 2: Depth Analysis - depth must be 7, verify path exists.\"\"\"\n    analysis_file = test_dir / \"structure_analysis.txt\"\n    \n    try:\n        content = analysis_file.read_text()\n        \n        # Extract depth and path\n        depth_match = re.search(r'depth:\\s*(\\d+)', content)\n        path_match = re.search(r'^([^\\n]+)$', content, re.MULTILINE)\n        \n        if not depth_match:\n            print(\"‚ùå Could not extract depth from structure_analysis.txt\")\n            return False\n        \n        depth = int(depth_match.group(1))\n        \n        # Check if depth is exactly 7\n        if depth != 7:\n            print(f\"‚ùå Depth must be 7, found: {depth}\")\n            return False\n        \n        print(f\"‚úÖ Depth verified: {depth}\")\n        \n        # Extract the path (it should be on a separate line after \"depth: 7\")\n        lines = content.split('\\n')\n        path_line = None\n        for i, line in enumerate(lines):\n            if line.strip() == f\"depth: {depth}\":\n                if i + 1 < len(lines):\n                    path_line = lines[i + 1].strip()\n                    break\n        \n        if not path_line:\n            print(\"‚ùå Could not find path line after depth specification\")\n            return False\n        \n        print(f\"üìÅ Found path: {path_line}\")\n        \n        # Verify that the path depth matches the declared depth\n        path_parts = path_line.split('/')\n        actual_depth = len(path_parts)\n        \n        if actual_depth != depth:\n            print(f\"‚ùå Path depth mismatch: declared depth is {depth}, but path has {actual_depth} levels\")\n            print(f\"   Path: {path_line}\")\n            print(f\"   Path parts: {path_parts}\")\n            return False\n        \n        print(f\"‚úÖ Path depth verified: {actual_depth} levels\")\n        \n        # Verify that this path exists in the test environment\n        expected_path = test_dir / path_line\n        if not expected_path.exists():\n            print(f\"‚ùå Path does not exist: {expected_path}\")\n            return False\n        \n        if not expected_path.is_dir():\n            print(f\"‚ùå Path exists but is not a directory: {expected_path}\")\n            return False\n        \n        print(f\"‚úÖ Path verified and exists: {path_line}\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying depth analysis: {e}\")\n        return False\n\ndef verify_subtask3_file_type_classification(test_dir: Path) -> bool:\n    \"\"\"Verify subtask 3: File Type Classification - 68 and 1 must be accurate.\"\"\"\n    analysis_file = test_dir / \"structure_analysis.txt\"\n    \n    try:\n        content = analysis_file.read_text()\n        \n        # Extract file type counts\n        txt_match = re.search(r'txt:\\s*(\\d+)', content)\n        py_match = re.search(r'py:\\s*(\\d+)', content)\n        \n        if not txt_match or not py_match:\n            print(\"‚ùå Could not extract file type counts from structure_analysis.txt\")\n            return False\n        \n        txt_count = int(txt_match.group(1))\n        py_count = int(py_match.group(1))\n        \n        print(f\"üìÅ Found: txt={txt_count}, py={py_count}\")\n        \n        # Check if txt count is exactly 68\n        if txt_count != 68:\n            print(f\"‚ùå txt count must be 68, found: {txt_count}\")\n            return False\n        \n        # Check if py count is exactly 1\n        if py_count != 1:\n            print(f\"‚ùå py count must be 1, found: {py_count}\")\n            return False\n        \n        print(f\"‚úÖ File type classification verified: txt={txt_count}, py={py_count}\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying file type classification: {e}\")\n        return False\n\ndef verify_file_format(test_dir: Path) -> bool:\n    \"\"\"Verify that the structure_analysis.txt file has proper format.\"\"\"\n    analysis_file = test_dir / \"structure_analysis.txt\"\n    \n    try:\n        content = analysis_file.read_text()\n        lines = content.split('\\n')\n        \n        # Check if file has the expected structure\n        if len(lines) < 5:  # Should have at least 5 lines\n            print(\"‚ùå File seems too short to contain all required information\")\n            return False\n        \n        # Basic format check - ensure it's not completely corrupted\n        if not content.strip():\n            print(\"‚ùå File is completely empty\")\n            return False\n        \n        print(\"‚úÖ File format is acceptable\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking file format: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    try:\n        test_dir = get_test_directory()\n        print(f\"üîç Verifying Directory Structure Analysis Task in: {test_dir}\")\n        \n        # Define verification steps\n        verification_steps = [\n            (\"Structure Analysis File Exists\", verify_structure_analysis_file_exists),\n            (\"File is Readable\", verify_structure_analysis_file_readable),\n            (\"Subtask 1: File Statistics\", verify_subtask1_file_statistics),\n            (\"Subtask 2: Depth Analysis\", verify_subtask2_depth_analysis),\n            (\"Subtask 3: File Type Classification\", verify_subtask3_file_type_classification),\n            (\"File Format\", verify_file_format),\n        ]\n        \n        # Run all verification steps\n        all_passed = True\n        for step_name, verify_func in verification_steps:\n            print(f\"\\n--- {step_name} ---\")\n            if not verify_func(test_dir):\n                all_passed = False\n        \n        # Final result\n        print(\"\\n\" + \"=\"*50)\n        if all_passed:\n            print(\"‚úÖ Directory Structure Analysis completed correctly!\")\n            print(\"üéâ Structure Analysis verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"‚ùå Structure Analysis verification: FAIL\")\n            sys.exit(1)\n            \n    except Exception as e:\n        print(f\"‚ùå Verification failed with error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}