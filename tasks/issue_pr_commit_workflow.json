{
  "task_id": "issue_pr_commit_workflow",
  "task_name": "Issue Pr Commit Workflow",
  "category_id": "harmony",
  "category_name": "Harmony",
  "description": "Implement complete bug tracking workflow demonstrating proper cross-referencing between issues, PRs, and commits for race condition fixes.",
  "author": "Zijian Wu",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "issue management",
    "pr workflows"
  ],
  "mcp": [
    "github"
  ],
  "metadata": {},
  "instruction": "I need you to implement a complete bug tracking and resolution workflow that demonstrates proper cross-referencing between issues, pull requests, and commits. Here's what you need to do:\n\n**Step 1: Create Issue for Race Condition Bug**\nCreate a new issue with:\n- Title containing: 'race condition', 'HarmonyEncoding', 'concurrent access'\n- Body must include:\n  - A \"## Problem\" heading describing threading issues\n  - A \"## Root Cause\" heading about file locking\n  - A \"## Expected Solution\" heading with bullet points\n  - References to issues #6 and #1\n  - Keywords: \"multiple threads\", \"tokenizer file downloads\", \"mutex-based file locking\"\n\n**Step 2: Create Feature Branch**\nCreate a new branch called 'fix/race-condition-tokenizer-loading' from main.\n\n**Step 3: Implement Thread-Safe Loading**\nOn the feature branch, create/update the file `src/concurrent_loading.rs` with:\n```rust\nuse std::sync::Mutex;\nuse std::sync::OnceLock;\n\n// Thread-safe tokenizer loading with file locks\nstatic DOWNLOAD_MUTEX: OnceLock<Mutex<()>> = OnceLock::new();\n\npub fn load_harmony_encoding_safe(name: &str) -> Result<HarmonyEncoding, HarmonyError> {\n    let _guard = DOWNLOAD_MUTEX.get_or_init(|| Mutex::new(())).lock().unwrap();\n    // Implementation for thread-safe loading\n    // Addresses race condition from issue #6\n    Ok(HarmonyEncoding::new())\n}\n\npub fn load_harmony_encoding_from_file(path: &str) -> Result<HarmonyEncoding, HarmonyError> {\n    // Offline loading API as requested in issue #1\n    HarmonyEncoding::from_file(path)\n}\n```\n\n**Step 4: Create Pull Request with Cross-References**\nCreate a pull request from 'fix/race-condition-tokenizer-loading' to 'main' with:\n- Title containing: 'Fix race condition', 'tokenizer loading', 'threading issues'\n- Body must include:\n  - A \"## Summary\" heading explaining the fix\n  - A \"## Changes\" heading with bullet points about mutex implementation\n  - A \"## Testing\" heading mentioning related issues\n  - \"Closes #[ISSUE_NUMBER]\" pattern linking to your created issue\n  - References to #1 and #6\n  - Keywords: \"thread-safe\", \"concurrent downloads\", \"offline loading API\"\n\n**Step 5: Add PR Review Comments**\nCreate a pending review and add a review comment to the PR with:\n- Technical analysis of the implementation approach\n- Discussion of thread safety mechanisms\n- Keywords that must be included: \"OnceLock\", \"mutex\", \"thread safety\", \"concurrent access\"\n- Reference to issue #1 and the offline loading capability\n- Explanation of how the solution prevents race conditions\nThen submit the review as a COMMENT type review.\n\n**Step 6: Update Issue with Implementation Details**\nAdd a comment to the original issue you created with:\n- Reference to the PR number using \"PR #[NUMBER]\" pattern\n- Technical details about the mutex-based solution\n- Keywords: \"std::sync::Mutex\", \"OnceLock\", \"thread-safe initialization\"\n- Mention of key implementation changes (DOWNLOAD_MUTEX, offline loading)\n- Reference back to issue #1 for offline loading requirement\n\n**Step 7: Close the Issue**\nClose the issue you created by updating its state to 'closed' with state_reason 'completed'.",
  "verify": "import sys\nimport os\nimport requests\nfrom typing import Dict, List, Optional, Tuple\nimport base64\nfrom dotenv import load_dotenv\n\n\ndef _get_github_api(\n    endpoint: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Tuple[bool, Optional[Dict]]:\n    \"\"\"Make a GET request to GitHub API and return (success, response).\"\"\"\n    url = f\"https://api.github.com/repos/{org}/{repo}/{endpoint}\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return True, response.json()\n        elif response.status_code == 404:\n            return False, None\n        else:\n            print(f\"API error for {endpoint}: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Exception for {endpoint}: {e}\", file=sys.stderr)\n        return False, None\n\n\ndef _check_branch_exists(\n    branch_name: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> bool:\n    \"\"\"Verify that a branch exists in the repository.\"\"\"\n    success, _ = _get_github_api(f\"branches/{branch_name}\", headers, org, repo)\n    return success\n\n\ndef _check_file_content(\n    branch: str,\n    file_path: str,\n    keywords: List[str],\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"harmony\",\n) -> bool:\n    \"\"\"Verify that a file exists in branch and contains required keywords.\"\"\"\n    success, result = _get_github_api(\n        f\"contents/{file_path}?ref={branch}\", headers, org, repo\n    )\n    if not success or not result:\n        return False\n\n    if keywords and result.get(\"content\"):\n        try:\n            content = base64.b64decode(result.get(\"content\", \"\")).decode(\"utf-8\")\n            return all(keyword in content for keyword in keywords)\n        except Exception as e:\n            print(f\"Content decode error for {file_path}: {e}\", file=sys.stderr)\n            return False\n\n    return True\n\n\ndef _find_issue_by_title(\n    title_substring: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Optional[Dict]:\n    \"\"\"Find an issue by title substring and return the issue data.\"\"\"\n    # Check both open and closed issues\n    for state in [\"open\", \"closed\"]:\n        success, issues = _get_github_api(\n            f\"issues?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and issues:\n            for issue in issues:\n                if title_substring.lower() in issue.get(\"title\", \"\").lower():\n                    return issue\n    return None\n\n\ndef _find_pr_by_title(\n    title_substring: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Optional[Dict]:\n    \"\"\"Find a PR by title substring and return the PR data.\"\"\"\n    # Check both open and closed PRs\n    for state in [\"open\", \"closed\"]:\n        success, prs = _get_github_api(\n            f\"pulls?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and prs:\n            for pr in prs:\n                if title_substring.lower() in pr.get(\"title\", \"\").lower():\n                    return pr\n    return None\n\n\ndef _check_issue_references(issue_body: str, reference_numbers: List[str]) -> bool:\n    \"\"\"Check if issue body contains references to specified issue numbers.\"\"\"\n    if not issue_body:\n        return False\n\n    return all(f\"#{ref}\" in issue_body for ref in reference_numbers)\n\n\ndef _check_pr_references(\n    pr_body: str, issue_number: int, reference_numbers: List[str]\n) -> bool:\n    \"\"\"Check if PR body contains proper references.\"\"\"\n    if not pr_body:\n        return False\n\n    # Check for \"Closes #X\" pattern\n    closes_pattern = (\n        f\"Closes #{issue_number}\" in pr_body or f\"closes #{issue_number}\" in pr_body\n    )\n\n    # Check for other references\n    refs_present = all(f\"#{ref}\" in pr_body for ref in reference_numbers)\n\n    return closes_pattern and refs_present\n\n\ndef _get_issue_comments(\n    issue_number: int, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> List[Dict]:\n    \"\"\"Get all comments for an issue.\"\"\"\n    success, comments = _get_github_api(\n        f\"issues/{issue_number}/comments\", headers, org, repo\n    )\n    if success and comments:\n        return comments\n    return []\n\n\ndef _get_pr_reviews(\n    pr_number: int, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> List[Dict]:\n    \"\"\"Get all reviews for a PR.\"\"\"\n    success, reviews = _get_github_api(f\"pulls/{pr_number}/reviews\", headers, org, repo)\n    if success and reviews:\n        return reviews\n    return []\n\n\ndef _check_issue_comment_references(\n    comments: List[Dict], pr_number: int, keywords: List[str]\n) -> bool:\n    \"\"\"Check if issue has a comment referencing the PR number with required technical keywords.\"\"\"\n    for comment in comments:\n        body = comment.get(\"body\", \"\")\n        has_pr_ref = (\n            f\"PR #{pr_number}\" in body\n            or f\"PR#{pr_number}\" in body\n            or f\"pr #{pr_number}\" in body.lower()\n        )\n        has_keywords = all(keyword.lower() in body.lower() for keyword in keywords)\n        if has_pr_ref and has_keywords:\n            return True\n    return False\n\n\ndef _check_title_keywords(title: str, required_keywords: List[str]) -> bool:\n    \"\"\"Check if title contains all required keywords.\"\"\"\n    return all(keyword.lower() in title.lower() for keyword in required_keywords)\n\n\ndef _check_headings_and_content(\n    body: str, headings: List[str], keywords: List[str]\n) -> bool:\n    \"\"\"Check if body contains required headings and keywords.\"\"\"\n    has_headings = all(heading in body for heading in headings)\n    has_keywords = all(keyword.lower() in body.lower() for keyword in keywords)\n    return has_headings and has_keywords\n\n\ndef _check_pr_review_content(reviews: List[Dict], keywords: List[str]) -> bool:\n    \"\"\"Check if PR has review comments containing required keywords.\"\"\"\n    for review in reviews:\n        body = review.get(\"body\", \"\")\n        if body and all(keyword.lower() in body.lower() for keyword in keywords):\n            return True\n    return False\n\n\ndef verify() -> bool:\n    \"\"\"\n    Programmatically verify that the issue-PR-commit workflow meets the\n    requirements described in description.md.\n    \"\"\"\n    # Load environment variables from .mcp_env\n    load_dotenv(\".mcp_env\")\n\n    # Get GitHub token and org\n    github_token = os.environ.get(\"MCP_GITHUB_TOKEN\")\n    github_org = os.environ.get(\"GITHUB_EVAL_ORG\")\n\n    if not github_token:\n        print(\"Error: MCP_GITHUB_TOKEN environment variable not set\", file=sys.stderr)\n        return False\n\n    if not github_org:\n        print(\"Error: GITHUB_EVAL_ORG environment variable not set\", file=sys.stderr)\n        return False\n\n    # Configuration constants\n    BRANCH_NAME = \"fix/race-condition-tokenizer-loading\"\n    ISSUE_TITLE_SUBSTRING = \"race condition in HarmonyEncoding\"\n    PR_TITLE_SUBSTRING = \"Fix race condition in tokenizer loading\"\n\n    # File content checks\n    RUST_FILE_KEYWORDS = [\n        \"DOWNLOAD_MUTEX\",\n        \"OnceLock<Mutex<()>>\",\n        \"load_harmony_encoding_safe\",\n        \"load_harmony_encoding_from_file\",\n        \"Thread-safe tokenizer loading\",\n    ]\n\n    # Issue content requirements\n    ISSUE_TITLE_KEYWORDS = [\"race condition\", \"HarmonyEncoding\", \"concurrent access\"]\n    ISSUE_REFERENCE_NUMBERS = [\"6\", \"1\"]\n    ISSUE_HEADINGS = [\"## Problem\", \"## Root Cause\", \"## Expected Solution\"]\n    ISSUE_KEYWORDS = [\n        \"multiple threads\",\n        \"tokenizer file downloads\",\n        \"mutex-based file locking\",\n    ]\n\n    # PR content requirements\n    PR_TITLE_KEYWORDS = [\"Fix race condition\", \"tokenizer loading\", \"threading issues\"]\n    PR_REFERENCE_NUMBERS = [\"1\", \"6\"]\n    PR_HEADINGS = [\"## Summary\", \"## Changes\", \"## Testing\"]\n    PR_KEYWORDS = [\"thread-safe\", \"concurrent downloads\", \"offline loading API\"]\n\n    # Review comment requirements\n    REVIEW_KEYWORDS = [\"OnceLock\", \"mutex\", \"thread safety\", \"concurrent access\"]\n\n    # Issue comment requirements\n    ISSUE_COMMENT_KEYWORDS = [\n        \"std::sync::Mutex\",\n        \"OnceLock\",\n        \"thread-safe initialization\",\n        \"DOWNLOAD_MUTEX\",\n    ]\n\n    headers = {\n        \"Authorization\": f\"token {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    # Run verification checks\n    print(\"Verifying GitHub issue-PR-commit workflow completion...\")\n\n    # 1. Check that feature branch exists\n    print(\"1. Verifying feature branch exists...\")\n    if not _check_branch_exists(BRANCH_NAME, headers, github_org):\n        print(f\"Error: Branch '{BRANCH_NAME}' not found\", file=sys.stderr)\n        return False\n\n    # 2. Check that the Rust implementation file exists with required content\n    print(\"2. Verifying concurrent_loading.rs implementation...\")\n    if not _check_file_content(\n        BRANCH_NAME,\n        \"src/concurrent_loading.rs\",\n        RUST_FILE_KEYWORDS,\n        headers,\n        github_org,\n    ):\n        print(\n            \"Error: src/concurrent_loading.rs not found or missing required content\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 3. Find the created issue\n    print(\"3. Verifying issue creation and content...\")\n    issue = _find_issue_by_title(ISSUE_TITLE_SUBSTRING, headers, github_org)\n    if not issue:\n        print(\n            f\"Error: Issue with title containing '{ISSUE_TITLE_SUBSTRING}' not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    issue_number = issue.get(\"number\")\n    issue_title = issue.get(\"title\", \"\")\n    issue_body = issue.get(\"body\", \"\")\n\n    # Check issue title keywords\n    if not _check_title_keywords(issue_title, ISSUE_TITLE_KEYWORDS):\n        print(\"Error: Issue title missing required keywords\", file=sys.stderr)\n        return False\n\n    # Check issue headings, content and references\n    if not _check_headings_and_content(issue_body, ISSUE_HEADINGS, ISSUE_KEYWORDS):\n        print(\"Error: Issue missing required headings or keywords\", file=sys.stderr)\n        return False\n\n    if not _check_issue_references(issue_body, ISSUE_REFERENCE_NUMBERS):\n        print(\n            \"Error: Issue does not reference required issues #6 and #1\", file=sys.stderr\n        )\n        return False\n\n    # 4. Find the created PR\n    print(\"4. Verifying pull request creation and content...\")\n    pr = _find_pr_by_title(PR_TITLE_SUBSTRING, headers, github_org)\n    if not pr:\n        print(\n            f\"Error: PR with title containing '{PR_TITLE_SUBSTRING}' not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    pr_number = pr.get(\"number\")\n    pr_title = pr.get(\"title\", \"\")\n    pr_body = pr.get(\"body\", \"\")\n\n    # Check PR title keywords\n    if not _check_title_keywords(pr_title, PR_TITLE_KEYWORDS):\n        print(\"Error: PR title missing required keywords\", file=sys.stderr)\n        return False\n\n    # Check PR headings and content\n    if not _check_headings_and_content(pr_body, PR_HEADINGS, PR_KEYWORDS):\n        print(\"Error: PR missing required headings or keywords\", file=sys.stderr)\n        return False\n\n    # Check PR references\n    if not _check_pr_references(pr_body, issue_number, PR_REFERENCE_NUMBERS):\n        print(\n            f\"Error: PR does not properly reference issue #{issue_number} or issues #1, #6\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 5. Check PR review comments\n    print(\"5. Verifying PR review comments...\")\n    reviews = _get_pr_reviews(pr_number, headers, github_org)\n    if not _check_pr_review_content(reviews, REVIEW_KEYWORDS):\n        print(\n            \"Error: PR missing review comment with required technical keywords\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 6. Check issue comments for PR reference with technical keywords\n    print(\"6. Verifying issue comment referencing PR...\")\n    issue_comments = _get_issue_comments(issue_number, headers, github_org)\n    if not _check_issue_comment_references(\n        issue_comments, pr_number, ISSUE_COMMENT_KEYWORDS\n    ):\n        print(\n            f\"Error: Issue #{issue_number} missing comment referencing PR #{pr_number} with required technical keywords\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 7. Check issue is closed\n    print(\"7. Verifying issue closure...\")\n    if issue.get(\"state\") != \"closed\":\n        print(f\"Error: Issue #{issue_number} is not closed\", file=sys.stderr)\n        return False\n\n    print(\"\\n✓ All verification checks passed!\")\n    print(\"Issue-PR-commit workflow completed successfully:\")\n    print(f\"  - Issue #{issue_number}: {issue.get('title')}\")\n    print(f\"  - PR #{pr_number}: {pr.get('title')}\")\n    print(f\"  - Branch: {BRANCH_NAME}\")\n    return True\n\n\nif __name__ == \"__main__\":\n    success = verify()\n    sys.exit(0 if success else 1)\n"
}