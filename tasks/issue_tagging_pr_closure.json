{
  "task_id": "issue_tagging_pr_closure",
  "task_name": "Issue Tagging Pr Closure",
  "category_id": "harmony",
  "category_name": "Harmony",
  "description": "Simulate development workflow where enhancement PR is closed without merging due to technical constraints discovered during implementation.",
  "author": "Zijian Wu",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "issue management",
    "pr workflows"
  ],
  "mcp": [
    "github"
  ],
  "metadata": {},
  "instruction": "I need you to simulate a realistic development workflow where an enhancement issue is created, implementation is attempted via a pull request, but then the PR must be closed without merging due to technical constraints discovered during the implementation process.\n\n**Step 1: Create Enhancement Issue**\nCreate a new issue with:\n- Title containing: \"Upgrade JavaScript demo to use ESM imports\" and \"modern module system\"\n- Body must include:\n  - A \"## Problem\" heading describing CommonJS limitations\n  - A \"## Proposed Solution\" heading about ESM migration\n  - A \"## Benefits\" heading listing advantages\n  - Reference to issue #26 (which is about JavaScript demo issues)\n  - Keywords: \"CommonJS\", \"ESM imports\", \"module bundling\", \"modern JavaScript\"\n- Labels: Add \"enhancement\" label to the issue\n\n**Step 2: Create Feature Branch**\nCreate a new branch called 'feat/esm-migration-attempt' from main.\n\n**Step 3: Attempt ESM Implementation**\nOn the feature branch, update the file `javascript/demo/package.json` with:\n```json\n{\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"webpack --mode production --entry ./src/main.js\"\n  },\n  \"dependencies\": {\n    \"@openai/harmony\": \"^0.1.0\",\n    \"webpack\": \"^5.0.0\"\n  }\n}\n```\n\nAlso create `javascript/demo/src/main.js` with:\n```javascript\n// ESM import attempt - fails due to harmony core requirements\nimport { HarmonyEncoding } from '@openai/harmony';\n\n// This breaks the existing CommonJS integration\n// harmony core requires specific CommonJS patterns\nexport const initHarmony = () => {\n    throw new Error(\"ESM migration incompatible with harmony core\");\n};\n```\n\n**Step 4: Create Pull Request**\nCreate a pull request from 'feat/esm-migration-attempt' to 'main' with:\n- Title containing: \"Upgrade JavaScript demo to ESM imports\" and \"modern modules\"\n- Body must include:\n  - A \"## Summary\" heading explaining the attempted migration\n  - A \"## Changes\" heading with bullet points about ESM implementation\n  - A \"## Issues Discovered\" heading describing technical problems found\n  - \"Addresses #[ISSUE_NUMBER]\" pattern linking to your created issue\n  - Keywords: \"ESM migration\", \"webpack configuration\", \"module compatibility\", \"breaking changes\"\n- Labels: Add \"enhancement\" and \"needs-investigation\" labels to the PR\n\n**Step 5: Investigate and Document Problems**\nAdd a comment to the PR explaining the technical barriers discovered. The comment must contain these exact keywords:\n- \"CommonJS required\"\n- \"breaking compatibility\" \n- \"build system constraints\"\n- \"core tokenization\"\n- \"approach is not viable\"\nAlso include technical analysis of harmony core's CommonJS dependencies and webpack configuration conflicts.\n\n**Step 6: Update Issue with Findings**\nAdd a comment to the original issue you created. The comment must contain these exact keywords:\n- \"technical constraints\"\n- \"CommonJS dependency\"\n- \"harmony core limitations\" \n- \"build system compatibility\"\n- \"not viable at this time\"\nAlso reference the PR number using \"PR #[NUMBER]\" pattern and provide detailed explanation of why ESM migration cannot proceed.\n\n**Step 7: Close PR Without Merging**\nClose the pull request without merging by updating its state to 'closed', and add a final comment. The comment must contain these exact keywords:\n- \"architectural limitations\"\n- \"future consideration\" \n- \"core refactoring required\"\n- \"cannot be merged\"\nAlso explain why the PR cannot be merged, what would need to change in the future, reference back to the issue, and add \"wontfix\" label to the PR.\n\n**Step 8: Close Issue as Not Planned**\nClose the original issue by updating its state to 'closed' with state_reason 'not_planned'. Add a final comment to the issue that must contain these exact keywords:\n- \"closing as not planned\"\n- \"architectural constraints\"\n- \"future implementation blocked\"\n- \"requires core redesign\"",
  "verify": "import sys\nimport os\nimport requests\nfrom typing import Dict, List, Optional, Tuple\nfrom dotenv import load_dotenv\n\n\ndef _get_github_api(\n    endpoint: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Tuple[bool, Optional[Dict]]:\n    \"\"\"Make a GET request to GitHub API and return (success, response).\"\"\"\n    url = f\"https://api.github.com/repos/{org}/{repo}/{endpoint}\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return True, response.json()\n        elif response.status_code == 404:\n            return False, None\n        else:\n            print(f\"API error for {endpoint}: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Exception for {endpoint}: {e}\", file=sys.stderr)\n        return False, None\n\n\ndef _check_branch_exists(\n    branch_name: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> bool:\n    \"\"\"Verify that a branch exists in the repository.\"\"\"\n    success, _ = _get_github_api(f\"branches/{branch_name}\", headers, org, repo)\n    return success\n\n\ndef _check_file_content(\n    branch: str,\n    file_path: str,\n    keywords: List[str],\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"harmony\",\n) -> bool:\n    \"\"\"Verify that a file exists in branch and contains required keywords.\"\"\"\n    import base64\n\n    success, result = _get_github_api(\n        f\"contents/{file_path}?ref={branch}\", headers, org, repo\n    )\n    if not success or not result:\n        return False\n\n    if keywords and result.get(\"content\"):\n        try:\n            content = base64.b64decode(result.get(\"content\", \"\")).decode(\"utf-8\")\n            return all(keyword in content for keyword in keywords)\n        except Exception as e:\n            print(f\"Content decode error for {file_path}: {e}\", file=sys.stderr)\n            return False\n\n    return True\n\n\ndef _find_issue_by_title_keywords(\n    title_keywords: List[str], headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Optional[Dict]:\n    \"\"\"Find an issue by title keywords and return the issue data.\"\"\"\n    for state in [\"open\", \"closed\"]:\n        success, issues = _get_github_api(\n            f\"issues?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and issues:\n            for issue in issues:\n                title = issue.get(\"title\", \"\").lower()\n                if all(keyword.lower() in title for keyword in title_keywords):\n                    return issue\n    return None\n\n\ndef _find_pr_by_title_keywords(\n    title_keywords: List[str], headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Optional[Dict]:\n    \"\"\"Find a PR by title keywords and return the PR data.\"\"\"\n    for state in [\"open\", \"closed\"]:\n        success, prs = _get_github_api(\n            f\"pulls?state={state}&per_page=100\", headers, org, repo\n        )\n        if success and prs:\n            for pr in prs:\n                title = pr.get(\"title\", \"\").lower()\n                if all(keyword.lower() in title for keyword in title_keywords):\n                    return pr\n    return None\n\n\ndef _check_labels(labels: List[Dict], required_labels: List[str]) -> bool:\n    \"\"\"Check if required labels are present.\"\"\"\n    label_names = [label.get(\"name\", \"\").lower() for label in labels]\n    return all(req_label.lower() in label_names for req_label in required_labels)\n\n\ndef _check_headings_and_keywords(\n    body: str, headings: List[str], keywords: List[str]\n) -> bool:\n    \"\"\"Check if body contains required headings and keywords.\"\"\"\n    if not body:\n        return False\n    has_headings = all(heading in body for heading in headings)\n    has_keywords = all(keyword.lower() in body.lower() for keyword in keywords)\n    return has_headings and has_keywords\n\n\ndef _check_issue_reference(body: str, issue_number: int) -> bool:\n    \"\"\"Check if body contains reference to the issue.\"\"\"\n    if not body:\n        return False\n    return f\"#{issue_number}\" in body or f\"Addresses #{issue_number}\" in body\n\n\ndef _get_issue_comments(\n    issue_number: int, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> List[Dict]:\n    \"\"\"Get all comments for an issue.\"\"\"\n    success, comments = _get_github_api(\n        f\"issues/{issue_number}/comments\", headers, org, repo\n    )\n    if success and comments:\n        return comments\n    return []\n\n\ndef _get_pr_comments(\n    pr_number: int, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> List[Dict]:\n    \"\"\"Get all comments for a PR.\"\"\"\n    success, comments = _get_github_api(\n        f\"issues/{pr_number}/comments\", headers, org, repo\n    )\n    if success and comments:\n        return comments\n    return []\n\n\ndef _check_pr_technical_comment(comments: List[Dict], keywords: List[str]) -> bool:\n    \"\"\"Check if PR has a comment with technical analysis containing required keywords.\"\"\"\n    for comment in comments:\n        body = comment.get(\"body\", \"\")\n        if body and all(keyword.lower() in body.lower() for keyword in keywords):\n            return True\n    return False\n\n\ndef _check_issue_comment_with_pr_ref(\n    comments: List[Dict], pr_number: int, keywords: List[str]\n) -> bool:\n    \"\"\"Check if issue has a comment referencing the PR with required keywords.\"\"\"\n    for comment in comments:\n        body = comment.get(\"body\", \"\")\n        has_pr_ref = (\n            f\"PR #{pr_number}\" in body\n            or f\"PR#{pr_number}\" in body\n            or f\"pr #{pr_number}\" in body.lower()\n        )\n        has_keywords = all(keyword.lower() in body.lower() for keyword in keywords)\n        if has_pr_ref and has_keywords:\n            return True\n    return False\n\n\ndef verify() -> bool:\n    \"\"\"\n    Programmatically verify that the issue tagging and PR closure workflow meets the\n    requirements described in description.md.\n    \"\"\"\n    # Load environment variables from .mcp_env\n    load_dotenv(\".mcp_env\")\n\n    # Get GitHub token and org\n    github_token = os.environ.get(\"MCP_GITHUB_TOKEN\")\n    github_org = os.environ.get(\"GITHUB_EVAL_ORG\")\n\n    if not github_token:\n        print(\"Error: MCP_GITHUB_TOKEN environment variable not set\", file=sys.stderr)\n        return False\n\n    if not github_org:\n        print(\"Error: GITHUB_EVAL_ORG environment variable not set\", file=sys.stderr)\n        return False\n\n    # Configuration constants\n    BRANCH_NAME = \"feat/esm-migration-attempt\"\n\n    # Issue requirements\n    ISSUE_TITLE_KEYWORDS = [\n        \"Upgrade JavaScript demo to use ESM imports\",\n        \"modern module system\",\n    ]\n    ISSUE_HEADINGS = [\"## Problem\", \"## Proposed Solution\", \"## Benefits\"]\n    ISSUE_KEYWORDS = [\"CommonJS\", \"ESM imports\", \"module bundling\", \"modern JavaScript\"]\n    ISSUE_LABELS = [\"enhancement\", \"wontfix\"]\n\n    # PR requirements\n    PR_TITLE_KEYWORDS = [\"Upgrade JavaScript demo to ESM imports\", \"modern modules\"]\n    PR_HEADINGS = [\"## Summary\", \"## Changes\", \"## Issues Discovered\"]\n    PR_KEYWORDS = [\n        \"ESM migration\",\n        \"webpack configuration\",\n        \"module compatibility\",\n        \"breaking changes\",\n    ]\n    PR_LABELS = [\"enhancement\", \"needs-investigation\", \"wontfix\"]\n\n    # File content requirements\n    PACKAGE_JSON_KEYWORDS = ['\"type\": \"module\"', \"webpack\", \"@openai/harmony\"]\n    MAIN_JS_KEYWORDS = [\n        \"import { HarmonyEncoding }\",\n        \"ESM import attempt\",\n        \"harmony core\",\n    ]\n\n    # Comment requirements\n    PR_TECHNICAL_KEYWORDS = [\n        \"CommonJS required\",\n        \"breaking compatibility\",\n        \"build system constraints\",\n        \"core tokenization\",\n        \"approach is not viable\",\n    ]\n    ISSUE_COMMENT_KEYWORDS = [\n        \"technical constraints\",\n        \"CommonJS dependency\",\n        \"harmony core limitations\",\n        \"build system compatibility\",\n        \"not viable at this time\",\n    ]\n    PR_CLOSURE_KEYWORDS = [\n        \"architectural limitations\",\n        \"future consideration\",\n        \"core refactoring required\",\n        \"cannot be merged\",\n    ]\n    ISSUE_CLOSURE_KEYWORDS = [\n        \"closing as not planned\",\n        \"architectural constraints\",\n        \"future implementation blocked\",\n        \"requires core redesign\",\n    ]\n\n    headers = {\n        \"Authorization\": f\"token {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    # Run verification checks\n    print(\"Verifying issue tagging and PR closure workflow completion...\")\n\n    # 1. Check that feature branch exists\n    print(\"1. Verifying feature branch exists...\")\n    if not _check_branch_exists(BRANCH_NAME, headers, github_org):\n        print(f\"Error: Branch '{BRANCH_NAME}' not found\", file=sys.stderr)\n        return False\n\n    # 2. Check that implementation files exist with required content\n    print(\"2. Verifying ESM implementation files...\")\n    if not _check_file_content(\n        BRANCH_NAME,\n        \"javascript/demo/package.json\",\n        PACKAGE_JSON_KEYWORDS,\n        headers,\n        github_org,\n    ):\n        print(\n            \"Error: javascript/demo/package.json not found or missing required content\",\n            file=sys.stderr,\n        )\n        return False\n\n    if not _check_file_content(\n        BRANCH_NAME,\n        \"javascript/demo/src/main.js\",\n        MAIN_JS_KEYWORDS,\n        headers,\n        github_org,\n    ):\n        print(\n            \"Error: javascript/demo/src/main.js not found or missing required content\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 3. Find the created issue\n    print(\"3. Verifying issue creation and content...\")\n    issue = _find_issue_by_title_keywords(ISSUE_TITLE_KEYWORDS, headers, github_org)\n    if not issue:\n        print(\n            \"Error: Issue with title containing required keywords not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    issue_number = issue.get(\"number\")\n    issue_body = issue.get(\"body\", \"\")\n    issue_labels = issue.get(\"labels\", [])\n\n    # Check issue content\n    if not _check_headings_and_keywords(issue_body, ISSUE_HEADINGS, ISSUE_KEYWORDS):\n        print(\"Error: Issue missing required headings or keywords\", file=sys.stderr)\n        return False\n\n    # Check issue references #26\n    if \"#26\" not in issue_body:\n        print(\"Error: Issue does not reference issue #26\", file=sys.stderr)\n        return False\n\n    # Check issue labels\n    if not _check_labels(issue_labels, ISSUE_LABELS):\n        print(f\"Error: Issue missing required labels: {ISSUE_LABELS}\", file=sys.stderr)\n        return False\n\n    # 4. Find the created PR\n    print(\"4. Verifying pull request creation and content...\")\n    pr = _find_pr_by_title_keywords(PR_TITLE_KEYWORDS, headers, github_org)\n    if not pr:\n        print(\n            \"Error: PR with title containing required keywords not found\",\n            file=sys.stderr,\n        )\n        return False\n\n    pr_number = pr.get(\"number\")\n    pr_body = pr.get(\"body\", \"\")\n    pr_labels = pr.get(\"labels\", [])\n    pr_state = pr.get(\"state\")\n\n    # Check PR content\n    if not _check_headings_and_keywords(pr_body, PR_HEADINGS, PR_KEYWORDS):\n        print(\"Error: PR missing required headings or keywords\", file=sys.stderr)\n        return False\n\n    # Check PR references issue\n    if not _check_issue_reference(pr_body, issue_number):\n        print(f\"Error: PR does not reference issue #{issue_number}\", file=sys.stderr)\n        return False\n\n    # Check PR labels\n    if not _check_labels(pr_labels, PR_LABELS):\n        print(f\"Error: PR missing required labels: {PR_LABELS}\", file=sys.stderr)\n        return False\n\n    # 5. Check PR is closed (not merged)\n    print(\"5. Verifying PR is closed without merging...\")\n    if pr_state != \"closed\":\n        print(f\"Error: PR #{pr_number} is not closed\", file=sys.stderr)\n        return False\n\n    if pr.get(\"merged_at\"):\n        print(\n            f\"Error: PR #{pr_number} was merged (should be closed without merging)\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 6. Check PR technical analysis comment\n    print(\"6. Verifying PR technical analysis comment...\")\n    pr_comments = _get_pr_comments(pr_number, headers, github_org)\n    if not _check_pr_technical_comment(pr_comments, PR_TECHNICAL_KEYWORDS):\n        print(\n            \"Error: PR missing technical analysis comment with required keywords\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 7. Check issue comment with PR reference\n    print(\"7. Verifying issue comment referencing PR...\")\n    issue_comments = _get_issue_comments(issue_number, headers, github_org)\n    if not _check_issue_comment_with_pr_ref(\n        issue_comments, pr_number, ISSUE_COMMENT_KEYWORDS\n    ):\n        print(\n            f\"Error: Issue #{issue_number} missing comment referencing PR #{pr_number} with required keywords\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 8. Check PR closure comment with required keywords\n    print(\"8. Verifying PR closure comment...\")\n    pr_closure_comment_found = False\n    for comment in pr_comments:\n        body = comment.get(\"body\", \"\")\n        if body and all(\n            keyword.lower() in body.lower() for keyword in PR_CLOSURE_KEYWORDS\n        ):\n            pr_closure_comment_found = True\n            break\n\n    if not pr_closure_comment_found:\n        print(\n            \"Error: PR missing closure comment with required keywords\", file=sys.stderr\n        )\n        return False\n\n    # 9. Verify issue is closed as not_planned\n    print(\"9. Verifying issue is closed as not_planned...\")\n    if issue.get(\"state\") != \"closed\":\n        print(f\"Error: Issue #{issue_number} should be closed\", file=sys.stderr)\n        return False\n\n    if issue.get(\"state_reason\") != \"not_planned\":\n        print(\n            f\"Error: Issue #{issue_number} should be closed with state_reason 'not_planned'\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 10. Check issue closure comment with required keywords\n    print(\"10. Verifying issue closure comment...\")\n    issue_closure_comment_found = False\n    for comment in issue_comments:\n        body = comment.get(\"body\", \"\")\n        if body and all(\n            keyword.lower() in body.lower() for keyword in ISSUE_CLOSURE_KEYWORDS\n        ):\n            issue_closure_comment_found = True\n            break\n\n    if not issue_closure_comment_found:\n        print(\n            \"Error: Issue missing closure comment with required keywords\",\n            file=sys.stderr,\n        )\n        return False\n\n    print(\"\\n✓ All verification checks passed!\")\n    print(\"Issue tagging and PR closure workflow completed successfully:\")\n    print(f\"  - Issue #{issue_number}: {issue.get('title')} (closed as not_planned)\")\n    print(f\"  - PR #{pr_number}: {pr.get('title')} (closed without merging)\")\n    print(f\"  - Branch: {BRANCH_NAME}\")\n    print(\"  - All comments contain required keywords\")\n    print(\"  - Technical constraints properly documented and communicated\")\n    return True\n\n\nif __name__ == \"__main__\":\n    success = verify()\n    sys.exit(0 if success else 1)\n",
  "model_results": {
    "gemini-2-5-pro": 0,
    "gpt-4-1-mini": 0,
    "claude-4-sonnet": 0,
    "k2": 0,
    "gemini-2-5-flash": 0,
    "gpt-4-1": 0,
    "o3": 0
  }
}