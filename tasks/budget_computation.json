{
  "task_id": "budget_computation",
  "task_name": "Budget Computation",
  "category_id": "desktop_template",
  "category_name": "Desktop Template",
  "description": "Analyze personal expense data extracted from desktop files to create a detailed budget summary report for financial review.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-14",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "pattern analysis"
  ],
  "mcp": [
    "filesystem"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "desktop_template/\n    ‚îú‚îÄ‚îÄ Archives/\n    ‚îÇ       ‚îú‚îÄ‚îÄ backup_contacts.csv\n    ‚îÇ       ‚îî‚îÄ‚îÄ tax_documents_2022.csv\n    ‚îú‚îÄ‚îÄ Desktop/\n    ‚îÇ       ‚îî‚îÄ‚îÄ contacts.csv\n    ‚îú‚îÄ‚îÄ Documents/\n    ‚îÇ       ‚îú‚îÄ‚îÄ Personal/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ tax_info_2023.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ Projects/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ budget_tracker.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ Work/\n    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ client_list.csv\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ timesheet.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ budget.csv\n    ‚îÇ       ‚îî‚îÄ‚îÄ important_dates.csv\n    ‚îú‚îÄ‚îÄ Downloads/\n    ‚îÇ       ‚îú‚îÄ‚îÄ expenses.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ fitness_log.csv\n    ‚îÇ       ‚îî‚îÄ‚îÄ price_comparisons.csv\n    ‚îú‚îÄ‚îÄ Temp/\n    ‚îÇ       ‚îî‚îÄ‚îÄ test_data.csv\n    ‚îú‚îÄ‚îÄ book_list.txt\n    ‚îú‚îÄ‚îÄ bookmark_export.txt\n    ‚îú‚îÄ‚îÄ calculations.txt\n    ‚îú‚îÄ‚îÄ correspondence_2023.txt\n    ‚îú‚îÄ‚îÄ draft_letter.txt\n    ‚îú‚îÄ‚îÄ emergency_contacts.txt\n    ‚îú‚îÄ‚îÄ example.txt\n    ‚îî‚îÄ‚îÄ experiment_results.txt\n",
    "stateUrl": "https://storage.mcpmark.ai/filesystem/desktop_template.zip",
    "stateOriginalUrl": null
  },
  "instruction": "Please use FileSystem tools to finish the following task:\n\n### Task Description\n\nYou need to analyze all the files in the desktop environment to calculate personal life expenses and create a budget summary.\n\n### Task Objectives\n\n1. **Locate and analyze all files** in the desktop environment\n2. **Extract personal life expenses** from the files (such as salary, food, living material, tax, expenses on the internet, ...) (exclude expenses in project/work)\n3. **Create a file named `total_budget.txt`** in the main directory\n4. **Format each expense entry** as `file_path;price` (one per line)\n5. **Add total sum** as the last line, rounded to 2 decimal places\n\n### Output Format\n\nThe `total_budget.txt` file should contain:\n\n- One expense per line in format: `file_path;price`\n- File path should be the relative path from the main directory\n- Price should be rounded to 2 decimal places\n- Last line should be the total sum\n- No additional text or explanations\n\n### Important Notes\n\n- Only include personal life expenses (not in project/work)\n- Use the cheapest available price when multiple options exist for one thing\n- The total should match the sum of all individual expenses\n- Hint: If a file contains 1 item for personal consumption, it means that all the entry in entire file is for personal consumption\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Budget Computation Task\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\nfrom collections import Counter\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_total_budget_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the total_budget.txt file exists.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    if not budget_file.exists():\n        print(\"‚ùå File 'total_budget.txt' not found\")\n        return False\n    \n    print(\"‚úÖ total_budget.txt file found\")\n    return True\n\ndef verify_file_format(test_dir: Path) -> bool:\n    \"\"\"Verify that the total_budget.txt file has proper format.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    try:\n        content = budget_file.read_text()\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        if len(lines) < 2:\n            print(\"‚ùå File must contain at least 2 lines (expenses + total)\")\n            return False\n        \n        # Check that all lines except the last follow the format file_path;price\n        for i, line in enumerate(lines[:-1]):\n            if ';' not in line:\n                print(f\"‚ùå Line {i+1} does not contain ';' separator: {line}\")\n                return False\n            \n            parts = line.split(';')\n            if len(parts) != 2:\n                print(f\"‚ùå Line {i+1} does not have exactly 2 parts: {line}\")\n                return False\n            \n            # Check if second part is a valid number\n            try:\n                float(parts[1])\n            except ValueError:\n                print(f\"‚ùå Line {i+1} price is not a valid number: {parts[1]}\")\n                return False\n        \n        # Check if last line is a valid number (total)\n        try:\n            float(lines[-1])\n        except ValueError:\n            print(f\"‚ùå Last line is not a valid number: {lines[-1]}\")\n            return False\n        \n        print(\"‚úÖ File format is correct\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error reading or parsing file: {e}\")\n        return False\n\ndef verify_expense_entries(test_dir: Path) -> bool:\n    \"\"\"Verify that all 15 required expense entries are present.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    try:\n        content = budget_file.read_text()\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        # Should have 16 lines total (15 expenses + 1 total)\n        if len(lines) != 16:\n            print(f\"‚ùå Expected 16 lines (15 expenses + 1 total), found {len(lines)}\")\n            return False\n        \n        # Check that we have exactly 15 expense entries\n        expense_lines = lines[:-1]  # All lines except the last\n        \n        if len(expense_lines) != 15:\n            print(f\"‚ùå Expected 15 expense entries, found {len(expense_lines)}\")\n            return False\n        \n        print(\"‚úÖ File contains exactly 15 expense entries\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking expense entries: {e}\")\n        return False\n\ndef verify_file_paths_and_counts(test_dir: Path) -> bool:\n    \"\"\"Verify that all required file paths are present with correct counts.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    try:\n        content = budget_file.read_text()\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        expense_lines = lines[:-1]  # All lines except the last\n        \n        # Extract file paths from expense lines\n        file_paths = []\n        for line in expense_lines:\n            file_path = line.split(';')[0]\n            file_paths.append(file_path)\n        \n        # Count occurrences of each path\n        path_counts = Counter(file_paths)\n        \n        # Expected file paths and their counts based on answer.txt\n        expected_paths = {\n            'Archives/tax_documents_2022.csv': 3,\n            'Documents/Personal/tax_info_2023.csv': 3,\n            'Documents/budget.csv': 3,\n            'Downloads/expenses.csv': 3,\n            'Downloads/price_comparisons.csv': 3\n        }\n        \n        # Helper function to check if a path contains the expected path\n        def path_matches_expected(actual_path: str, expected_path: str) -> bool:\n            \"\"\"Check if actual path contains the expected path (allowing for prefixes like './')\"\"\"\n            # Remove common prefixes like './', '../', etc.\n            normalized_actual = actual_path\n            while normalized_actual.startswith('./') or normalized_actual.startswith('../'):\n                normalized_actual = normalized_actual[2:] if normalized_actual.startswith('./') else normalized_actual[3:]\n            \n            # Check if the normalized path contains the expected path\n            return expected_path in normalized_actual or normalized_actual == expected_path\n        \n        # Check if all expected paths are present with correct counts\n        for expected_path, expected_count in expected_paths.items():\n            # Find matching actual paths\n            matching_paths = []\n            for actual_path in path_counts.keys():\n                if path_matches_expected(actual_path, expected_path):\n                    matching_paths.append(actual_path)\n            \n            if not matching_paths:\n                print(f\"‚ùå Missing expected file path: {expected_path}\")\n                return False\n            \n            # Sum up the counts from all matching paths\n            total_count = sum(path_counts[path] for path in matching_paths)\n            if total_count != expected_count:\n                print(f\"‚ùå Path {expected_path} has wrong count: expected {expected_count}, found {total_count}\")\n                print(f\"   Matching paths: {matching_paths}\")\n                return False\n        \n        # Check if there are any completely unexpected paths (not matching any expected path)\n        all_matching_paths = set()\n        for expected_path in expected_paths.keys():\n            for actual_path in path_counts.keys():\n                if path_matches_expected(actual_path, expected_path):\n                    all_matching_paths.add(actual_path)\n        \n        unexpected_paths = set(path_counts.keys()) - all_matching_paths\n        if unexpected_paths:\n            print(f\"‚ùå Unexpected file paths found: {unexpected_paths}\")\n            return False\n        \n        print(\"‚úÖ All expected file paths are present with correct counts\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking file paths: {e}\")\n        return False\n\ndef verify_individual_prices(test_dir: Path) -> bool:\n    \"\"\"Verify that all individual prices match the expected values.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    try:\n        content = budget_file.read_text()\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        expense_lines = lines[:-1]  # All lines except the last\n        \n        # Expected prices based on answer.txt\n        expected_expenses = [\n            ('Archives/tax_documents_2022.csv', 42000.00),\n            ('Archives/tax_documents_2022.csv', 1800.00),\n            ('Archives/tax_documents_2022.csv', 950.00),\n            ('Documents/Personal/tax_info_2023.csv', 45000.00),\n            ('Documents/Personal/tax_info_2023.csv', 2500.00),\n            ('Documents/Personal/tax_info_2023.csv', 1200.00),\n            ('Documents/budget.csv', 250.00),\n            ('Documents/budget.csv', 180.00),\n            ('Documents/budget.csv', 120.00),\n            ('Downloads/expenses.csv', 45.99),\n            ('Downloads/expenses.csv', 99.00),\n            ('Downloads/expenses.csv', 234.50),\n            ('Downloads/price_comparisons.csv', 879.99),\n            ('Downloads/price_comparisons.csv', 289.99),\n            ('Downloads/price_comparisons.csv', 74.99)\n        ]\n        \n        # Helper function to check if a path contains the expected path\n        def path_matches_expected(actual_path: str, expected_path: str) -> bool:\n            \"\"\"Check if actual path contains the expected path (allowing for prefixes like './')\"\"\"\n            # Remove common prefixes like './', '../', etc.\n            normalized_actual = actual_path\n            while normalized_actual.startswith('./') or normalized_actual.startswith('../'):\n                normalized_actual = normalized_actual[2:] if normalized_actual.startswith('./') else normalized_actual[3:]\n            \n            # Check if the normalized path contains the expected path\n            return expected_path in normalized_actual or normalized_actual == expected_path\n        \n        # Parse actual expenses\n        actual_expenses = []\n        for line in expense_lines:\n            parts = line.split(';')\n            file_path = parts[0]\n            price = float(parts[1])\n            actual_expenses.append((file_path, price))\n        \n        # Create a counter for expected expenses to handle duplicates\n        expected_expenses_counter = Counter(expected_expenses)\n        actual_expenses_counter = Counter(actual_expenses)\n        \n        # Check if all expected expenses are present with correct counts\n        for expected_expense, expected_count in expected_expenses_counter.items():\n            expected_path, expected_price = expected_expense\n            \n            # Find matching actual expenses\n            matching_expenses = []\n            for actual_expense, actual_count in actual_expenses_counter.items():\n                actual_path, actual_price = actual_expense\n                if path_matches_expected(actual_path, expected_path) and abs(actual_price - expected_price) < 0.01:\n                    matching_expenses.append(actual_expense)\n            \n            if not matching_expenses:\n                print(f\"‚ùå Missing expected expense: {expected_expense}\")\n                return False\n            \n            # Sum up the counts from all matching expenses\n            total_count = sum(actual_expenses_counter[expense] for expense in matching_expenses)\n            if total_count != expected_count:\n                print(f\"‚ùå Expense {expected_expense} has wrong count: expected {expected_count}, found {total_count}\")\n                print(f\"   Matching expenses: {matching_expenses}\")\n                return False\n        \n        # Check if there are any completely unexpected expenses (not matching any expected expense)\n        all_matching_expenses = set()\n        for expected_expense in expected_expenses_counter.keys():\n            expected_path, expected_price = expected_expense\n            for actual_expense in actual_expenses_counter.keys():\n                actual_path, actual_price = actual_expense\n                if path_matches_expected(actual_path, expected_path) and abs(actual_price - expected_price) < 0.01:\n                    all_matching_expenses.add(actual_expense)\n        \n        unexpected_expenses = set(actual_expenses_counter.keys()) - all_matching_expenses\n        if unexpected_expenses:\n            print(f\"‚ùå Unexpected expenses found: {unexpected_expenses}\")\n            return False\n        \n        print(\"‚úÖ All individual prices match expected values\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking individual prices: {e}\")\n        return False\n\ndef verify_total_price(test_dir: Path) -> bool:\n    \"\"\"Verify that the total price is correct.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    try:\n        content = budget_file.read_text()\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        # Get the total from the last line\n        total_line = lines[-1]\n        try:\n            actual_total = float(total_line)\n        except ValueError:\n            print(f\"‚ùå Last line is not a valid number: {total_line}\")\n            return False\n        \n        # Expected total based on answer.txt\n        expected_total = 95624.46\n        \n        if abs(actual_total - expected_total) > 0.01:  # Allow small floating point differences\n            print(f\"‚ùå Expected total {expected_total}, found {actual_total}\")\n            return False\n        \n        print(\"‚úÖ Total price is correct\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking total price: {e}\")\n        return False\n\ndef verify_total_calculation(test_dir: Path) -> bool:\n    \"\"\"Verify that the total matches the sum of individual expenses.\"\"\"\n    budget_file = test_dir / \"total_budget.txt\"\n    \n    try:\n        content = budget_file.read_text()\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        expense_lines = lines[:-1]  # All lines except the last\n        \n        # Calculate sum of individual expenses\n        calculated_total = 0.0\n        for line in expense_lines:\n            price = float(line.split(';')[1])\n            calculated_total += price\n        \n        # Get the stated total from the last line\n        stated_total = float(lines[-1])\n        \n        # Check if they match (allow small floating point differences)\n        if abs(calculated_total - stated_total) > 0.01:\n            print(f\"‚ùå Total calculation mismatch: calculated {calculated_total:.2f}, stated {stated_total:.2f}\")\n            return False\n        \n        print(\"‚úÖ Total calculation is correct\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying total calculation: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"üîç Verifying Budget Computation Task...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Total Budget File Exists\", verify_total_budget_file_exists),\n        (\"File Format\", verify_file_format),\n        (\"Expense Entries Count\", verify_expense_entries),\n        (\"File Paths and Counts\", verify_file_paths_and_counts),\n        (\"Individual Prices\", verify_individual_prices),\n        (\"Total Price\", verify_total_price),\n        (\"Total Calculation\", verify_total_calculation),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"‚úÖ Budget computation task completed successfully!\")\n        print(\"üéâ All verification steps passed\")\n        print(\"üìä Summary:\")\n        print(\"   - 15 expense entries found\")\n        print(\"   - 5 different file paths covered\")\n        print(\"   - All individual prices correct\")\n        print(\"   - Total price: $95,624.46\")\n        print(\"   - Calculation verified\")\n        sys.exit(0)\n    else:\n        print(\"‚ùå Budget computation task verification: FAIL\")\n        print(\"Please check the errors above and ensure all requirements are met\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}