{
  "task_id": "employee_retention_analysis",
  "task_name": "Employee Retention Analysis",
  "category_id": "employees",
  "category_name": "Employees",
  "description": "Analyze retention patterns identifying turnover factors and high-risk employees to develop targeted retention strategies.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "reporting and analytics",
    "statistical aggregation",
    "audit and compliance"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Analyze employee retention patterns and identify factors contributing to turnover across the organization. The HR leadership team needs comprehensive insights to develop targeted retention strategies and reduce costly employee attrition.\n\n## Your Tasks:\n\n1. **Create the retention analysis table** — build a table called `employee_retention_analysis` in the `employees` schema with these exact columns:\n   * `department_name` (varchar) — the department name\n   * `total_employees_ever` (integer) — total number of employees who have ever worked in this department\n   * `current_employees` (integer) — number of current employees in the department\n   * `former_employees` (integer) — number of employees who left the department\n   * `retention_rate` (decimal) — percentage of employees still with the company (current/total * 100)\n\n2. **Create the high-risk employee identification table** — build a table called `high_risk_employees` in the `employees` schema with:\n   * `employee_id` (bigint) — the employee's ID  \n   * `full_name` (varchar) — concatenated first and last name\n   * `current_department` (varchar) — current department name\n   * `tenure_days` (integer) — days with the company\n   * `current_salary` (integer) — current salary amount\n   * `risk_category` (varchar) — risk level ('high_risk', 'medium_risk', 'low_risk')\n   \n   **Note**: Analyze only current employees (those with active salary records where to_date = '9999-01-01').\n\n3. **Create the turnover trend analysis table** — build a table called `turnover_trend_analysis` in the `employees` schema with:\n   * `departure_year` (integer) — year when employees left (extract from to_date of salary records)\n   * `departures_count` (integer) — number of employees who left that year\n   * `avg_tenure_days` (decimal) — average tenure in days for employees who left that year\n   * `avg_final_salary` (decimal) — average final salary of departed employees that year\n\n4. **Apply risk assessment criteria** for current employees:\n   * **High risk**: Employees in departments with retention rate < 80% AND tenure < 1095 days (3 years)\n   * **Medium risk**: Employees in departments with retention rate < 85% AND tenure < 1825 days (5 years)  \n   * **Low risk**: All other current employees\n\n5. **Analyze departure trends** — examine employees who left between 1985-2002, grouping by departure year.\n\n6. **Handle final salary selection** — when calculating `avg_final_salary`, if an employee has multiple salary records with the same departure date, select the record with the latest start date. If there are still ties, select the record with the highest salary amount.\n\n7. **Focus appropriately** — use current employees for risk analysis, all historical data for retention rates, and former employees for trend analysis.\n\nThe comprehensive analysis will help identify retention patterns, at-risk employees, and historical turnover trends to guide strategic workforce planning.\n",
  "verify": "\"\"\"\nVerification script for PostgreSQL Task 2: Employee Retention Analysis\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.1 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.1:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\")\n    }\n\ndef verify_retention_analysis_results(conn) -> bool:\n    \"\"\"Verify the employee retention analysis results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT department_name, total_employees_ever, current_employees, \n                   former_employees, retention_rate\n            FROM employees.employee_retention_analysis\n            ORDER BY department_name\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            SELECT\n            d.dept_name AS department_name,\n            COUNT(DISTINCT de.employee_id) AS total_employees_ever,\n            COUNT(DISTINCT de.employee_id) FILTER (WHERE de.to_date = DATE '9999-01-01') AS current_employees,\n            (COUNT(DISTINCT de.employee_id)\n            - COUNT(DISTINCT de.employee_id) FILTER (WHERE de.to_date = DATE '9999-01-01')) AS former_employees,\n            (COUNT(DISTINCT de.employee_id) FILTER (WHERE de.to_date = DATE '9999-01-01'))::DECIMAL\n                / NULLIF(COUNT(DISTINCT de.employee_id), 0) * 100 AS retention_rate\n            FROM employees.department d\n            LEFT JOIN employees.department_employee de\n            ON d.id = de.department_id\n            GROUP BY d.id, d.dept_name\n            ORDER BY d.dept_name\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} retention analysis results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Employee retention analysis results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_high_risk_results(conn) -> bool:\n    \"\"\"Verify the high risk employee analysis results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT employee_id, full_name, current_department, tenure_days, \n                   current_salary, risk_category\n            FROM employees.high_risk_employees\n            ORDER BY employee_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query - only current employees\n        cur.execute(\"\"\"\n            WITH current_salary AS (\n            SELECT employee_id, amount AS current_amount\n            FROM (\n                SELECT s.*,\n                    ROW_NUMBER() OVER (PARTITION BY s.employee_id\n                                        ORDER BY s.from_date DESC, s.amount DESC) AS rn\n                FROM employees.salary s\n                WHERE s.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            current_dept AS (\n            SELECT employee_id, department_id\n            FROM (\n                SELECT de.*,\n                    ROW_NUMBER() OVER (PARTITION BY de.employee_id\n                                        ORDER BY de.from_date DESC, de.department_id) AS rn\n                FROM employees.department_employee de\n                WHERE de.to_date = DATE '9999-01-01'\n            ) x\n            WHERE rn = 1\n            ),\n            dept_retention AS (\n            SELECT\n                d.id   AS department_id,\n                d.dept_name,\n                COUNT(DISTINCT de.employee_id) AS total_employees_ever,\n                COUNT(DISTINCT de.employee_id) FILTER (WHERE de.to_date = DATE '9999-01-01') AS current_employees,\n                (COUNT(DISTINCT de.employee_id) FILTER (WHERE de.to_date = DATE '9999-01-01'))::NUMERIC\n                / NULLIF(COUNT(DISTINCT de.employee_id), 0) * 100 AS retention_rate\n            FROM employees.department d\n            LEFT JOIN employees.department_employee de\n                    ON de.department_id = d.id\n            GROUP BY d.id, d.dept_name\n            )\n            SELECT\n            e.id AS employee_id,\n            CONCAT(e.first_name, ' ', e.last_name) AS full_name,\n            d.dept_name AS current_department,\n            (CURRENT_DATE - e.hire_date)::INTEGER AS tenure_days,\n            cs.current_amount::INTEGER AS current_salary,\n            CASE\n                WHEN dr.retention_rate < 80  AND (CURRENT_DATE - e.hire_date) < 1095 THEN 'high_risk'\n                WHEN dr.retention_rate < 85  AND (CURRENT_DATE - e.hire_date) < 1825 THEN 'medium_risk'\n                ELSE 'low_risk'\n            END AS risk_category\n            FROM employees.employee e\n            JOIN current_salary cs ON cs.employee_id = e.id\n            JOIN current_dept   cd ON cd.employee_id = e.id\n            JOIN employees.department d ON d.id = cd.department_id\n            JOIN dept_retention dr ON dr.department_id = d.id\n            ORDER BY e.id;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} high risk analysis results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ High risk employee analysis results are correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_turnover_trend_results(conn) -> bool:\n    \"\"\"Verify the turnover trend analysis results.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT departure_year, departures_count, avg_tenure_days, avg_final_salary\n            FROM employees.turnover_trend_analysis\n            ORDER BY departure_year\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query - simplified version\n        cur.execute(\"\"\"\n            WITH last_non_current_salary AS (\n            SELECT\n                s.employee_id,\n                s.to_date      AS departure_date,\n                s.amount       AS final_salary,\n                ROW_NUMBER() OVER (\n                PARTITION BY s.employee_id\n                ORDER BY s.to_date DESC, s.from_date DESC, s.amount DESC\n                ) AS rn\n            FROM employees.salary s\n            WHERE s.to_date <> DATE '9999-01-01'\n                AND NOT EXISTS (\n                SELECT 1\n                FROM employees.salary s_cur\n                WHERE s_cur.employee_id = s.employee_id\n                    AND s_cur.to_date = DATE '9999-01-01'\n                )\n            ),\n            departed AS (\n            SELECT employee_id, departure_date, final_salary\n            FROM last_non_current_salary\n            WHERE rn = 1\n            ),\n            with_tenure AS (\n            SELECT\n                e.id AS employee_id,\n                d.departure_date,\n                d.final_salary,\n                (d.departure_date - e.hire_date)::INTEGER AS tenure_days\n            FROM employees.employee e\n            JOIN departed d ON d.employee_id = e.id\n            )\n            SELECT\n            EXTRACT(YEAR FROM departure_date)::INTEGER AS departure_year,\n            COUNT(*)::INTEGER                         AS departures_count,\n            AVG(tenure_days)                          AS avg_tenure_days,\n            AVG(final_salary)                         AS avg_final_salary\n            FROM with_tenure\n            WHERE departure_date BETWEEN DATE '1985-01-01' AND DATE '2002-12-31'\n            GROUP BY EXTRACT(YEAR FROM departure_date)\n            ORDER BY departure_year;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"❌ Expected {len(expected_results)} turnover trend results, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"❌ Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"❌ Total mismatches: {mismatches}\")\n            return False\n\n        print(f\"✅ Turnover trend analysis results are correct ({len(actual_results)} records)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"❌ No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify all three analysis results\n        success = (\n            verify_retention_analysis_results(conn) and \n            verify_high_risk_results(conn) and \n            verify_turnover_trend_results(conn)\n        )\n\n        conn.close()\n\n        if success:\n            print(\"\\n🎉 Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n❌ Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"❌ Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"❌ Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}