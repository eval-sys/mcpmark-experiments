{
  "task_id": "solution_tracing",
  "task_name": "Solution Tracing",
  "category_id": "legal_document",
  "category_name": "Legal Document",
  "description": "Trace the evolution of clause resolutions across document versions to identify who first proposed each final accepted solution.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "cross-referencing",
    "pattern analysis"
  ],
  "mcp": [
    "filesystem"
  ],
  "metadata": {},
  "instruction": "# Legal Document Solution Tracing Task\n\n## Overview\n\nThe folder \"legal_files/\" contains all versions (Preferred_Stock_Purchase_Agreement_v0.txt  -- Preferred_Stock_Purchase_Agreement_v10.txt) of the Stock Purchase Agreement for a corporate investment project.\n\nThere are comments in it, come from four people:\n\n- **Bill Harvey** (Company CEO)\n- **Michelle Jackson** (Investor)\n- **David Russel** (Company Counsel)\n- **Tony Taylor** (Investor Counsel)\n\nBetween v1 and v9, these four people make comments on the clauses. The comment format is `[name:content]`, where:\n\n- `name` is the commenter's name\n- `content` is the revision note\n\n**Special Note:** If the name is \"All parties\", it represents a joint comment from all parties, which counts as one comment but does not count toward any individual's personal comment count.\n\n## Task Description\n\n**Your task is to focus on clauses 4.6, 4.16, 6.8, and 6.16 in v5-9** to determine:\n\n1. Who first proposed the idea that eventually led to the final agreed solution\n2. In which version's comment it appeared\n\n**Important:** If the final solution was formed through multiple people's comments, count as the originator the person whose comment first provided the core motivation (or part of the idea) that shaped the final solution. The key is to identify who initially proposed the motivation for the final solution.\n\n## Output Requirements\n\n**File Name:** `tracing.csv` (must be placed in the main directory)\n\n**CSV Structure:**\n\n- **First row** (excluding the top-left cell): `4.6, 4.16, 6.8, 6.16`\n- **First column** (excluding the top-left cell): `version_number, name`\n- **Remaining cells:** Fill in the `version_number` (the version in which the final solution was first proposed, only write a number without any other things) and the `name` (the person who proposed it) for each clause\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Legal Document Solution Tracing Task\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport csv\nimport os\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_output_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the tracing.csv file exists.\"\"\"\n    output_file = test_dir / \"tracing.csv\"\n    \n    if not output_file.exists():\n        print(\"❌ File 'tracing.csv' not found\")\n        return False\n    \n    print(\"✅ Output file 'tracing.csv' found\")\n    return True\n\ndef verify_csv_format(test_dir: Path) -> bool:\n    \"\"\"Verify that the CSV file has the correct format.\"\"\"\n    output_file = test_dir / \"tracing.csv\"\n    \n    try:\n        with open(output_file, 'r', newline='', encoding='utf-8') as csvfile:\n            reader = csv.reader(csvfile)\n            rows = list(reader)\n            \n            if not rows:\n                print(\"❌ CSV file is empty\")\n                return False\n            \n            # Check if there are at least 2 rows (header + data)\n            if len(rows) < 2:\n                print(\"❌ CSV file has insufficient rows\")\n                return False\n            \n            # Check if header row has correct number of columns\n            header = rows[0]\n            if len(header) != 5:  # First column (can be anything) + 4 clauses\n                print(f\"❌ Header row has incorrect number of columns: {len(header)}, expected 5\")\n                return False\n            \n            # Check if data rows have correct number of columns\n            for i, row in enumerate(rows[1:], 1):\n                if len(row) != 5:\n                    print(f\"❌ Data row {i} has incorrect number of columns: {len(row)}, expected 5\")\n                    return False\n            \n            print(\"✅ CSV format is correct\")\n            return True\n            \n    except Exception as e:\n        print(f\"❌ Error reading CSV file: {e}\")\n        return False\n\ndef verify_csv_content(test_dir: Path) -> bool:\n    \"\"\"Verify that the CSV content matches the expected answer exactly.\"\"\"\n    output_file = test_dir / \"tracing.csv\"\n    \n    try:\n        with open(output_file, 'r', newline='', encoding='utf-8') as csvfile:\n            reader = csv.reader(csvfile)\n            rows = list(reader)\n            \n            # Expected data based on answer.csv\n            expected_data = {\n                \"version_number\": [\"5\", \"6\", \"7\", \"8\"],\n                \"name\": [\"Bill Harvey\", \"Michelle Jackson\", \"Michelle Jackson\", \"Tony Taylor\"]\n            }\n            \n            # Expected header columns (excluding first column which can be anything)\n            expected_header_columns = [\"4.6\", \"4.16\", \"6.8\", \"6.16\"]\n            \n            # Verify header has correct number of columns\n            header = rows[0]\n            if len(header) != 5:  # First column + 4 clauses\n                print(f\"❌ Header row has incorrect number of columns: {len(header)}, expected 5\")\n                return False\n            \n            # Check if all expected clause columns are present (allow order to be different)\n            # Allow first column to be anything, so we check columns 1-4\n            header_clauses = header[1:5]\n            missing_clauses = []\n            for expected_clause in expected_header_columns:\n                if expected_clause not in header_clauses:\n                    missing_clauses.append(expected_clause)\n            \n            if missing_clauses:\n                print(f\"❌ Missing expected clause columns: {missing_clauses}\")\n                return False\n            \n            # Check if there are extra clause columns\n            extra_clauses = []\n            for clause in header_clauses:\n                if clause not in expected_header_columns:\n                    extra_clauses.append(clause)\n            \n            if extra_clauses:\n                print(f\"❌ Unexpected extra clause columns: {extra_clauses}\")\n                return False\n            \n            # Create a mapping from expected clause order to actual column indices\n            clause_mapping = {}\n            for i, clause in enumerate(header_clauses):\n                if clause in expected_header_columns:\n                    clause_mapping[clause] = i\n            \n            # Parse the CSV data into a dictionary with correct column mapping\n            csv_data = {}\n            for row in rows[1:]:\n                if len(row) >= 5:\n                    row_type = row[0]  # version_number or name\n                    # Map values according to the expected clause order\n                    values = []\n                    for expected_clause in expected_header_columns:\n                        col_index = clause_mapping[expected_clause] + 1  # +1 because we skip first column\n                        values.append(row[col_index])\n                    csv_data[row_type] = values\n            \n            # Check if all expected row types are present\n            missing_types = []\n            for expected_type in expected_data:\n                if expected_type not in csv_data:\n                    missing_types.append(expected_type)\n            \n            if missing_types:\n                print(f\"❌ Missing expected row types: {missing_types}\")\n                return False\n            \n            # Check if there are extra row types\n            extra_types = []\n            for row_type in csv_data:\n                if row_type not in expected_data:\n                    extra_types.append(row_type)\n            \n            if extra_types:\n                print(f\"❌ Unexpected extra row types: {extra_types}\")\n                return False\n            \n            # Check values for each row type\n            for row_type, expected_values in expected_data.items():\n                actual_values = csv_data[row_type]\n                \n                if actual_values != expected_values:\n                    print(f\"❌ Values mismatch for {row_type}:\")\n                    print(f\"   Expected: {expected_values}\")\n                    print(f\"   Got:      {actual_values}\")\n                    return False\n            \n            print(\"✅ CSV content matches expected answer exactly\")\n            return True\n            \n    except Exception as e:\n        print(f\"❌ Error verifying CSV content: {e}\")\n        return False\n\ndef verify_data_accuracy(test_dir: Path) -> bool:\n    \"\"\"Verify that the data values are accurate.\"\"\"\n    output_file = test_dir / \"tracing.csv\"\n    \n    try:\n        with open(output_file, 'r', newline='', encoding='utf-8') as csvfile:\n            reader = csv.reader(csvfile)\n            rows = list(reader)\n            \n            # Skip header row\n            for i, row in enumerate(rows[1:], 1):\n                if len(row) >= 5:\n                    row_type = row[0]\n                    values = row[1:5]\n                    \n                    # Check version_number row\n                    if row_type == \"version_number\":\n                        for j, value in enumerate(values, 1):\n                            try:\n                                int_val = int(value)\n                                if int_val < 5 or int_val > 8:\n                                    print(f\"❌ Row {i}, column {j}: version number '{value}' is out of expected range [5-8]\")\n                                    return False\n                            except ValueError:\n                                print(f\"❌ Row {i}, column {j}: non-integer version number '{value}'\")\n                                return False\n                    \n                    # Check name row\n                    elif row_type == \"name\":\n                        expected_names = [\"Bill Harvey\", \"Michelle Jackson\", \"Michelle Jackson\", \"Tony Taylor\"]\n                        for j, value in enumerate(values, 1):\n                            if value not in expected_names:\n                                print(f\"❌ Row {i}, column {j}: unexpected name '{value}'\")\n                                return False\n            \n            print(\"✅ All data values are accurate\")\n            return True\n            \n    except Exception as e:\n        print(f\"❌ Error verifying data accuracy: {e}\")\n        return False\n\ndef verify_file_location(test_dir: Path) -> bool:\n    \"\"\"Verify that the file is in the main directory (not in a subdirectory).\"\"\"\n    output_file = test_dir / \"tracing.csv\"\n    \n    if output_file.exists():\n        print(\"✅ File is located in the main directory\")\n        return True\n    else:\n        print(\"❌ File is not in the main directory\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"🔍 Verifying Legal Document Solution Tracing Task...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Output File Exists\", verify_output_file_exists),\n        (\"CSV Format\", verify_csv_format),\n        (\"CSV Content\", verify_csv_content),\n        (\"Data Accuracy\", verify_data_accuracy),\n        (\"File Location\", verify_file_location),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"✅ Legal document solution tracing task completed correctly!\")\n        print(\"🎉 Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"❌ Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()",
  "model_results": {
    "gemini-2-5-pro": 0,
    "deepseek-chat": 0,
    "qwen-3-coder": 0,
    "o3": 0,
    "gpt-5": 0,
    "k2": 0,
    "claude-4-sonnet": 0
  }
}