{
  "task_id": "extraction_table",
  "task_name": "Extraction Table",
  "category_id": "eval_web",
  "category_name": "Eval Web",
  "description": "Extract structured data from complex web tables, parse multi-level headers, handle dynamic content loading, transform data formats, and export comprehensive datasets.",
  "author": "Arvin Xu",
  "created_at": "2025-08-18",
  "difficulty": "L3",
  "tags": [
    "data extraction"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "https://storage.mcpmark.ai/tasks_state/playwright_video/mcpmark-eval-website.mp4",
    "stateOriginalUrl": "https://eval-web.mcpmark.ai/extraction"
  },
  "instruction": "# Web Data Extraction Task\n\nUse Playwright MCP tools to extract all data from the specified website and present it in CSV format.\n\n## Requirements:\n\n1. Navigate to https://eval-web.mcpmark.ai/extraction\n2. Wait for the page to fully load\n3. Extract all data content from the page, including:\n   - Title\n   - Rating\n   - Likes\n   - Views\n   - Replies\n4. Organize the extracted data into CSV format\n5. Ensure data completeness and accuracy\n6. Output ONLY the complete CSV formatted data (no additional text or explanations)\n\n## CSV Data Example:\n\n```csv\nTitle, Rating, Likes, Views, Replies\nSEO Optimization, \"4.6\", 756, 10123, 72\nVue 3 Composition API, \"4.5\", 743, 9876, 67\nAdvanced TypeScript Types Guide, \"4.9\", 924, 15432, 102\nNode.js Performance Optimization, \"4.2\", 567, 8765, 45\nFrontend Engineering Best Practices, \"4.7\", 812, 11234, 78\n```\n\n## Notes:\n\n- Ensure extraction of all visible data rows\n- Maintain data format consistency\n- All numeric data (Rating, Likes, Views, Replies) should NOT have quotes, only text data containing commas should be wrapped in quotes\n- Wait for the page to fully load before starting data extraction\n- Verify the quantity and format of extracted data are correct\n- **IMPORTANT: Final output must contain ONLY CSV data - no explanatory text, descriptions, or other content**\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for checking Playwright web data extraction tasks.\n\nThis script verifies whether the model successfully extracted CSV format data from web pages\nby checking the last assistant message in messages.json.\n\"\"\"\n\nimport sys\nimport json\nimport os\nimport re\nimport csv\nfrom io import StringIO\n\n# Expected CSV header (must match exactly, including spaces)\nEXPECTED_HEADER_LINE = \"Title, Rating, Likes, Views, Replies\"\nEXPECTED_HEADERS = [\"Title\", \"Rating\", \"Likes\", \"Views\", \"Replies\"]\n# Exact number of data rows (must match data.csv exactly)\nEXPECTED_DATA_ROWS = 97\n\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"| MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"| Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n\n    try:\n        with open(messages_path, 'r') as f:\n            messages = json.load(f)\n\n        # Find the last assistant message with status completed\n        for message in reversed(messages):\n            if (message.get('role') == 'assistant' and\n                message.get('status') == 'completed' and\n                message.get('type') == 'message'):\n                content = message.get('content', [])\n                # Extract text from content\n                if isinstance(content, list):\n                    for item in content:\n                        if isinstance(item, dict) and item.get('type') in ['text', 'output_text']:\n                            return item.get('text', '')\n                elif isinstance(content, str):\n                    return content\n\n        print(\"| Warning: No completed assistant message found\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"| Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef extract_csv_from_response(response):\n    \"\"\"\n    Extract CSV data from model response.\n    \"\"\"\n    # Look for CSV code blocks\n    csv_pattern = r'```(?:csv)?\\s*\\n(.*?)\\n```'\n    matches = re.findall(csv_pattern, response, re.DOTALL | re.IGNORECASE)\n\n    if matches:\n        return matches[-1].strip()  # Return the last CSV block\n\n    # If no code block found, try to find CSV data starting with header\n    lines = response.split('\\n')\n    csv_start = -1\n\n    # Stricter header matching: look for lines containing \"Title\" and \"Rating\"\n    for i, line in enumerate(lines):\n        if \"Title\" in line and \"Rating\" in line and \"Likes\" in line:\n            csv_start = i\n            break\n\n    if csv_start >= 0:\n        # Extract from header until empty line or non-CSV format line\n        csv_lines = []\n        for line in lines[csv_start:]:\n            line = line.strip()\n            if not line or not (',' in line):\n                if csv_lines:  # If we already have data, stop at empty line\n                    break\n                continue\n            csv_lines.append(line)\n            if len(csv_lines) > 100:  # Prevent extracting too many rows\n                break\n\n        return '\\n'.join(csv_lines)\n\n    return None\n\n\ndef validate_csv_data(csv_text):\n    \"\"\"\n    Validate CSV data format and content, must match data.csv exactly.\n    \"\"\"\n    if not csv_text:\n        return False, \"CSV data not found\"\n\n    try:\n        lines = csv_text.strip().split('\\n')\n\n        # Check total number of rows (1 header row + data rows)\n        expected_total_rows = EXPECTED_DATA_ROWS + 1\n        if len(lines) != expected_total_rows:\n            return False, f\"| CSV total row count mismatch, expected: {expected_total_rows} rows, actual: {len(lines)} rows\"\n\n        # Check header row format (must match exactly)\n        header_line = lines[0].strip()\n        if header_line != EXPECTED_HEADER_LINE:\n            return False, f\"| Header format mismatch, expected: '{EXPECTED_HEADER_LINE}', actual: '{header_line}'\"\n\n        # Parse CSV to validate structure\n        csv_reader = csv.reader(StringIO(csv_text))\n        rows = list(csv_reader)\n\n        # Check column count for each row\n        expected_columns = len(EXPECTED_HEADERS)\n        for i, row in enumerate(rows):\n            if len(row) != expected_columns:\n                return False, f\"| Row {i+1} column count incorrect, expected: {expected_columns} columns, actual: {len(row)} columns\"\n\n        # Validate data row format\n        valid_rows = 0\n        for i, row in enumerate(rows[1:], 2):  # Skip header, start from row 2\n            # Check if each column has data\n            if not all(cell.strip() for cell in row):\n                return False, f\"| Row {i} contains empty data\"\n\n            # Check numeric column format (Rating, Likes, Views, Replies should not have quotes)\n            for col_idx, col_name in [(1, \"Rating\"), (2, \"Likes\"), (3, \"Views\"), (4, \"Replies\")]:\n                value = row[col_idx].strip()\n\n                # Check for quotes (should not have any)\n                if value.startswith('\"') and value.endswith('\"'):\n                    return False, f\"| Row {i} {col_name} should not have quotes, actual: {value}\"\n\n                # Check numeric format\n                if col_name == \"Rating\":\n                    try:\n                        float(value)\n                    except ValueError:\n                        return False, f\"| Row {i} {col_name} should be a number, actual: {value}\"\n                else:\n                    if not value.isdigit():\n                        return False, f\"| Row {i} {col_name} should be pure digits, actual: {value}\"\n\n            valid_rows += 1\n\n        # Validate number of data rows\n        if valid_rows != EXPECTED_DATA_ROWS:\n            return False, f\"| Valid data row count mismatch, expected: {EXPECTED_DATA_ROWS} rows, actual: {valid_rows} rows\"\n\n        return True, f\"| CSV validation successful: format matches data.csv exactly, {valid_rows} valid data rows\"\n\n    except Exception as e:\n        return False, f\"| CSV format parsing error: {str(e)}\"\n\n\ndef verify():\n    \"\"\"\n    Verify if the model's response contains correct CSV data extraction results.\n    \"\"\"\n    # Get model response\n    model_response = get_model_response()\n\n    if not model_response:\n        print(\"| Model response not found\", file=sys.stderr)\n        return False\n\n    print(f\"|\\n| Model response (first 500 characters): {model_response[:500]}...\", file=sys.stderr)\n\n    # Extract CSV data from response\n    csv_data = extract_csv_from_response(model_response)\n\n    if not csv_data:\n        print(\"|\\n| ✗ CSV data not found in response\", file=sys.stderr)\n        return False\n\n    print(f\"|\\n| Found CSV data (first 300 characters):\\n| {csv_data[:300]}...\", file=sys.stderr)\n\n    # Validate CSV data\n    is_valid, message = validate_csv_data(csv_data)\n\n    if is_valid:\n        print(f\"|\\n| ✓ {message}\", file=sys.stderr)\n        return True\n    else:\n        print(f\"|\\n| ✗ CSV validation failed: {message}\", file=sys.stderr)\n        return False\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = verify()\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}