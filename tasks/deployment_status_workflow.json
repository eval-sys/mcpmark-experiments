{
  "task_id": "deployment_status_workflow",
  "task_name": "Deployment Status Workflow",
  "category_id": "mcpmark-cicd",
  "category_name": "MCPMark CI/CD",
  "description": "Create deployment status workflow with pre-deployment checks, rollback preparation, and comprehensive issue tracking for deployments.",
  "author": "Zijian Wu",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "ci/cd automation",
    "workflow automation"
  ],
  "mcp": [
    "github"
  ],
  "metadata": {},
  "instruction": "I need you to create a Deployment Status workflow for this Node.js project. The project currently has no GitHub Actions workflows, so you'll be building a deployment-focused CI/CD workflow from scratch that responds to push events on the main branch. Here's what needs to be implemented:\n\n## Deployment Status Workflow\n\nCreate `.github/workflows/deployment-status.yml` that triggers on `push` to `main` branch with these sequential jobs:\n\n### 1. **pre-deployment** job (name: `pre-deployment`):\n   - Runs basic quality checks (lint and test)\n   - Creates deployment tracking issue with title: \"Deployment Tracking - [commit-sha]\"\n   - Adds labels: `deployment`, `in-progress`\n   - Captures previous commit SHA and package version information\n   - Posts comment containing \"Pre-deployment checks completed\"\n\n### 2. **rollback-preparation** job (name: `rollback-preparation`):\n   - Depends on: pre-deployment\n   - Creates comprehensive rollback artifacts including:\n     * Executable rollback script with proper error handling\n     * Configuration backups (package.json, package-lock.json, environment templates)\n     * Dependency verification script for compatibility checking\n     * Detailed rollback documentation with step-by-step instructions\n     * Compressed rollback package with SHA256 checksums\n   - Uploads rollback artifacts to GitHub Actions with 30-day retention\n   - Posts comment on deployment issue that MUST contain the following verifiable elements:\n     * Title: \"üîÑ Rollback Plan Ready\"\n     * Previous commit SHA (format: \"Previous Commit: [sha]\")\n     * Current commit SHA (format: \"Current Commit: [sha]\")\n     * Package version (format: \"Package Version: [version]\")\n     * Artifact name (format: \"Artifact: rollback-package-[commit-sha]\")\n     * At least 5 checkmarks (‚úÖ) indicating completed rollback components\n     * Quick rollback command section with bash code block\n     * Script verification status: \"Rollback script created: true\"\n     * Backup verification status: \"Configuration backup: true\"\n     * Artifact checksum (format: \"SHA256: [checksum-value]\")\n\n### 3. **post-deployment** job (name: `post-deployment`):\n   - Depends on: rollback-preparation\n   - Removes `in-progress` label and adds `completed` label\n   - Posts final comment containing \"Deployment Completed Successfully\" with rollback artifact details\n   - Closes the deployment tracking issue\n\n## Implementation Requirements:\n\n**Step 1: Create Feature Branch**\nCreate a new branch called `deployment-status-workflow` from main.\n\n**Step 2: Implement the Workflow**\nCreate `.github/workflows/deployment-status.yml` with proper YAML syntax:\n- Trigger only on push to main branch\n- Sequential job execution: pre-deployment ‚Üí rollback-preparation ‚Üí post-deployment\n- Use github-script actions for issue management\n- Avoid identifier conflicts in github-script actions (don't redeclare 'github')\n- Include proper error handling and script validation\n- Implement comprehensive rollback artifact creation and verification\n- Use proper fetch-depth for accessing commit history\n- Include artifact upload/download capabilities with checksums\n\n**Step 3: Create and Merge Pull Request**\nCreate a comprehensive pull request and merge it to main:\n- Title: \"Implement Deployment Status Workflow\"\n- Detailed description of the workflow and its purpose\n- Merge the pull request to main branch to trigger the deployment workflow",
  "verify": "import sys\nimport os\nimport requests\nimport time\nfrom typing import Dict, List, Optional, Tuple\nfrom dotenv import load_dotenv\n\n\ndef _get_github_api(\n    endpoint: str, headers: Dict[str, str], owner: str, repo: str\n) -> Tuple[bool, Optional[Dict]]:\n    \"\"\"Make a GET request to GitHub API and return (success, response).\"\"\"\n    url = f\"https://api.github.com/repos/{owner}/{repo}/{endpoint}\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return True, response.json()\n        elif response.status_code == 404:\n            return False, None\n        else:\n            print(f\"API error for {endpoint}: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Exception for {endpoint}: {e}\", file=sys.stderr)\n        return False, None\n\n\ndef _search_github_issues(\n    query: str, headers: Dict[str, str]\n) -> Tuple[bool, Optional[List]]:\n    \"\"\"Search GitHub issues using the search API.\"\"\"\n    url = f\"https://api.github.com/search/issues?q={query}&per_page=100\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            data = response.json()\n            return True, data.get(\"items\", [])\n        else:\n            print(f\"Search API error: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Search exception: {e}\", file=sys.stderr)\n        return False, None\n\n\ndef _wait_for_workflow_completion(\n    headers: Dict[str, str], owner: str, repo: str, max_wait: int = 300\n) -> bool:\n    \"\"\"Wait for GitHub Actions workflows to complete processing.\"\"\"\n    print(\"‚è≥ Waiting for deployment status workflows to complete...\")\n\n    start_time = time.time()\n    no_workflow_check_count = 0\n\n    while time.time() - start_time < max_wait:\n        try:\n            # Check workflow runs for deployment-status.yml\n            success, response = _get_github_api(\n                \"actions/workflows/deployment-status.yml/runs?per_page=10\",\n                headers,\n                owner,\n                repo,\n            )\n\n            if success and response:\n                runs = response.get(\"workflow_runs\", [])\n                if len(runs) > 0:\n                    # Check status of recent runs\n                    running_count = 0\n                    completed_count = 0\n                    failed_count = 0\n\n                    for run in runs[:3]:  # Check recent runs\n                        status = run[\"status\"]\n                        conclusion = run.get(\"conclusion\")\n\n                        if status == \"completed\":\n                            completed_count += 1\n                            if conclusion == \"failure\":\n                                failed_count += 1\n                        elif status in [\"in_progress\", \"queued\"]:\n                            running_count += 1\n\n                    print(\n                        f\"   Status: {completed_count} completed, {running_count} running/queued\"\n                    )\n\n                    # Wait until NO workflows are running\n                    if running_count == 0:\n                        if failed_count > 0:\n                            print(\n                                f\"‚ö†Ô∏è Warning: {failed_count} workflow runs failed, but continuing verification...\"\n                            )\n\n                        print(\n                            f\"‚úÖ All workflows completed. Found {completed_count} completed runs.\"\n                        )\n                        # Additional wait to ensure all processing is done\n                        print(\n                            \"‚è≥ Additional wait for deployment processing to complete...\"\n                        )\n                        time.sleep(5)\n                        return True\n                else:\n                    # No workflow runs found\n                    no_workflow_check_count += 1\n                    if no_workflow_check_count == 1:\n                        print(\n                            \"   No workflow runs found yet, waiting 5 seconds and checking once more...\"\n                        )\n                        time.sleep(5)\n                        continue\n                    elif no_workflow_check_count >= 2:\n                        print(\n                            \"‚ö†Ô∏è No workflow runs detected after 2 checks. Workflow may not have been triggered.\"\n                        )\n                        print(\"   Continuing with verification...\")\n                        return False\n\n            print(f\"‚è≥ Still waiting... ({int(time.time() - start_time)}s elapsed)\")\n            time.sleep(5)\n\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Error checking workflow status: {e}\")\n            time.sleep(5)\n\n    print(f\"‚ö†Ô∏è Workflow completion wait timed out after {max_wait}s\")\n    return False\n\n\ndef _verify_workflow_runs(\n    headers: Dict[str, str], owner: str, repo: str\n) -> Tuple[bool, List[str], Optional[Dict]]:\n    \"\"\"Verify that the deployment status workflow runs have the correct jobs.\"\"\"\n    print(\"\\n‚öôÔ∏è Verifying deployment status workflow runs...\")\n    errors = []\n\n    # Get the most recent workflow run\n    success, response = _get_github_api(\n        \"actions/workflows/deployment-status.yml/runs?per_page=5\",\n        headers,\n        owner,\n        repo,\n    )\n\n    if not success or not response:\n        return False, [\"Failed to fetch workflow runs\"], None\n\n    runs = response.get(\"workflow_runs\", [])\n    if not runs:\n        return False, [\"No workflow runs found for deployment-status.yml\"], None\n\n    # Find the most recent successful run\n    latest_successful_run = None\n    for run in runs:\n        if run.get(\"conclusion\") == \"success\":\n            latest_successful_run = run\n            break\n\n    if not latest_successful_run:\n        return False, [\"No successful workflow runs found\"], None\n\n    run_id = latest_successful_run[\"id\"]\n    print(f\"   Found successful workflow run #{run_id}\")\n\n    # Get jobs for this run\n    success, jobs_response = _get_github_api(\n        f\"actions/runs/{run_id}/jobs\", headers, owner, repo\n    )\n\n    if not success:\n        return False, [\"Failed to fetch workflow jobs\"], None\n\n    jobs = jobs_response.get(\"jobs\", [])\n    expected_jobs = [\"pre-deployment\", \"rollback-preparation\", \"post-deployment\"]\n\n    found_jobs = [job[\"name\"] for job in jobs]\n    missing_jobs = [job for job in expected_jobs if job not in found_jobs]\n\n    if missing_jobs:\n        errors.append(f\"Missing jobs: {missing_jobs}. Found: {found_jobs}\")\n    else:\n        print(f\"   ‚úÖ All 3 required jobs found: {found_jobs}\")\n\n    # Verify all jobs succeeded\n    failed_jobs = [job[\"name\"] for job in jobs if job[\"conclusion\"] != \"success\"]\n    if failed_jobs:\n        errors.append(f\"Failed jobs: {failed_jobs}\")\n    else:\n        print(\"   ‚úÖ All jobs completed successfully\")\n\n    # Verify sequential execution (each job should start after the previous one)\n    if len(jobs) >= 3:\n        job_times = {}\n        for job in jobs:\n            if job[\"name\"] in expected_jobs and job[\"started_at\"]:\n                job_times[job[\"name\"]] = job[\"started_at\"]\n\n        if len(job_times) >= 3:\n            # Check that jobs ran in correct sequence\n            import datetime\n\n            times = {\n                name: datetime.datetime.fromisoformat(time.replace(\"Z\", \"+00:00\"))\n                for name, time in job_times.items()\n            }\n\n            # pre-deployment should start first\n            # rollback-preparation should start after pre-deployment\n            # post-deployment should start after rollback-preparation\n            if all(job in times for job in expected_jobs):\n                if (\n                    times[\"rollback-preparation\"] <= times[\"pre-deployment\"]\n                    or times[\"post-deployment\"] <= times[\"rollback-preparation\"]\n                ):\n                    errors.append(\"Jobs did not run in correct sequential order\")\n                else:\n                    print(\"   ‚úÖ Jobs ran in correct sequential order\")\n            else:\n                errors.append(\n                    \"Not enough job timing data to verify sequential execution\"\n                )\n\n    return len(errors) == 0, errors, latest_successful_run\n\n\ndef _verify_deployment_issue(\n    run_data: Dict, headers: Dict[str, str], owner: str, repo: str\n) -> Tuple[bool, List[str]]:\n    \"\"\"Verify that a deployment tracking issue was created and closed properly.\"\"\"\n    print(\"\\nüìã Verifying deployment tracking issue...\")\n    errors = []\n\n    # Extract commit SHA from the workflow run\n    head_sha = run_data.get(\"head_sha\")\n    if not head_sha:\n        return False, [\"Could not determine head SHA from workflow run\"]\n\n    short_sha = head_sha[:7]\n    expected_title = f\"Deployment Tracking - {short_sha}\"\n\n    # Search for the deployment tracking issue\n    success, issues = _search_github_issues(\n        f'repo:{owner}/{repo} \"{expected_title}\" is:issue', headers\n    )\n\n    if not success:\n        return False, [\"Failed to search for deployment tracking issue\"]\n\n    # Find the exact issue\n    deployment_issue = None\n    for issue in issues:\n        if issue.get(\"title\") == expected_title:\n            deployment_issue = issue\n            break\n\n    if not deployment_issue:\n        return False, [f\"Deployment tracking issue '{expected_title}' not found\"]\n\n    issue_number = deployment_issue[\"number\"]\n    print(f\"   Found deployment tracking issue #{issue_number}: {expected_title}\")\n\n    # Check that issue is closed\n    if deployment_issue.get(\"state\") != \"closed\":\n        errors.append(\n            f\"Deployment issue #{issue_number} is not closed (state: {deployment_issue.get('state')})\"\n        )\n    else:\n        print(f\"   ‚úÖ Deployment issue #{issue_number} is closed\")\n\n    # Check required labels\n    expected_labels = [\"deployment\", \"completed\"]\n    actual_labels = [label[\"name\"] for label in deployment_issue.get(\"labels\", [])]\n    missing_labels = [label for label in expected_labels if label not in actual_labels]\n\n    if missing_labels:\n        errors.append(\n            f\"Missing labels on deployment issue: {missing_labels}. Found: {actual_labels}\"\n        )\n    else:\n        print(f\"   ‚úÖ Required labels found: {expected_labels}\")\n\n    # Get issue comments to verify GitHub Actions bot comments\n    success, comments = _get_github_api(\n        f\"issues/{issue_number}/comments\", headers, owner, repo\n    )\n\n    if not success:\n        errors.append(\"Failed to get deployment issue comments\")\n        return len(errors) == 0, errors\n\n    # Filter for GitHub Actions bot comments only\n    bot_comments = [\n        comment\n        for comment in comments\n        if comment.get(\"user\", {}).get(\"login\") == \"github-actions[bot]\"\n    ]\n\n    if not bot_comments:\n        errors.append(\"No comments found from GitHub Actions bot\")\n        return len(errors) == 0, errors\n\n    print(f\"   Found {len(bot_comments)} comment(s) from GitHub Actions bot\")\n\n    # Get all bot comment bodies\n    bot_comment_bodies = [comment.get(\"body\", \"\") for comment in bot_comments]\n    all_bot_comments = \" \".join(bot_comment_bodies)\n\n    # Check for required GitHub Actions bot comment indicators\n    required_comment_indicators = [\n        \"Pre-deployment checks completed\",\n        \"üîÑ Rollback Plan Ready\",\n        \"Deployment Completed Successfully\",\n    ]\n\n    for indicator in required_comment_indicators:\n        if indicator not in all_bot_comments:\n            errors.append(\n                f\"Missing required GitHub Actions bot comment indicator: '{indicator}'\"\n            )\n        else:\n            print(f\"   ‚úÖ Found GitHub Actions bot comment indicator: '{indicator}'\")\n\n    # Find and verify the rollback plan comment from GitHub Actions bot\n    rollback_comment = None\n    for comment in bot_comments:\n        if \"üîÑ Rollback Plan Ready\" in comment.get(\"body\", \"\"):\n            rollback_comment = comment.get(\"body\", \"\")\n            break\n\n    if rollback_comment:\n        print(\"   ‚úÖ Found rollback plan comment from GitHub Actions bot\")\n\n        # Check for required rollback plan elements\n        required_elements = [\n            \"**Previous Commit**:\",\n            \"**Current Commit**:\",\n            \"**Package Version**:\",\n            \"‚úÖ Executable rollback script created\",\n            \"‚úÖ Configuration backups saved\",\n            \"‚úÖ Dependency verification script prepared\",\n            \"‚úÖ Comprehensive rollback documentation generated\",\n            \"‚úÖ Compressed rollback package created\",\n            \"**SHA256**:\",\n            \"**Artifact**:\",\n            \"Quick Rollback Commands\",\n        ]\n\n        for element in required_elements:\n            if element not in rollback_comment:\n                errors.append(f\"Missing element in rollback plan: '{element}'\")\n            else:\n                print(f\"   ‚úÖ Found rollback plan element: '{element}'\")\n\n        # Verify commit SHAs in rollback comment\n        if f\"**Current Commit**: {head_sha}\" in rollback_comment:\n            print(f\"   ‚úÖ Current commit SHA verified: {head_sha}\")\n        else:\n            errors.append(\n                f\"Current commit SHA {head_sha} not found in rollback comment\"\n            )\n\n        # Extract and verify previous commit SHA\n        if \"**Previous Commit**:\" in rollback_comment:\n            import re\n\n            prev_sha_match = re.search(\n                r\"\\*\\*Previous Commit\\*\\*:\\s*([a-f0-9]{40})\", rollback_comment\n            )\n            if prev_sha_match:\n                prev_sha = prev_sha_match.group(1)\n                print(f\"   ‚úÖ Previous commit SHA found: {prev_sha}\")\n\n                # Verify it's a valid 40-character SHA\n                if len(prev_sha) != 40:\n                    errors.append(\n                        f\"Previous commit SHA has invalid length: {len(prev_sha)}\"\n                    )\n            else:\n                errors.append(\n                    \"Previous commit SHA format not found in rollback comment\"\n                )\n        else:\n            errors.append(\"Previous commit SHA not found in rollback comment\")\n\n        # Verify SHA256 checksum is present\n        sha256_match = re.search(r\"\\*\\*SHA256\\*\\*:\\s*([a-f0-9]{64})\", rollback_comment)\n        if sha256_match:\n            sha256_value = sha256_match.group(1)\n            print(f\"   ‚úÖ SHA256 checksum found: {sha256_value[:16]}...\")\n        else:\n            errors.append(\n                \"SHA256 checksum not found or invalid format in rollback comment\"\n            )\n\n    else:\n        errors.append(\"Rollback plan comment not found from GitHub Actions bot\")\n\n    return len(errors) == 0, errors\n\n\ndef verify() -> bool:\n    \"\"\"\n    Verify that the deployment status workflow automation is working correctly.\n    \"\"\"\n    # Load environment variables\n    load_dotenv(\".mcp_env\")\n\n    github_token = os.environ.get(\"MCP_GITHUB_TOKEN\")\n    if not github_token:\n        print(\"Error: MCP_GITHUB_TOKEN environment variable not set\", file=sys.stderr)\n        return False\n\n    # Get GitHub organization\n    github_org = os.environ.get(\"GITHUB_EVAL_ORG\")\n    if not github_org:\n        print(\"Error: GITHUB_EVAL_ORG environment variable not set\", file=sys.stderr)\n        return False\n\n    # Repository configuration\n    owner = github_org\n    repo = \"mcpmark-cicd\"\n\n    headers = {\n        \"Authorization\": f\"token {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    print(\"üîç Starting Deployment Status Workflow Verification\")\n    print(\"=\" * 60)\n\n    # Wait for workflows to complete\n    workflows_completed = _wait_for_workflow_completion(headers, owner, repo)\n    if not workflows_completed:\n        print(\n            \"‚ö†Ô∏è Warning: Workflows may still be running. Continuing with verification...\"\n        )\n\n    # Verify workflow runs and jobs\n    all_passed = True\n\n    # 1. Verify workflow runs have correct jobs\n    runs_ok, runs_errors, run_data = _verify_workflow_runs(headers, owner, repo)\n    if not runs_ok:\n        all_passed = False\n        print(\"‚ùå Workflow Runs Verification Failed:\")\n        for error in runs_errors:\n            print(f\"   - {error}\")\n    else:\n        print(\"‚úÖ Workflow Runs Verification Passed\")\n\n        # 2. Verify deployment issue if workflow runs passed\n        if run_data:\n            issue_ok, issue_errors = _verify_deployment_issue(\n                run_data, headers, owner, repo\n            )\n            if not issue_ok:\n                all_passed = False\n                print(\"‚ùå Deployment Issue Verification Failed:\")\n                for error in issue_errors:\n                    print(f\"   - {error}\")\n            else:\n                print(\"‚úÖ Deployment Issue Verification Passed\")\n\n    print(\"\\n\" + \"=\" * 60)\n    if all_passed:\n        print(\"üéâ All Deployment Status Workflow verifications PASSED!\")\n        print(\"\\nüìã Summary:\")\n        print(\n            \"   ‚úÖ Workflow runs with correct 3 sequential jobs: pre-deployment, rollback-preparation, post-deployment\"\n        )\n        print(\"   ‚úÖ Deployment tracking issue created and closed with proper labels\")\n        print(\"   ‚úÖ Issue contains rollback plan with all required elements\")\n        print(\"   ‚úÖ Previous and current commit SHAs are correctly tracked\")\n        print(\"   ‚úÖ All workflow automation comments are present\")\n        print(\n            \"\\nü§ñ The GitHub Actions deployment status workflow is working correctly!\"\n        )\n    else:\n        print(\"‚ùå Deployment Status Workflow verification FAILED!\")\n        print(\"   Some components did not meet the expected automation requirements.\")\n\n    return all_passed\n\n\nif __name__ == \"__main__\":\n    success = verify()\n    sys.exit(0 if success else 1)\n"
}