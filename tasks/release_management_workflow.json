{
  "task_id": "release_management_workflow",
  "task_name": "Release Management Workflow",
  "category_id": "harmony",
  "category_name": "Harmony",
  "description": "Implement comprehensive release management workflow including bug fixes, version updates, changelog creation, and PR merging.",
  "author": "Zijian Wu",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "release coordination",
    "pr workflows"
  ],
  "mcp": [
    "github"
  ],
  "metadata": {},
  "instruction": "I need help implementing a comprehensive release management workflow for this harmony repository. Here's what I need you to do:\n\n**Step 1: Analyze Current State** \nFirst, analyze the current open pull requests to understand what changes they contain and their impact on the codebase.\n\n**Step 2: Create Release Branch**\nCreate a release preparation branch called 'release-v1.1.0' from the current main branch.\n\n**Step 3: Apply Critical Bug Fixes**\nOn the release branch, apply the MetaSep token fix from PR #25 by creating/updating the file `src/encoding.rs` with the corrected content where FormattingToken::MetaSep maps to \"<|meta_sep|>\" instead of \"<|channel|>\".\n\nAlso create/update `src/registry.rs` to include the missing MetaSep and MetaEnd token registrations:\n```rust\n(FormattingToken::MetaSep, \"<|meta_sep|>\"),\n(FormattingToken::MetaEnd, \"<|meta_end|>\"),\n```\n\n**Step 4: Add Missing Utility File**\nFrom PR #26, create the missing shadcn utils file `demo/harmony-demo/src/lib/utils.ts` with content:\n```typescript\nimport { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n```\n\nAnd create/update `.gitignore` to add:\n```\n# Avoid ignoring shadcn utils\n!demo/harmony-demo/src/lib\n```\n\n**Step 5: Version Update**\nUpdate the version number in `Cargo.toml`: Change the `version` field in the `[package]` section to `version = \"1.1.0\"`.\n\n**Step 6: Create Comprehensive Changelog**\nCreate a `CHANGELOG.md` file in the release branch with the following content:\n```markdown\n# Changelog\n\n## [1.1.0] - 2025-08-07\n\n### Added\n- Added missing shadcn utils.ts file for demo application\n- Enhanced gitignore rules to preserve shadcn utilities\n\n### Fixed\n- Fixed MetaSep token mapping bug (was incorrectly mapped to channel token)\n- Added missing MetaSep and MetaEnd token registrations in registry\n- Improved tokenizer registry functionality for meta formatting tokens\n\n### Changed\n- Updated version to 1.1.0 for new release cycle\n\n### Technical Details\n- MetaSep token now correctly maps to `<|meta_sep|>` instead of `<|channel|>`\n- Registry now properly recognizes MetaSep and MetaEnd formatting tokens\n- Demo application now includes required utility functions for UI components\n```\n\n**Step 7: Create Release Pull Request**\nCreate a pull request from 'release-v1.1.0' to 'main' with title \"Release v1.1.0 - Bug fixes and utility additions\" and a detailed description explaining all the integrated changes.\n\n**Step 8: Merge the Pull Request**\nAfter creating the PR, merge it into the main branch using the \"squash and merge\" method.\n\n**Step 9: Verification**\nEnsure the release branch contains at least 4 distinct commits before merging:\n1. MetaSep token fix commit\n2. Utility file addition commit  \n3. Version update commit\n4. Changelog addition commit",
  "verify": "import sys\nimport os\nimport requests\nfrom typing import Dict, List, Optional, Tuple\nimport base64\nfrom dotenv import load_dotenv\n\n\ndef _get_github_api(\n    endpoint: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> Tuple[bool, Optional[Dict]]:\n    \"\"\"Make a GET request to GitHub API and return (success, response).\"\"\"\n    url = f\"https://api.github.com/repos/{org}/{repo}/{endpoint}\"\n    try:\n        response = requests.get(url, headers=headers)\n        if response.status_code == 200:\n            return True, response.json()\n        elif response.status_code == 404:\n            return False, None\n        else:\n            print(f\"API error for {endpoint}: {response.status_code}\", file=sys.stderr)\n            return False, None\n    except Exception as e:\n        print(f\"Exception for {endpoint}: {e}\", file=sys.stderr)\n        return False, None\n\n\ndef _check_branch_exists(\n    branch_name: str, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> bool:\n    \"\"\"Verify that a branch exists in the repository.\"\"\"\n    success, _ = _get_github_api(f\"branches/{branch_name}\", headers, org, repo)\n    return success\n\n\ndef _check_file_content(\n    branch: str,\n    file_path: str,\n    keywords: List[str],\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"harmony\",\n) -> bool:\n    \"\"\"Verify that a file exists in branch and contains required keywords.\"\"\"\n    success, result = _get_github_api(\n        f\"contents/{file_path}?ref={branch}\", headers, org, repo\n    )\n    if not success or not result:\n        return False\n\n    if keywords and result.get(\"content\"):\n        try:\n            content = base64.b64decode(result.get(\"content\", \"\")).decode(\"utf-8\")\n            return all(keyword in content for keyword in keywords)\n        except Exception as e:\n            print(f\"Content decode error for {file_path}: {e}\", file=sys.stderr)\n            return False\n\n    return True\n\n\ndef _check_specific_file_content(\n    branch: str,\n    file_path: str,\n    expected_content: str,\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"harmony\",\n    min_length: int = 100,\n) -> bool:\n    \"\"\"Verify that a file contains specific exact content and has reasonable size.\"\"\"\n    success, result = _get_github_api(\n        f\"contents/{file_path}?ref={branch}\", headers, org, repo\n    )\n    if not success or not result:\n        return False\n\n    if result.get(\"content\"):\n        try:\n            content = base64.b64decode(result.get(\"content\", \"\")).decode(\"utf-8\")\n            # Check both that expected content exists and file has reasonable content\n            return expected_content in content and len(content) >= min_length\n        except Exception as e:\n            print(f\"Content decode error for {file_path}: {e}\", file=sys.stderr)\n            return False\n\n    return False\n\n\ndef _check_pr_merged(\n    title_substring: str,\n    base_branch: str,\n    headers: Dict[str, str],\n    org: str,\n    repo: str = \"harmony\",\n) -> Tuple[bool, Optional[int]]:\n    \"\"\"Check if a PR with specified title was merged into base branch and return PR number.\"\"\"\n    # Check closed PRs to find merged ones\n    success, prs = _get_github_api(\n        \"pulls?state=closed&per_page=100\", headers, org, repo\n    )\n    if not success or not prs:\n        return False, None\n\n    for pr in prs:\n        title_match = title_substring.lower() in pr.get(\"title\", \"\").lower()\n        base_match = pr.get(\"base\", {}).get(\"ref\") == base_branch\n        is_merged = pr.get(\"merged_at\") is not None\n\n        if title_match and base_match and is_merged:\n            return True, pr.get(\"number\")\n\n    return False, None\n\n\ndef _check_pr_squash_merged(\n    pr_number: int, headers: Dict[str, str], org: str, repo: str = \"harmony\"\n) -> bool:\n    \"\"\"Check if a PR was merged using squash and merge method.\"\"\"\n    # Get the PR details\n    success, pr = _get_github_api(f\"pulls/{pr_number}\", headers, org, repo)\n    if not success or not pr:\n        return False\n\n    if not pr.get(\"merged_at\"):\n        return False\n\n    merge_commit_sha = pr.get(\"merge_commit_sha\")\n    if not merge_commit_sha:\n        return False\n\n    # Get the merge commit details\n    success, commit = _get_github_api(f\"commits/{merge_commit_sha}\", headers, org, repo)\n    if not success or not commit:\n        return False\n\n    # For squash and merge, the commit will have exactly one parent\n    # and the commit message typically includes the PR number\n    parents = commit.get(\"parents\", [])\n    commit_message = commit.get(\"commit\", {}).get(\"message\", \"\")\n\n    # Squash and merge commits have exactly 1 parent (the base branch)\n    # Regular merge commits have 2 parents (base and head branches)\n    if len(parents) == 1 and f\"#{pr_number}\" in commit_message:\n        return True\n\n    return False\n\n\ndef verify() -> bool:\n    \"\"\"\n    Programmatically verify that the release management workflow meets the\n    requirements described in description.md.\n    \"\"\"\n    # Load environment variables from .mcp_env\n    load_dotenv(\".mcp_env\")\n\n    # Get GitHub token and org\n    github_token = os.environ.get(\"MCP_GITHUB_TOKEN\")\n    github_org = os.environ.get(\"GITHUB_EVAL_ORG\")\n\n    if not github_token:\n        print(\"Error: MCP_GITHUB_TOKEN environment variable not set\", file=sys.stderr)\n        return False\n\n    if not github_org:\n        print(\"Error: GITHUB_EVAL_ORG environment variable not set\", file=sys.stderr)\n        return False\n\n    # Configuration constants\n    RELEASE_BRANCH = \"release-v1.1.0\"\n\n    # Expected content checks with minimum file sizes to ensure files aren't just stubs\n    METASEP_FIX = 'FormattingToken::MetaSep => \"<|meta_sep|>\"'\n    REGISTRY_FIX = '(FormattingToken::MetaSep, \"<|meta_sep|>\")'\n    METAEND_FIX = '(FormattingToken::MetaEnd, \"<|meta_end|>\")'\n    UTILS_CONTENT = \"export function cn(...inputs: ClassValue[])\"\n    GITIGNORE_ADDITION = \"!demo/harmony-demo/src/lib\"\n    VERSION_110 = 'version = \"1.1.0\"'\n\n    CHANGELOG_KEYWORDS = [\n        \"## [1.1.0] - 2025-08-07\",\n        \"MetaSep token mapping bug\",\n        \"shadcn utils.ts file\",\n        \"Fixed MetaSep token\",\n        \"Registry now properly recognizes\",\n    ]\n\n    headers = {\n        \"Authorization\": f\"token {github_token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n    }\n\n    # Run verification checks\n    print(\"Verifying GitHub release management workflow completion...\")\n\n    # 1. Check release branch exists\n    print(\"1. Verifying release branch exists...\")\n    if not _check_branch_exists(RELEASE_BRANCH, headers, github_org):\n        print(f\"Error: Branch '{RELEASE_BRANCH}' not found\", file=sys.stderr)\n        return False\n\n    # 2. Check MetaSep fix in encoding.rs (with min content length to ensure file wasn't gutted)\n    print(\"2. Verifying MetaSep token fix in encoding.rs...\")\n    if not _check_specific_file_content(\n        \"main\", \"src/encoding.rs\", METASEP_FIX, headers, github_org, min_length=500\n    ):\n        print(\n            \"Error: MetaSep token fix not found in src/encoding.rs or file is too small\",\n            file=sys.stderr,\n        )\n        return False\n\n    # 3. Check registry updates (both MetaSep and MetaEnd)\n    print(\"3. Verifying MetaSep and MetaEnd registry additions...\")\n    if not _check_specific_file_content(\n        \"main\", \"src/registry.rs\", REGISTRY_FIX, headers, github_org, min_length=500\n    ):\n        print(\n            \"Error: MetaSep registry fix not found in src/registry.rs or file is too small\",\n            file=sys.stderr,\n        )\n        return False\n    if not _check_specific_file_content(\n        \"main\", \"src/registry.rs\", METAEND_FIX, headers, github_org, min_length=500\n    ):\n        print(\n            \"Error: MetaEnd registry fix not found in src/registry.rs\", file=sys.stderr\n        )\n        return False\n\n    # 4. Check utils.ts file exists with correct content\n    print(\"4. Verifying shadcn utils.ts file...\")\n    if not _check_specific_file_content(\n        \"main\",\n        \"demo/harmony-demo/src/lib/utils.ts\",\n        UTILS_CONTENT,\n        headers,\n        github_org,\n        min_length=50,\n    ):\n        print(\"Error: utils.ts file not found or incorrect content\", file=sys.stderr)\n        return False\n\n    # 5. Check .gitignore update\n    print(\"5. Verifying .gitignore update...\")\n    if not _check_specific_file_content(\n        \"main\", \".gitignore\", GITIGNORE_ADDITION, headers, github_org, min_length=100\n    ):\n        print(\"Error: .gitignore update not found\", file=sys.stderr)\n        return False\n\n    # 6. Check version update in Cargo.toml only (pyproject.toml uses dynamic versioning)\n    print(\"6. Verifying version update in Cargo.toml...\")\n    if not _check_specific_file_content(\n        \"main\", \"Cargo.toml\", VERSION_110, headers, github_org, min_length=200\n    ):\n        print(\"Error: Version 1.1.0 not found in Cargo.toml\", file=sys.stderr)\n        return False\n\n    # 7. Check CHANGELOG.md exists with required content\n    print(\"7. Verifying CHANGELOG.md...\")\n    if not _check_file_content(\n        \"main\", \"CHANGELOG.md\", CHANGELOG_KEYWORDS, headers, github_org\n    ):\n        print(\n            \"Error: CHANGELOG.md not found or missing required content\", file=sys.stderr\n        )\n        return False\n\n    # 8. Check release PR was merged and get PR number\n    print(\"8. Verifying release pull request was merged...\")\n    pr_merged, pr_number = _check_pr_merged(\n        \"Release v1.1.0\", \"main\", headers, github_org\n    )\n    if not pr_merged:\n        print(\"Error: Release pull request not found or not merged\", file=sys.stderr)\n        return False\n\n    # 9. Check PR was merged using squash and merge\n    print(\"9. Verifying pull request was merged using 'squash and merge' method...\")\n    if pr_number and not _check_pr_squash_merged(pr_number, headers, github_org):\n        print(\n            f\"Error: Pull request #{pr_number} was not merged using 'squash and merge' method\",\n            file=sys.stderr,\n        )\n        return False\n\n    print(\"\\nâœ“ All verification checks passed!\")\n    print(\"Release management workflow completed successfully.\")\n    return True\n\n\nif __name__ == \"__main__\":\n    success = verify()\n    sys.exit(0 if success else 1)\n",
  "model_results": {
    "gemini-2-5-pro": 0,
    "gpt-4-1-mini": 0,
    "claude-4-sonnet": 0,
    "k2": 0,
    "gemini-2-5-flash": 0,
    "gpt-4-1": 0,
    "o3": 0
  }
}