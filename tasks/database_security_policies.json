{
  "task_id": "database_security_policies",
  "task_name": "Database Security Policies",
  "category_id": "lego",
  "category_name": "Lego",
  "description": "Implement Row-Level Security policies with role-based access control for theme-based data isolation in LEGO database.",
  "author": "Jiawei Wang",
  "created_at": "2025-08-15",
  "difficulty": "L3",
  "tags": [
    "security and access control",
    "stored procedures and functions"
  ],
  "mcp": [
    "postgres"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "Table \"lego_colors\" {\n  \"id\" int4 [pk, not null, increment]\n  \"name\" varchar(255) [not null]\n  \"rgb\" varchar(6) [not null]\n  \"is_trans\" bpchar(1) [not null]\n}\n\nTable \"lego_inventories\" {\n  \"id\" int4 [pk, not null, increment]\n  \"version\" int4 [not null]\n  \"set_num\" varchar(255) [not null]\n}\n\nTable \"lego_inventory_parts\" {\n  \"inventory_id\" int4 [not null]\n  \"part_num\" varchar(255) [not null]\n  \"color_id\" int4 [not null]\n  \"quantity\" int4 [not null]\n  \"is_spare\" bool [not null]\n}\n\nTable \"lego_inventory_sets\" {\n  \"inventory_id\" int4 [not null]\n  \"set_num\" varchar(255) [not null]\n  \"quantity\" int4 [not null]\n}\n\nTable \"lego_part_categories\" {\n  \"id\" int4 [pk, not null, increment]\n  \"name\" varchar(255) [not null]\n}\n\nTable \"lego_parts\" {\n  \"part_num\" varchar(255) [pk, not null]\n  \"name\" text [not null]\n  \"part_cat_id\" int4 [not null]\n}\n\nTable \"lego_sets\" {\n  \"set_num\" varchar(255) [pk, not null]\n  \"name\" varchar(255) [not null]\n  \"year\" int4\n  \"theme_id\" int4\n  \"num_parts\" int4\n}\n\nTable \"lego_themes\" {\n  \"id\" int4 [pk, not null, increment]\n  \"name\" varchar(255) [not null]\n  \"parent_id\" int4\n}\n",
    "stateUrl": null,
    "stateOriginalUrl": "https://github.com/neondatabase-labs/postgres-sample-dbs/blob/main/lego.sql"
  },
  "instruction": "Implement a comprehensive database security system with Row-Level Security (RLS) policies and role-based access control for the LEGO database. The system must ensure theme-based data isolation and prevent unauthorized access across different LEGO themes.\n\n## Your Tasks:\n\n1. **Create database role and permissions** ‚Äî Create a new database role called `theme_analyst` with the following permissions:\n   * `SELECT` permissions on all reference tables: `lego_themes`, `lego_colors`, `lego_parts`, `lego_part_categories`\n   * `SELECT` permissions on main data tables: `lego_sets`, `lego_inventories`, `lego_inventory_parts`\n   * No `INSERT`, `UPDATE`, or `DELETE` permissions on any tables\n\n2. **Enable Row-Level Security** ‚Äî Enable RLS on the following tables:\n   * `lego_sets`\n   * `lego_inventories` \n   * `lego_inventory_parts`\n\n3. **Create RLS policies** ‚Äî Implement theme-based data isolation policies:\n   \n   **Policy 1: `theme_sets_policy` on `lego_sets`**\n   * Allows access only to sets where `theme_id = 18` (Star Wars theme)\n   * Policy should use a function that checks the current user's theme assignment\n   \n   **Policy 2: `theme_inventories_policy` on `lego_inventories`**\n   * Allows access only to inventories for sets with `theme_id = 18`\n   * Must join with `lego_sets` table to check theme_id\n   \n   **Policy 3: `theme_inventory_parts_policy` on `lego_inventory_parts`**\n   * Allows access only to inventory parts for sets with `theme_id = 18`\n   * Must join through `lego_inventories` and `lego_sets` to check theme_id\n\n4. **Create theme assignment function** ‚Äî Create a function `get_user_theme_id()` that:\n   * Returns `18` for the `theme_analyst` role (Star Wars theme)\n   * Can be extended to support other themes in the future\n   * Uses `current_user` to determine the appropriate theme_id\n\n5. **Test the security implementation** ‚Äî Execute verification queries that demonstrate:\n   * Star Wars theme (theme_id=18) returns exactly 2 sets: '65081-1' and 'K8008-1'\n   * Technic theme (theme_id=1) returns 0 sets when accessed by theme_analyst role\n   * Cross-theme data access is properly blocked\n   * Reference tables are accessible for all data\n\n6. **Create comprehensive security audit** ‚Äî Generate a detailed report including:\n   * Complete SQL statements for role creation and policy implementation\n   * Expected query results for each theme\n   * Verification queries to confirm proper data isolation\n   * Documentation of the security model and access patterns\n\n## Security Requirements:\n\n- The `theme_analyst` role must only see data related to Star Wars theme (theme_id=18)\n- All other themes must be completely hidden from this role\n- Reference tables (themes, colors, parts, part_categories) must be fully accessible\n- The system must prevent any cross-theme data leakage\n- RLS policies must be active and enforced for all data access\n\n## Expected Results:\n\nWhen the `theme_analyst` role queries the database:\n- `lego_sets` should return only 2 Star Wars sets\n- `lego_inventories` should return only inventories for those 2 sets  \n- `lego_inventory_parts` should return only parts for those 2 sets\n- All reference tables should return complete data\n- Queries for other themes should return empty results\n",
  "verify": "\"\"\"\nVerification script for PostgreSQL LEGO Task 4: Database Security and RLS Implementation\n(Version 2 - Improved Robustness)\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nimport psycopg2.errors\nfrom typing import Dict\n\ndef get_connection_params() -> Dict[str, any]:\n    \"\"\"Get database connection parameters from environment variables.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\"),\n    }\n\ndef verify_role_creation(conn) -> bool:\n    \"\"\"\n    TASK 1 VERIFICATION: Check if theme_analyst role was created with proper permissions.\n    \"\"\"\n    print(\"\\n-- Verifying Task 1: Role Creation and Permissions --\")\n    with conn.cursor() as cur:\n        # Check if role exists\n        cur.execute(\"SELECT 1 FROM pg_roles WHERE rolname = 'theme_analyst';\")\n        if not cur.fetchone():\n            print(\"‚ùå FAIL: The 'theme_analyst' role was not created.\")\n            return False\n        print(\"‚úÖ OK: Role 'theme_analyst' exists.\")\n\n        # Check SELECT permissions on reference and main tables\n        all_tables = [\n            'lego_themes', 'lego_colors', 'lego_parts', 'lego_part_categories',\n            'lego_sets', 'lego_inventories', 'lego_inventory_parts'\n        ]\n        for table in all_tables:\n            cur.execute(\n                \"\"\"\n                SELECT has_table_privilege('theme_analyst', %s, 'SELECT');\n                \"\"\",\n                (table,)\n            )\n            if not cur.fetchone()[0]:\n                print(f\"‚ùå FAIL: 'theme_analyst' role is missing SELECT permission on '{table}'.\")\n                return False\n        print(\"‚úÖ OK: Role has correct SELECT permissions on all required tables.\")\n\n        # Check that no INSERT/UPDATE/DELETE permissions exist\n        for table in all_tables:\n            cur.execute(\n                \"\"\"\n                SELECT \n                    has_table_privilege('theme_analyst', %s, 'INSERT') OR\n                    has_table_privilege('theme_analyst', %s, 'UPDATE') OR\n                    has_table_privilege('theme_analyst', %s, 'DELETE');\n                \"\"\",\n                (table, table, table)\n            )\n            if cur.fetchone()[0]:\n                print(f\"‚ùå FAIL: 'theme_analyst' role has unauthorized INSERT, UPDATE, or DELETE permission on '{table}'.\")\n                return False\n        print(\"‚úÖ OK: Role does not have modification permissions.\")\n        \n        print(\"‚úÖ PASS: 'theme_analyst' role created with correct permissions.\")\n        return True\n\ndef verify_rls_enabled(conn) -> bool:\n    \"\"\"\n    TASK 2 VERIFICATION: Check if Row-Level Security is enabled on required tables.\n    \"\"\"\n    print(\"\\n-- Verifying Task 2: Row-Level Security Enablement --\")\n    tables_to_check = ['lego_sets', 'lego_inventories', 'lego_inventory_parts']\n    with conn.cursor() as cur:\n        for table in tables_to_check:\n            cur.execute(\n                \"SELECT relrowsecurity FROM pg_class WHERE relname = %s;\", (table,)\n            )\n            rls_enabled = cur.fetchone()\n            if not rls_enabled or not rls_enabled[0]:\n                print(f\"‚ùå FAIL: RLS is not enabled on table '{table}'.\")\n                return False\n            print(f\"‚úÖ OK: RLS is enabled on table '{table}'.\")\n    \n    print(\"‚úÖ PASS: Row-Level Security is enabled on all required tables.\")\n    return True\n\ndef verify_rls_policies(conn) -> bool:\n    \"\"\"\n    TASK 3 VERIFICATION: Check if RLS policies were created on required tables.\n    \"\"\"\n    print(\"\\n-- Verifying Task 3: RLS Policy Creation --\")\n    expected_policies = {\n        'lego_sets': 'theme_sets_policy',\n        'lego_inventories': 'theme_inventories_policy',\n        'lego_inventory_parts': 'theme_inventory_parts_policy'\n    }\n    with conn.cursor() as cur:\n        for table, policy_name in expected_policies.items():\n            cur.execute(\n                \"SELECT 1 FROM pg_policies WHERE tablename = %s AND policyname = %s;\",\n                (table, policy_name)\n            )\n            if not cur.fetchone():\n                print(f\"‚ùå FAIL: RLS policy '{policy_name}' not found on table '{table}'.\")\n                return False\n            print(f\"‚úÖ OK: RLS policy '{policy_name}' found on table '{table}'.\")\n    \n    print(\"‚úÖ PASS: All required RLS policies are created.\")\n    return True\n\ndef verify_theme_function(conn) -> bool:\n    \"\"\"\n    TASK 4 VERIFICATION: Check if get_user_theme_id() function was created and works correctly.\n    \"\"\"\n    print(\"\\n-- Verifying Task 4: Theme Assignment Function --\")\n    with conn.cursor() as cur:\n        cur.execute(\n            \"SELECT 1 FROM pg_proc WHERE proname = 'get_user_theme_id';\"\n        )\n        if not cur.fetchone():\n            print(\"‚ùå FAIL: The 'get_user_theme_id' function was not created.\")\n            return False\n        print(\"‚úÖ OK: Function 'get_user_theme_id' exists.\")\n\n        try:\n            # Test the function's output specifically for the 'theme_analyst' role\n            cur.execute(\"SET ROLE theme_analyst;\")\n            cur.execute(\"SELECT get_user_theme_id();\")\n            theme_id = cur.fetchone()[0]\n            cur.execute(\"RESET ROLE;\") # IMPORTANT: Switch back\n            \n            if theme_id != 18:\n                print(f\"‚ùå FAIL: get_user_theme_id() returned {theme_id} for 'theme_analyst', but expected 18.\")\n                return False\n            \n            print(\"‚úÖ OK: Function returns correct theme_id (18) for 'theme_analyst'.\")\n            print(\"‚úÖ PASS: Theme assignment function is correct.\")\n            return True\n        except Exception as e:\n            conn.rollback() # Rollback any failed transaction state\n            print(f\"‚ùå FAIL: Error testing get_user_theme_id() function: {e}\")\n            return False\n\ndef test_theme_analyst_access(conn) -> bool:\n    \"\"\"\n    TASK 5 VERIFICATION: Test data access by assuming the theme_analyst role.\n    \"\"\"\n    print(\"\\n-- Verifying Task 5: Theme-Based Data Access --\")\n    try:\n        with conn.cursor() as cur:\n            # Assume the role of theme_analyst for this session\n            cur.execute(\"SET ROLE theme_analyst;\")\n\n            # Test 1: Check Star Wars sets access (should return 2 sets)\n            cur.execute(\"SELECT set_num FROM lego_sets ORDER BY set_num;\")\n            star_wars_sets = [row[0] for row in cur.fetchall()]\n            expected_sets = ['65081-1', 'K8008-1']\n            \n            if sorted(star_wars_sets) != sorted(expected_sets):\n                print(f\"‚ùå FAIL: Expected Star Wars sets {expected_sets}, but got {star_wars_sets}.\")\n                cur.execute(\"RESET ROLE;\")\n                return False\n            print(\"‚úÖ PASS: Star Wars sets access is correct (2 sets returned).\")\n\n            # Test 2: Check that Technic sets are not accessible (should return 0)\n            cur.execute(\"SELECT COUNT(*) FROM lego_sets WHERE theme_id = 1;\")\n            technic_count = cur.fetchone()[0]\n            if technic_count != 0:\n                print(f\"‚ùå FAIL: Technic sets should be blocked, but query returned {technic_count} sets.\")\n                cur.execute(\"RESET ROLE;\")\n                return False\n            print(\"‚úÖ PASS: Technic theme is correctly blocked (0 sets returned).\")\n\n            # Test 3: Check reference tables are fully accessible\n            cur.execute(\"SELECT COUNT(*) > 10 FROM lego_themes;\") # Check for a reasonable number\n            if not cur.fetchone()[0]:\n                print(\"‚ùå FAIL: 'lego_themes' table seems inaccessible or empty.\")\n                cur.execute(\"RESET ROLE;\")\n                return False\n            print(\"‚úÖ PASS: Reference tables appear to be accessible.\")\n\n            # Test 4 & 5: Check related tables\n            cur.execute(\"SELECT COUNT(*) FROM lego_inventories;\")\n            if cur.fetchone()[0] == 0:\n                print(\"‚ùå FAIL: No inventories are visible for the allowed sets.\")\n                cur.execute(\"RESET ROLE;\")\n                return False\n            \n            cur.execute(\"SELECT COUNT(*) FROM lego_inventory_parts;\")\n            if cur.fetchone()[0] == 0:\n                print(\"‚ùå FAIL: No inventory parts are visible for the allowed sets.\")\n                cur.execute(\"RESET ROLE;\")\n                return False\n            print(\"‚úÖ PASS: Related tables (inventories, inventory_parts) are correctly filtered.\")\n\n            # IMPORTANT: Always reset the role at the end\n            cur.execute(\"RESET ROLE;\")\n            return True\n    except Exception as e:\n        conn.rollback() # Ensure transaction is clean\n        print(f\"‚ùå FAIL: An error occurred while testing data access as 'theme_analyst': {e}\")\n        # Try to reset role even on failure to clean up session state\n        try:\n            with conn.cursor() as cleanup_cur:\n                cleanup_cur.execute(\"RESET ROLE;\")\n        except:\n            pass\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 60)\n    print(\"LEGO Database Security and RLS Verification Script\")\n    print(\"=\" * 60)\n\n    conn_params = get_connection_params()\n    if not conn_params.get(\"database\"):\n        print(\"‚ùå CRITICAL: POSTGRES_DATABASE environment variable not set.\")\n        sys.exit(1)\n\n    conn = None\n    try:\n        conn = psycopg2.connect(**conn_params)\n        \n        results = [\n            verify_role_creation(conn),\n            verify_rls_enabled(conn),\n            verify_rls_policies(conn),\n            verify_theme_function(conn),\n            test_theme_analyst_access(conn),\n        ]\n\n        if all(results):\n            print(\"\\nüéâ Overall Result: PASS - All security tasks verified successfully!\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Overall Result: FAIL - One or more verification steps failed.\")\n            sys.exit(1)\n\n    except psycopg2.OperationalError as e:\n        print(f\"‚ùå CRITICAL: Could not connect to the database. Check credentials and host. Details: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå CRITICAL: An unexpected error occurred. Details: {e}\")\n        sys.exit(1)\n    finally:\n        if conn:\n            conn.close()\n\nif __name__ == \"__main__\":\n    main()\n"
}