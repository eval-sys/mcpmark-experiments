{
  "task_id": "timeline_extraction",
  "task_name": "Timeline Extraction",
  "category_id": "desktop",
  "category_name": "Desktop",
  "description": "Extract temporal event information from various desktop files and compile a comprehensive chronological timeline of activities and milestones.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "pattern analysis"
  ],
  "mcp": [
    "filesystem"
  ],
  "metadata": {},
  "instruction": "# Desktop 2024 Time Extraction Task\n\nRead all the files under current path, extract every time/plan information that clearly indicates 2024, and integrate them into a list and create a file in main directory called `timeline.txt`. Write the timeline in the file in the following format.\n\n## Task Requirements\n\n### Rules\n\n- If a task only shows month without day, use the 1st day of that month\n- If a task only shows year without month and day, skip it.\n- If a file shows multiple tasks on the same date, count only once per date\n\n### Output Format\n\nEach line format: `file_path:time`\n\n- `file_path`: The file path where this time information appears (**relative to the current path**)\n- `time`: Specific time, if it's a time period, write the start time (YYYY-MM-DD)\n\n### Sorting Requirements\n\nSort by chronological order\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Desktop 2 Timeline Extraction Task\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\nimport re\nfrom datetime import datetime\nfrom typing import List, Tuple, Set\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_timeline_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the timeline.txt file exists in the main directory.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    if not timeline_file.exists():\n        print(\"❌ 'timeline.txt' file not found in main directory\")\n        return False\n    \n    if not timeline_file.is_file():\n        print(\"❌ 'timeline.txt' exists but is not a file\")\n        return False\n    \n    print(\"✅ 'timeline.txt' file exists in main directory\")\n    return True\n\ndef verify_timeline_file_readable(test_dir: Path) -> bool:\n    \"\"\"Verify that the timeline.txt file is readable.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        if not content.strip():\n            print(\"❌ 'timeline.txt' file is empty\")\n            return False\n        \n        print(\"✅ 'timeline.txt' file is readable\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error reading 'timeline.txt' file: {e}\")\n        return False\n\ndef verify_line_count(test_dir: Path) -> bool:\n    \"\"\"Verify that the timeline.txt file has exactly 43 lines.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        if len(lines) != 43:\n            print(f\"❌ Expected 43 lines, but found {len(lines)} lines\")\n            return False\n        \n        print(f\"✅ File contains exactly {len(lines)} lines\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking line count: {e}\")\n        return False\n\ndef verify_line_format(test_dir: Path) -> bool:\n    \"\"\"Verify that each line contains both file path and date time information.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        # More flexible pattern: just check if line contains both path-like content and date-like content\n        date_pattern = r'\\d{4}-\\d{2}-\\d{2}'  # YYYY-MM-DD format\n        \n        invalid_lines = []\n        for i, line in enumerate(lines, 1):\n            # Check if line contains a date\n            if not re.search(date_pattern, line):\n                invalid_lines.append(f\"Line {i}: '{line}' (no valid date found)\")\n                continue\n            \n            # Check if line contains path-like content (contains '/' or '.' and not just a date)\n            # More flexible: look for path anywhere in the line, not just at the beginning\n            path_found = False\n            \n            # Split line into words and look for path-like content\n            words = line.split()\n            for word in words:\n                # Check if word looks like a file path (contains '/' or '.' and not just a date)\n                if ('/' in word or '.' in word) and not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', word.strip()):\n                    path_found = True\n                    break\n            \n            # Also check if line contains path-like content with colon separator\n            if ':' in line:\n                parts = line.split(':')\n                for part in parts:\n                    if ('/' in part or '.' in part) and not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', part.strip()):\n                        path_found = True\n                        break\n            \n            if not path_found:\n                invalid_lines.append(f\"Line {i}: '{line}' (no valid path found)\")\n                continue\n        \n        if invalid_lines:\n            print(f\"❌ Invalid line format found: {invalid_lines[:5]}...\")\n            return False\n        \n        print(\"✅ All lines contain both file path and date time information\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking line format: {e}\")\n        return False\n\ndef verify_date_format(test_dir: Path) -> bool:\n    \"\"\"Verify that all dates are in valid YYYY-MM-DD format.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        invalid_dates = []\n        for i, line in enumerate(lines, 1):\n            try:\n                # Find date pattern in the line (more flexible)\n                date_match = re.search(r'\\d{4}-\\d{2}-\\d{2}', line)\n                if not date_match:\n                    invalid_dates.append(f\"Line {i}: '{line}' (no date found)\")\n                    continue\n                \n                date_part = date_match.group()\n                datetime.strptime(date_part, '%Y-%m-%d')\n            except (IndexError, ValueError) as e:\n                invalid_dates.append(f\"Line {i}: '{line}' (invalid date: {e})\")\n        \n        if invalid_dates:\n            print(f\"❌ Invalid date format found: {invalid_dates[:5]}...\")\n            return False\n        \n        print(\"✅ All dates are in valid YYYY-MM-DD format\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking date format: {e}\")\n        return False\n\ndef verify_chronological_order(test_dir: Path) -> bool:\n    \"\"\"Verify that dates are in chronological order.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        dates = []\n        for line in lines:\n            # Find date pattern in the line (more flexible)\n            date_match = re.search(r'\\d{4}-\\d{2}-\\d{2}', line)\n            if date_match:\n                date_obj = datetime.strptime(date_match.group(), '%Y-%m-%d')\n                dates.append(date_obj)\n        \n        # Check if dates are in ascending order\n        for i in range(1, len(dates)):\n            if dates[i] < dates[i-1]:\n                print(f\"❌ Date order violation: {dates[i-1].strftime('%Y-%m-%d')} comes after {dates[i].strftime('%Y-%m-%d')}\")\n                return False\n        \n        print(\"✅ All dates are in chronological order\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking chronological order: {e}\")\n        return False\n\ndef verify_expected_entries(test_dir: Path) -> bool:\n    \"\"\"Verify that all expected entries from answer.txt are present.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        actual_lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        # Expected entries from answer.txt\n        expected_entries = {\n            \"exp_logs/project_2/analysis_report.md:2024-01-01\",\n            \"learning/2024/learning_progress.csv:2024-01-01\",\n            \"exp_logs/experiment_summary.md:2024-01-05\",\n            \"play/kit&shoes_collection/inventory.py:2024-01-05\",\n            \"exp_logs/experiment_summary.md:2024-01-10\",\n            \"play/kit&shoes_collection/inventory.py:2024-01-10\",\n            \"exp_logs/aug/augmentation_log.txt:2024-01-15\",\n            \"exp_logs/experiment_summary.md:2024-01-15\",\n            \"play/kit&shoes_collection/inventory.py:2024-01-15\",\n            \"learning/2024/learning_progress.csv:2024-02-01\",\n            \"learning/2024/learning_progress.csv:2024-03-01\",\n            \"play/hongkong_tour/travel_itinerary.csv:2024-03-15\",\n            \"travel_plan/travel_calculator.py:2024-03-15\",\n            \"play/hongkong_tour/travel_itinerary.csv:2024-03-16\",\n            \"play/hongkong_tour/travel_itinerary.csv:2024-03-17\",\n            \"play/hongkong_tour/travel_itinerary.csv:2024-03-18\",\n            \"play/hongkong_tour/travel_itinerary.csv:2024-03-19\",\n            \"play/hongkong_tour/travel_itinerary.csv:2024-03-20\",\n            \"travel_plan/travel_bucket_list.md:2024-04-01\",\n            \"learning/2024/learning_progress.csv:2024-04-01\",\n            \"learning/2024/learning_progress.csv:2024-05-01\",\n            \"travel_plan/travel_bucket_list.md:2024-06-01\",\n            \"learning/2024/learning_progress.csv:2024-06-01\",\n            \"learning/2024/learning_progress.csv:2024-07-01\",\n            \"exp_logs/exp_record.md:2024-08-01\",\n            \"exp_logs/results_record.csv:2024-08-01\",\n            \"travel_plan/travel_bucket_list.md:2024-08-01\",\n            \"learning/2024/learning_progress.csv:2024-08-01\",\n            \"exp_logs/results_record.csv:2024-08-02\",\n            \"exp_logs/results_record.csv:2024-08-03\",\n            \"exp_logs/results_record.csv:2024-08-04\",\n            \"exp_logs/exp_record.md:2024-09-01\",\n            \"exp_logs/sep/september_summary.csv:2024-09-01\",\n            \"learning/2024/learning_progress.csv:2024-09-01\",\n            \"exp_logs/sep/september_summary.csv:2024-09-05\",\n            \"exp_logs/sep/september_summary.csv:2024-09-10\",\n            \"exp_logs/sep/september_summary.csv:2024-09-15\",\n            \"exp_logs/sep/september_summary.csv:2024-09-20\",\n            \"exp_logs/sep/september_summary.csv:2024-09-25\",\n            \"exp_logs/sep/september_summary.csv:2024-09-30\",\n            \"learning/2024/learning_progress.csv:2024-10-01\",\n            \"learning/2024/learning_progress.csv:2024-11-01\",\n            \"learning/2024/learning_progress.csv:2024-12-01\"\n        }\n        \n        # Check if each expected entry is found in actual lines (more flexible matching)\n        missing_entries = []\n        for expected in expected_entries:\n            expected_path, expected_date = expected.split(':')\n            found = False\n            \n            for actual_line in actual_lines:\n                # Check if line contains both the expected path and date\n                # More flexible: path can be anywhere in the line, not just at the beginning\n                if expected_path in actual_line and expected_date in actual_line:\n                    found = True\n                    break\n            \n            if not found:\n                missing_entries.append(expected)\n        \n        # Check for extra entries (lines that don't match any expected pattern)\n        extra_entries = []\n        for actual_line in actual_lines:\n            # Extract date from actual line\n            date_match = re.search(r'\\d{4}-\\d{2}-\\d{2}', actual_line)\n            if not date_match:\n                continue\n                \n            actual_date = date_match.group()\n            \n            # Try to extract file path from the line\n            actual_path = None\n            words = actual_line.split()\n            for word in words:\n                if ('/' in word or '.' in word) and not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', word.strip()):\n                    actual_path = word\n                    break\n            \n            if not actual_path:\n                continue\n            \n            # Find if this line matches any expected entry\n            found_expected = False\n            for expected in expected_entries:\n                expected_path, expected_date = expected.split(':')\n                if expected_path in actual_path and expected_date == actual_date:\n                    found_expected = True\n                    break\n            \n            if not found_expected:\n                extra_entries.append(actual_line)\n        \n        if missing_entries:\n            print(f\"❌ Missing {len(missing_entries)} expected entries\")\n            print(f\"   Examples: {missing_entries[:3]}\")\n            return False\n        \n        if extra_entries:\n            print(f\"❌ Found {len(extra_entries)} unexpected entries\")\n            print(f\"   Examples: {extra_entries[:3]}\")\n            return False\n        \n        print(\"✅ All expected entries are present, no extra entries\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking expected entries: {e}\")\n        return False\n\ndef verify_no_duplicates(test_dir: Path) -> bool:\n    \"\"\"Verify that there are no duplicate entries.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        if len(lines) != len(set(lines)):\n            print(\"❌ Duplicate entries found in timeline.txt\")\n            return False\n        \n        print(\"✅ No duplicate entries found\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking for duplicates: {e}\")\n        return False\n\ndef verify_file_paths_exist(test_dir: Path) -> bool:\n    \"\"\"Verify that all file paths mentioned in timeline.txt actually exist.\"\"\"\n    timeline_file = test_dir / \"timeline.txt\"\n    \n    try:\n        content = timeline_file.read_text(encoding='utf-8')\n        lines = [line.strip() for line in content.split('\\n') if line.strip()]\n        \n        missing_files = []\n        for line in lines:\n            # Try to extract file path from the line (more flexible)\n            file_path_found = False\n            \n            # Method 1: Split by colon and check each part\n            if ':' in line:\n                parts = line.split(':')\n                for part in parts:\n                    part = part.strip()\n                    if part and ('/' in part or '.' in part) and not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', part):\n                        # This looks like a file path\n                        full_path = test_dir / part\n                        if not full_path.exists():\n                            missing_files.append(part)\n                        file_path_found = True\n                        break\n            \n            # Method 2: Split into words and look for path-like content\n            if not file_path_found:\n                words = line.split()\n                for word in words:\n                    word = word.strip()\n                    if ('/' in word or '.' in word) and not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', word):\n                        # This looks like a file path\n                        full_path = test_dir / word\n                        if not full_path.exists():\n                            missing_files.append(word)\n                        file_path_found = True\n                        break\n            \n            # Method 3: Look for path pattern in the entire line\n            if not file_path_found:\n                # Use regex to find path-like patterns\n                path_pattern = r'[a-zA-Z0-9_\\-\\.\\/]+/[a-zA-Z0-9_\\-\\.\\/]+'\n                path_matches = re.findall(path_pattern, line)\n                for match in path_matches:\n                    if '.' in match or '/' in match:\n                        full_path = test_dir / match\n                        if not full_path.exists():\n                            missing_files.append(match)\n                        file_path_found = True\n                        break\n        \n        if missing_files:\n            print(f\"❌ {len(missing_files)} referenced files do not exist\")\n            print(f\"   Examples: {missing_files[:3]}\")\n            return False\n        \n        print(\"✅ All referenced file paths exist\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking file paths: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"🔍 Verifying Desktop Timeline Extraction Task...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Timeline File Exists\", verify_timeline_file_exists),\n        (\"File is Readable\", verify_timeline_file_readable),\n        (\"Correct Line Count\", verify_line_count),\n        (\"Line Format\", verify_line_format),\n        (\"Date Format\", verify_date_format),\n        (\"Chronological Order\", verify_chronological_order),\n        (\"Expected Entries\", verify_expected_entries),\n        (\"No Duplicates\", verify_no_duplicates),\n        (\"File Paths Exist\", verify_file_paths_exist),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"✅ Desktop 2 Timeline Extraction completed correctly!\")\n        print(\"🎉 Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"❌ Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}