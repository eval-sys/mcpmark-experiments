{
  "task_id": "marketing_customer_analysis",
  "task_name": "Marketing Customer Analysis",
  "category_id": "shopping_admin",
  "category_name": "Shopping Admin",
  "description": "Analyze customer behavior patterns using admin analytics, segment user demographics, track purchase histories, evaluate campaign effectiveness, and generate comprehensive marketing intelligence reports.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "comparative analysis",
    "content submission"
  ],
  "mcp": [
    "playwright"
  ],
  "metadata": {},
  "instruction": "Perform a comprehensive marketing and customer analysis workflow in the Magento Admin panel to understand search behavior patterns and promotional effectiveness.\n\n**Task Requirements:**\n\n1. First, we need to access the system to begin our comprehensive analysis:\n   if need to login, login with username 'admin' and password 'admin1234'\n\n2. Let's start by analyzing customer search behavior to understand what customers are looking for:\n   Go to Search Terms in Reports and analyze the search data:\n   - Identify the TOP 2 search terms with the highest number of hits (record exact terms and hit counts)\n   - Find a search term that has 0 results but still has search hits (record exact term and hit count)\n   - Count the total number of search terms displayed in the report\n\n3. Next, we'll examine our promotional strategies to understand current marketing efforts:\n   Navigate to Cart Price Rules and identify:\n   - Find ALL rules that contain a coupon code\n   - Record the exact coupon codes and the complete rule names for each\n   - Count how many active rules exist in total\n\n4. Now let's analyze our email marketing reach and subscriber engagement:\n   Go to Newsletter Subscribers:\n   - Apply filter to show only 'Subscribed' status\n   - Count the total number of subscribed users showing after filter\n   - Verify whether these TWO emails appear in the subscribed list:\n     * john.smith.xyz@gmail.com\n     * admin@magento.com\n\n5. To support our analysis, we need to create test customer profiles for different segments:\n   Create TWO new customers with the following details:\n   \n   Customer 1:\n   - First Name: Marketing1\n   - Last Name: Analy\n   - Email: marketdata1.analysis@magento.com\n   - Associate to Website: Main Website\n   - Group: General\n   \n   Customer 2:\n   - First Name: Analytics1\n   - Last Name: Report\n   - Email: analytics1.report@magento.com\n   - Associate to Website: Main Website\n   - Group: Wholesale\n\n6. Finally, let's review overall business performance metrics from the main dashboard:\n   Go to Dashboard and identify:\n   - The names and sales quantities of the products that are both the best-selling and most expensive\n   - The total revenue displayed on the dashboard\n\n7. Compile all your findings and must output them in the following exact format at last:\n\n```\n<answer>\nTop2SearchTerms|term1:hits1,term2:hits2\nZeroResultTerm|term:hits\nTotalSearchTerms|count\nCouponCodes|code1:rulename1,code2:rulename2\nActiveRulesCount|count\nSubscribedCount|count\nEmailVerification|john.smith.xyz@gmail.com:yes/no,admin@magento.com:yes/no\nTopProduct|name:quantity\nTotalRevenue|amount\n</answer>\n```\n\n**Example Output:**\n```\n<answer>\nTop2SearchTerms|term1:XX,term2:XX\nZeroResultTerm|term:XX\nTotalSearchTerms|XX\nCouponCodes|CODE:Rule Name Here\nActiveRulesCount|X\nSubscribedCount|XX\nEmailVerification|john.smith.xyz@gmail.com:yes/no,admin@magento.com:yes/no\nTopProduct|Product Name:XX\nTotalRevenue|$XX.XX\n</answer>\n```\n\n**Success Criteria:**\n- Successfully logged into Magento Admin\n- Navigated to Search Terms Report and identified top 2 terms\n- Found search term with 0 results but has hits\n- Counted total search terms in report\n- Located all Cart Price Rules with coupon codes\n- Extracted exact coupon codes and rule names\n- Counted active rules\n- Filtered Newsletter Subscribers by 'Subscribed' status\n- Counted total subscribed users\n- Verified presence of two specific email addresses\n- Created two new customers successfully\n- Found top bestselling product from dashboard\n- Identified total revenue from dashboard\n- Output answer in exact format with 9 data lines\n- Answer wrapped in <answer> tags",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nimport json\nfrom pathlib import Path\nfrom playwright.async_api import (\n    async_playwright,\n    TimeoutError as PlaywrightTimeoutError,\n)\n\n# 从环境变量读取 base_url（shopping_admin 会注入 http://localhost:7780/admin），默认回退到本地\nBASE_URL = os.getenv(\"WEBARENA_BASE_URL\", \"http://localhost:7780/admin\").rstrip(\"/\")\n\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n\n    try:\n        with open(messages_path, \"r\") as f:\n            messages = json.load(f)\n\n        # Find the last assistant message\n        for message in reversed(messages):\n            if (\n                message.get(\"role\") == \"assistant\"\n                and message.get(\"status\") == \"completed\"\n            ):\n                content = message.get(\"content\", [])\n                for item in content:\n                    if item.get(\"type\") == \"output_text\":\n                        return item.get(\"text\", \"\")\n\n        print(\"Warning: No assistant response found in messages\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef parse_answer_format(text):\n    \"\"\"\n    Parse the new multi-line <answer>xxx</answer> format from the agent's output.\n    Returns a dictionary with the parsed values.\n    \"\"\"\n    if not text:\n        return None\n\n    # Look for <answer>...</answer> pattern\n    match = re.search(r\"<answer>(.*?)</answer>\", text, re.IGNORECASE | re.DOTALL)\n    if not match:\n        return None\n\n    answer_content = match.group(1).strip()\n\n    # Parse each line\n    result = {}\n    lines = answer_content.split(\"\\n\")\n\n    if len(lines) != 9:\n        print(f\"Error: Expected 9 lines in answer, got {len(lines)}\", file=sys.stderr)\n        return None\n\n    for line in lines:\n        if \"|\" in line:\n            key, value = line.split(\"|\", 1)\n            result[key.strip()] = value.strip()\n\n    return result\n\n\ndef load_expected_answer(label_path):\n    \"\"\"\n    Load the expected answer from label.txt file.\n    Returns a dictionary with the expected values.\n    \"\"\"\n    try:\n        with open(label_path, \"r\") as f:\n            lines = f.read().strip().split(\"\\n\")\n\n        expected = {}\n        for line in lines:\n            if \"|\" in line:\n                key, value = line.split(\"|\", 1)\n                expected[key.strip()] = value.strip()\n\n        return expected\n    except Exception as e:\n        print(f\"Error reading label file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef compare_answers(model_answer, expected_answer):\n    \"\"\"\n    Compare the model's answer with the expected answer.\n    Returns True if all key information matches, False otherwise.\n    \"\"\"\n    if not model_answer or not expected_answer:\n        return False\n\n    # Check each expected key\n    mismatches = []\n    for key, expected_value in expected_answer.items():\n        model_value = model_answer.get(key, \"\")\n\n        # Special handling for different types of values\n        if key == \"Top2SearchTerms\":\n            # Check if both search terms are present with correct counts\n            expected_terms = expected_value.split(\",\")\n            model_terms = model_value.split(\",\")\n            if set(expected_terms) != set(model_terms):\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"EmailVerification\":\n            # Check email verification status\n            expected_emails = dict(\n                item.split(\":\") for item in expected_value.split(\",\")\n            )\n            model_emails = dict(\n                item.split(\":\") for item in model_value.split(\",\") if \":\" in item\n            )\n            if expected_emails != model_emails:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"CouponCodes\":\n            # Check if coupon code and rule name are present\n            if \"H20\" not in model_value or \"Luma water bottle\" not in model_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        elif key == \"TopProduct\":\n            # Check if product name and quantity match\n            if expected_value != model_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        else:\n            # Exact match for other fields\n            if model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n    if mismatches:\n        print(\"\\n=== Answer Comparison Mismatches ===\", file=sys.stderr)\n        for mismatch in mismatches:\n            print(f\"✗ {mismatch}\", file=sys.stderr)\n        return False\n\n    print(\"\\n=== Answer Comparison ===\", file=sys.stderr)\n    print(\"✓ All key information matches the expected answer\", file=sys.stderr)\n    return True\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the marketing analysis task has been completed correctly.\n    First checks the model's answer against the expected label,\n    then optionally verifies the actual state in the Magento Admin.\n    \"\"\"\n    # Get the label file path\n    label_path = Path(__file__).parent / \"label.txt\"\n\n    # Load expected answer\n    expected_answer = load_expected_answer(label_path)\n    if not expected_answer:\n        print(\"Error: Could not load expected answer from label.txt\", file=sys.stderr)\n        return False\n\n    # Get model's response from MCP_MESSAGES\n    model_response = get_model_response()\n    if model_response:\n        print(\"Found model response, parsing answer format...\", file=sys.stderr)\n        model_answer = parse_answer_format(model_response)\n\n        if model_answer:\n            print(\"\\n=== Model Answer Parsed ===\", file=sys.stderr)\n            for key, value in model_answer.items():\n                print(f\"{key}: {value}\", file=sys.stderr)\n\n            # Compare answers\n            answer_match = compare_answers(model_answer, expected_answer)\n            if not answer_match:\n                print(\"\\nModel answer does not match expected answer\", file=sys.stderr)\n                return False\n            print(\"\\n✓ Model answer matches expected answer\", file=sys.stderr)\n        else:\n            print(\n                \"Warning: Could not parse answer format from model response\",\n                file=sys.stderr,\n            )\n            print(\"Will proceed with browser verification only\", file=sys.stderr)\n    else:\n        print(\n            \"No model response found, proceeding with browser verification\",\n            file=sys.stderr,\n        )\n\n    # Browser verification - only check customer creation (the critical task requirement)\n    print(\"\\n=== Starting Browser Verification ===\", file=sys.stderr)\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=True)\n        context = await browser.new_context()\n        page = await context.new_page()\n\n        try:\n            # Navigate to Magento Admin\n            print(\"Navigating to Magento Admin...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/\", wait_until=\"networkidle\"\n            )\n\n            # Check if already logged in, if not, login\n            if \"dashboard\" not in page.url.lower():\n                print(\"Logging into Magento Admin...\", file=sys.stderr)\n                await page.fill('input[name=\"login[username]\"]', \"admin\")\n                await page.fill('input[name=\"login[password]\"]', \"admin1234\")\n                await page.click('button:has-text(\"Sign in\")')\n                await page.wait_for_load_state(\"networkidle\")\n\n                if \"dashboard\" not in page.url.lower():\n                    print(\"Error: Login failed\", file=sys.stderr)\n                    return False\n\n            print(\"Successfully logged into Magento Admin\", file=sys.stderr)\n\n            # Verify Customer Creation (the only critical check for task completion)\n            print(\"Verifying Customer Creation...\", file=sys.stderr)\n            await page.goto(\n                f\"{BASE_URL}/customer/index/\",\n                wait_until=\"networkidle\",\n            )\n\n            # Wait for the customer grid to load\n            try:\n                await page.wait_for_selector(\"table\", timeout=15000)\n            except PlaywrightTimeoutError:\n                print(\"Table not found, trying to proceed anyway...\", file=sys.stderr)\n\n            # Define customer requirements\n            customer1_requirements = {\n                \"email\": \"marketdata1.analysis@magento.com\",\n                \"first_name\": \"Marketing1\",\n                \"last_name\": \"Analy\",\n                \"group\": \"General\",\n                \"website\": \"Main Website\"\n            }\n            \n            customer2_requirements = {\n                \"email\": \"analytics1.report@magento.com\", \n                \"first_name\": \"Analytics1\",\n                \"last_name\": \"Report\",\n                \"group\": \"Wholesale\",\n                \"website\": \"Main Website\"\n            }\n\n            async def check_customer_exists(customer_requirements):\n                \"\"\"Check if a customer exists by looking for their details in the customer grid\"\"\"\n                email = customer_requirements[\"email\"]\n                first_name = customer_requirements[\"first_name\"]\n                last_name = customer_requirements[\"last_name\"]\n                group = customer_requirements[\"group\"]\n                \n                # First check if email exists in current page without searching\n                email_found = await page.locator(f\"*:has-text('{email}')\").count() > 0\n                \n                if not email_found:\n                    # Try searching for the customer\n                    try:\n                        search_box = page.locator('input[placeholder*=\"Search by keyword\"]').first\n                        await search_box.clear()\n                        await search_box.fill(email)\n                        await page.keyboard.press(\"Enter\")\n                        await page.wait_for_load_state(\"networkidle\")\n                        await page.wait_for_timeout(2000)\n                        \n                        # Check again after search\n                        email_found = await page.locator(f\"*:has-text('{email}')\").count() > 0\n                    except:\n                        pass\n                \n                if not email_found:\n                    return False, f\"Email {email} not found\"\n                \n                # More precise validation: find the row containing this customer's email\n                # Then check if the required fields are in the same row or nearby context\n                try:\n                    # Find the specific row containing this email\n                    email_cell = page.locator(f\"td:has-text('{email}')\").first\n                    if await email_cell.count() == 0:\n                        # Fall back to broader search\n                        email_cell = page.locator(f\"*:has-text('{email}')\").first\n                    \n                    # Get the parent row or container\n                    row = email_cell.locator(\"xpath=ancestor::tr[1]\")\n                    if await row.count() == 0:\n                        # Fall back to getting nearby content\n                        row = email_cell.locator(\"xpath=..\")\n                    \n                    # Get the text content of the row/container\n                    row_text = await row.text_content() if await row.count() > 0 else \"\"\n                    \n                    # If we can't get a specific row, fall back to broader validation\n                    if not row_text or len(row_text.strip()) < 10:\n                        # Search in nearby cells or elements\n                        nearby_elements = page.locator(f\"*:has-text('{email}')\").locator(\"xpath=../following-sibling::* | xpath=../preceding-sibling::*\")\n                        nearby_count = await nearby_elements.count()\n                        nearby_text = \"\"\n                        for i in range(min(nearby_count, 5)):  # Check up to 5 nearby elements\n                            element_text = await nearby_elements.nth(i).text_content()\n                            if element_text:\n                                nearby_text += element_text + \" \"\n                        row_text = row_text + \" \" + nearby_text\n                    \n                    # Check if required fields are present in the row/context\n                    required_fields = [first_name, last_name, group]\n                    found_fields = [email]  # Email is already confirmed\n                    missing_fields = []\n                    \n                    for field in required_fields:\n                        if field in row_text:\n                            found_fields.append(field)\n                        else:\n                            missing_fields.append(field)\n                    \n                    if missing_fields:\n                        return False, f\"Customer found but missing fields in row context: {', '.join(missing_fields)}. Row text: {row_text[:100]}...\"\n                    \n                    return True, f\"Customer verified with all required fields: {', '.join(found_fields)}\"\n                    \n                except Exception as e:\n                    # Fall back to original simple validation\n                    page_content = await page.content()\n                    required_fields = [first_name, last_name, group, email]\n                    found_fields = []\n                    missing_fields = []\n                    \n                    for field in required_fields:\n                        if field in page_content:\n                            found_fields.append(field)\n                        else:\n                            missing_fields.append(field)\n                    \n                    if missing_fields:\n                        return False, f\"Customer found but missing fields (fallback): {', '.join(missing_fields)}\"\n                    \n                    return True, f\"Customer verified with all required fields (fallback): {', '.join(found_fields)}\"\n\n            # Check both customers\n            customer1_exists, customer1_msg = await check_customer_exists(customer1_requirements)\n            customer2_exists, customer2_msg = await check_customer_exists(customer2_requirements)\n\n            print(\n                f\"Customer 1 (marketdata1.analysis@magento.com): {'Found' if customer1_exists else 'Not Found'} - {customer1_msg}\",\n                file=sys.stderr,\n            )\n            print(\n                f\"Customer 2 (analytics1.report@magento.com): {'Found' if customer2_exists else 'Not Found'} - {customer2_msg}\",\n                file=sys.stderr,\n            )\n\n            if not (customer1_exists and customer2_exists):\n                print(\"Error: Required customers were not found in the system\", file=sys.stderr)\n                return False\n\n            print(\"✓ Both required customers found in the system\", file=sys.stderr)\n            return True\n\n        except PlaywrightTimeoutError as e:\n            print(f\"Error: Timeout occurred - {str(e)}\", file=sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"Error: Unexpected error - {str(e)}\", file=sys.stderr)\n            return False\n        finally:\n            await browser.close()\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()\n"
}