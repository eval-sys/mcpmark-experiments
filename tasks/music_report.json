{
  "task_id": "music_report",
  "task_name": "Music Report",
  "category_id": "desktop",
  "category_name": "Desktop",
  "description": "Search and analyze desktop music files to generate a scored recommendation list using specified computation rules and criteria.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "pattern analysis"
  ],
  "mcp": [
    "filesystem"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "desktop/\n    ├── exp_logs/\n    │       ├── aug/\n    │       │       └── augmentation_log.txt\n    │       ├── project_1/\n    │       │       ├── data.csv\n    │       │       ├── model.py\n    │       │       └── README.md\n    │       ├── project_2/\n    │       │       ├── analysis_report.md\n    │       │       └── data_analysis.py\n    │       ├── sep/\n    │       │       └── september_summary.csv\n    │       ├── exp_record.md\n    │       ├── experiment_summary.md\n    │       └── results_record.csv\n    ├── learning/\n    │       ├── 2024/\n    │       │       └── learning_progress.csv\n    │       ├── 2025/\n    │       │       └── learning_roadmap.md\n    │       ├── activities/\n    │       │       └── study_notes.py\n    │       ├── research/\n    │       │       └── research_topics.md\n    │       ├── schedule/\n    │       │       └── weekly_schedule.csv\n    │       └── learning_goals.md\n    ├── music/\n    │       ├── beni/\n    │       │       └── playlist_manager.py\n    │       ├── jay_chou/\n    │       │       └── favorite_songs.csv\n    │       ├── jj_lin/\n    │       │       └── top_songs.txt\n    │       └── music_collection.md\n    ├── old_homebrew/\n    │       ├── 2023-09-23_22/\n    │       │       ├── opt/\n    │       │       └── Users/\n    │       └── 2023-09-23_23/\n    │               ├── opt/\n    │               └── Users/\n    ├── play/\n    │       ├── game_plan/\n    │       │       └── gaming_schedule.md\n    │       ├── hongkong_tour/\n    │       │       └── travel_itinerary.csv\n    │       ├── kit&shoes_collection/\n    │       │       └── inventory.py\n    │       └── others/\n    │               └── entertainment_planner.md\n    └── travel_plan/\n            ├── travel_bucket_list.md\n            └── travel_calculator.py\n",
    "stateUrl": "https://storage.mcpmark.ai/filesystem/desktop.zip",
    "stateOriginalUrl": null
  },
  "instruction": "Please use FileSystem tools to finish the following task:\n\n### 1. Data Loading\n\n- Read and extract song information from `jay_chou/`\n- Read and extract song information from `jj_lin/`\n\n### 2. Popularity Score Calculation\n\nFor each songs, calculate popularity scores using this formula (keep 3 decimal places):\n\n```\npopularity_score = (rating × 0.4) + (play_count_normalized × 0.4) + (year_factor × 0.2)\n\nWhere:\n- rating: song rating (1-5 scale)\n- play_count_normalized: play_count / 250 (0-1 scale)\n- year_factor: (2025 - release_year) / 25 (recency bonus)\n```\n\n### 3. Generate Analysis Report\n\nCreate a file named `music_analysis_report.txt`\n\n in the `music/` folder with the following exact format:\n\n**Lines 1-20**: Each line contains one song in format `songname:popularity_score`\n\n- Sort songs by popularity_score in descending order (highest first)\n- Use exact song names as they appear in the source files\n- Include all 20 songs from both artists\n\n**Lines 21-25**: Top 5 song names only (one per line)\n\n- List the top 5 songs by popularity_score\n- No scores, just song names\n- One song name per line\n\n**Important**: The file must contain exactly 25 lines with no additional content, headers, or formatting.\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Desktop 2 Music Report Task: Music Collection Analysis\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\n# Hardcoded expected data from answer.json\nEXPECTED_SONGS = [\n    {\"song_name\": \"晴天\", \"popularity_score\": 2.576},\n    {\"song_name\": \"七里香\", \"popularity_score\": 2.488},\n    {\"song_name\": \"江南\", \"popularity_score\": 2.488},\n    {\"song_name\": \"夜曲\", \"popularity_score\": 2.448},\n    {\"song_name\": \"一千年以后\", \"popularity_score\": 2.44},\n    {\"song_name\": \"稻香\", \"popularity_score\": 2.376},\n    {\"song_name\": \"青花瓷\", \"popularity_score\": 2.336},\n    {\"song_name\": \"不为谁而作的歌\", \"popularity_score\": 2.32},\n    {\"song_name\": \"学不会\", \"popularity_score\": 2.304},\n    {\"song_name\": \"小酒窝\", \"popularity_score\": 2.264},\n    {\"song_name\": \"可惜没如果\", \"popularity_score\": 2.248},\n    {\"song_name\": \"修炼爱情\", \"popularity_score\": 2.24},\n    {\"song_name\": \"背对背拥抱\", \"popularity_score\": 2.24},\n    {\"song_name\": \"爱笑的眼睛\", \"popularity_score\": 2.232},\n    {\"song_name\": \"她说\", \"popularity_score\": 2.216},\n    {\"song_name\": \"简单爱\", \"popularity_score\": 1.952},\n    {\"song_name\": \"龙卷风\", \"popularity_score\": 1.936},\n    {\"song_name\": \"双截棍\", \"popularity_score\": 1.92},\n    {\"song_name\": \"可爱女人\", \"popularity_score\": 1.912},\n    {\"song_name\": \"星晴\", \"popularity_score\": 1.896}\n]\n\nEXPECTED_TOP_5 = [\"晴天\", \"七里香\", \"江南\", \"夜曲\", \"一千年以后\"]\n\ndef verify_report_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the music_analysis_report.txt file exists.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    if not report_file.exists():\n        print(\"❌ 'music_analysis_report.txt' file not found in music/ folder\")\n        return False\n    \n    if not report_file.is_file():\n        print(\"❌ 'music_analysis_report.txt' exists but is not a file\")\n        return False\n    \n    print(\"✅ 'music_analysis_report.txt' file exists\")\n    return True\n\ndef verify_file_content_structure(test_dir: Path) -> bool:\n    \"\"\"Verify that the file has exactly 25 lines.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        if len(lines) != 25:\n            print(f\"❌ File should have exactly 25 lines, but has {len(lines)}\")\n            return False\n        \n        print(\"✅ File has exactly 25 lines\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error reading file content: {e}\")\n        return False\n\ndef verify_song_ranking_format(test_dir: Path) -> bool:\n    \"\"\"Verify that lines 1-20 contain songs with scores in correct format.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        # Check lines 1-20 (index 0-19)\n        for i in range(20):\n            line = lines[i].strip()\n            if not line:\n                print(f\"❌ Line {i+1} is empty\")\n                return False\n            \n            # Check format: songname:popularity_score\n            if ':' not in line:\n                print(f\"❌ Line {i+1} missing colon separator: '{line}'\")\n                return False\n            \n            parts = line.split(':', 1)\n            if len(parts) != 2:\n                print(f\"❌ Line {i+1} has incorrect format: '{line}'\")\n                return False\n            \n            song_name, score_str = parts\n            \n            if not song_name.strip():\n                print(f\"❌ Line {i+1} has empty song name: '{line}'\")\n                return False\n            \n            try:\n                score = float(score_str.strip())\n                if score < 0 or score > 5:\n                    print(f\"❌ Line {i+1} has invalid score range: {score}\")\n                    return False\n            except ValueError:\n                print(f\"❌ Line {i+1} has invalid score format: '{score_str}'\")\n                return False\n        \n        print(\"✅ Lines 1-20 have correct song:score format\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking song ranking format: {e}\")\n        return False\n\ndef verify_song_ranking_order_with_tolerance(test_dir: Path) -> bool:\n    \"\"\"Verify that songs are ranked by popularity score in descending order, allowing equal scores to be swapped.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        scores = []\n        for i in range(20):\n            line = lines[i].strip()\n            parts = line.split(':', 1)\n            score = float(parts[1].strip())\n            scores.append(score)\n        \n        # Check if scores are in descending order, allowing equal scores to be adjacent\n        for i in range(1, len(scores)):\n            if scores[i] > scores[i-1]:\n                print(f\"❌ Scores not in descending order: {scores[i-1]} < {scores[i]} at line {i+1}\")\n                return False\n        \n        print(\"✅ Songs are ranked by popularity score in descending order (allowing equal scores)\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking song ranking order: {e}\")\n        return False\n\ndef verify_song_names_match_expected(test_dir: Path) -> bool:\n    \"\"\"Verify that all expected song names are present in the ranking.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        found_songs = []\n        for i in range(20):\n            line = lines[i].strip()\n            song_name = line.split(':', 1)[0].strip()\n            found_songs.append(song_name)\n        \n        # Check if all expected songs are present\n        missing_songs = []\n        for expected_song in EXPECTED_SONGS:\n            if expected_song[\"song_name\"] not in found_songs:\n                missing_songs.append(expected_song[\"song_name\"])\n        \n        if missing_songs:\n            print(f\"❌ Missing expected songs: {missing_songs}\")\n            return False\n        \n        print(\"✅ All expected song names are present\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking song names: {e}\")\n        return False\n\ndef verify_popularity_scores_match_expected(test_dir: Path) -> bool:\n    \"\"\"Verify that popularity scores match the expected values.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        score_errors = []\n        for i in range(20):\n            line = lines[i].strip()\n            parts = line.split(':', 1)\n            song_name = parts[0].strip()\n            actual_score = float(parts[1].strip())\n            \n            # Find expected score for this song\n            expected_score = None\n            for expected_song in EXPECTED_SONGS:\n                if expected_song[\"song_name\"] == song_name:\n                    expected_score = expected_song[\"popularity_score\"]\n                    break\n            \n            if expected_score is not None:\n                # Allow small floating point precision differences\n                if abs(actual_score - expected_score) > 0.001:\n                    score_errors.append(f\"{song_name}: expected {expected_score}, got {actual_score}\")\n        \n        if score_errors:\n            print(f\"❌ Score mismatches: {score_errors}\")\n            return False\n        \n        print(\"✅ All popularity scores match expected values\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking popularity scores: {e}\")\n        return False\n\ndef verify_top_5_songs(test_dir: Path) -> bool:\n    \"\"\"Verify that lines 21-25 contain the top 5 song names, allowing equal scores to be in different order.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        # Check lines 21-25 (index 20-24)\n        found_top_5 = []\n        for i in range(5):\n            line_num = i + 21\n            line = lines[i + 20].strip()  # Index 20-24 for lines 21-25\n            \n            if not line:\n                print(f\"❌ Line {line_num} is empty\")\n                return False\n            \n            if ':' in line:\n                print(f\"❌ Line {line_num} should not contain colon: '{line}'\")\n                return False\n            \n            found_top_5.append(line)\n        \n        # Check if all expected top 5 songs are present (order doesn't matter for equal scores)\n        missing_songs = []\n        for expected_song in EXPECTED_TOP_5:\n            if expected_song not in found_top_5:\n                missing_songs.append(expected_song)\n        \n        if missing_songs:\n            print(f\"❌ Missing expected top 5 songs: {missing_songs}\")\n            return False\n        \n        # Check if the order is valid (allowing equal scores to be swapped)\n        # Since 七里香 and 江南 both have score 2.488, they can be in either order\n        valid_orders = [\n            [\"晴天\", \"七里香\", \"江南\", \"夜曲\", \"一千年以后\"],  # Original order\n            [\"晴天\", \"江南\", \"七里香\", \"夜曲\", \"一千年以后\"],  # Swapped 七里香 and 江南\n        ]\n        \n        order_valid = False\n        for valid_order in valid_orders:\n            if found_top_5 == valid_order:\n                order_valid = True\n                break\n        \n        if not order_valid:\n            print(f\"❌ Top 5 songs order is invalid. Found: {found_top_5}\")\n            print(f\"Expected one of: {valid_orders}\")\n            return False\n        \n        print(\"✅ Lines 21-25 contain correct top 5 song names in valid order\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking top 5 songs: {e}\")\n        return False\n\ndef verify_no_extra_content(test_dir: Path) -> bool:\n    \"\"\"Verify that the file contains no extra content beyond the 25 lines.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        if len(lines) != 25:\n            print(f\"❌ File should have exactly 25 lines, but has {len(lines)}\")\n            return False\n        \n        print(\"✅ File contains exactly 25 lines with no extra content\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Error checking for extra content: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"🔍 Verifying Desktop 2 Music Report Task: Music Collection Analysis...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Report File Exists\", verify_report_file_exists),\n        (\"File Content Structure\", verify_file_content_structure),\n        (\"Song Ranking Format\", verify_song_ranking_format),\n        (\"Song Ranking Order\", verify_song_ranking_order_with_tolerance),\n        (\"Song Names Match Expected\", verify_song_names_match_expected),\n        (\"Popularity Scores Match Expected\", verify_popularity_scores_match_expected),\n        (\"Top 5 Songs\", verify_top_5_songs),\n        (\"No Extra Content\", verify_no_extra_content),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"✅ Music collection analysis completed correctly!\")\n        print(\"🎉 Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"❌ Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}