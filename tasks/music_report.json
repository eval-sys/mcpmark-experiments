{
  "task_id": "music_report",
  "task_name": "Music Report",
  "category_id": "desktop",
  "category_name": "Desktop",
  "description": "Search and analyze desktop music files to generate a scored recommendation list using specified computation rules and criteria.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "pattern analysis"
  ],
  "mcp": [
    "filesystem"
  ],
  "meta_data": {
    "stateType": "text",
    "stateContent": "desktop/\n    ‚îú‚îÄ‚îÄ exp_logs/\n    ‚îÇ       ‚îú‚îÄ‚îÄ aug/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ augmentation_log.txt\n    ‚îÇ       ‚îú‚îÄ‚îÄ project_1/\n    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ data.csv\n    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ model.py\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ README.md\n    ‚îÇ       ‚îú‚îÄ‚îÄ project_2/\n    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ analysis_report.md\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ data_analysis.py\n    ‚îÇ       ‚îú‚îÄ‚îÄ sep/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ september_summary.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ exp_record.md\n    ‚îÇ       ‚îú‚îÄ‚îÄ experiment_summary.md\n    ‚îÇ       ‚îî‚îÄ‚îÄ results_record.csv\n    ‚îú‚îÄ‚îÄ learning/\n    ‚îÇ       ‚îú‚îÄ‚îÄ 2024/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ learning_progress.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ 2025/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ learning_roadmap.md\n    ‚îÇ       ‚îú‚îÄ‚îÄ activities/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ study_notes.py\n    ‚îÇ       ‚îú‚îÄ‚îÄ research/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ research_topics.md\n    ‚îÇ       ‚îú‚îÄ‚îÄ schedule/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ weekly_schedule.csv\n    ‚îÇ       ‚îî‚îÄ‚îÄ learning_goals.md\n    ‚îú‚îÄ‚îÄ music/\n    ‚îÇ       ‚îú‚îÄ‚îÄ beni/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ playlist_manager.py\n    ‚îÇ       ‚îú‚îÄ‚îÄ jay_chou/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ favorite_songs.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ jj_lin/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ top_songs.txt\n    ‚îÇ       ‚îî‚îÄ‚îÄ music_collection.md\n    ‚îú‚îÄ‚îÄ old_homebrew/\n    ‚îÇ       ‚îú‚îÄ‚îÄ 2023-09-23_22/\n    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ opt/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ Users/\n    ‚îÇ       ‚îî‚îÄ‚îÄ 2023-09-23_23/\n    ‚îÇ               ‚îú‚îÄ‚îÄ opt/\n    ‚îÇ               ‚îî‚îÄ‚îÄ Users/\n    ‚îú‚îÄ‚îÄ play/\n    ‚îÇ       ‚îú‚îÄ‚îÄ game_plan/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ gaming_schedule.md\n    ‚îÇ       ‚îú‚îÄ‚îÄ hongkong_tour/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ travel_itinerary.csv\n    ‚îÇ       ‚îú‚îÄ‚îÄ kit&shoes_collection/\n    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ inventory.py\n    ‚îÇ       ‚îî‚îÄ‚îÄ others/\n    ‚îÇ               ‚îî‚îÄ‚îÄ entertainment_planner.md\n    ‚îî‚îÄ‚îÄ travel_plan/\n            ‚îú‚îÄ‚îÄ travel_bucket_list.md\n            ‚îî‚îÄ‚îÄ travel_calculator.py\n",
    "stateUrl": "https://storage.mcpmark.ai/filesystem/desktop.zip",
    "stateOriginalUrl": null
  },
  "instruction": "Please use FileSystem tools to finish the following task:\n\n### 1. Data Loading\n\n- Read and extract song information from `jay_chou/`\n- Read and extract song information from `jj_lin/`\n\n### 2. Popularity Score Calculation\n\nFor each songs, calculate popularity scores using this formula (keep 3 decimal places):\n\n```\npopularity_score = (rating √ó 0.4) + (play_count_normalized √ó 0.4) + (year_factor √ó 0.2)\n\nWhere:\n- rating: song rating (1-5 scale)\n- play_count_normalized: play_count / 250 (0-1 scale)\n- year_factor: (2025 - release_year) / 25 (recency bonus)\n```\n\n### 3. Generate Analysis Report\n\nCreate a file named `music_analysis_report.txt`\n\n in the `music/` folder with the following exact format:\n\n**Lines 1-20**: Each line contains one song in format `songname:popularity_score`\n\n- Sort songs by popularity_score in descending order (highest first)\n- Use exact song names as they appear in the source files\n- Include all 20 songs from both artists\n\n**Lines 21-25**: Top 5 song names only (one per line)\n\n- List the top 5 songs by popularity_score\n- No scores, just song names\n- One song name per line\n\n**Important**: The file must contain exactly 25 lines with no additional content, headers, or formatting.\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for Desktop 2 Music Report Task: Music Collection Analysis\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\n# Hardcoded expected data from answer.json\nEXPECTED_SONGS = [\n    {\"song_name\": \"Êô¥Â§©\", \"popularity_score\": 2.576},\n    {\"song_name\": \"‰∏ÉÈáåÈ¶ô\", \"popularity_score\": 2.488},\n    {\"song_name\": \"Ê±üÂçó\", \"popularity_score\": 2.488},\n    {\"song_name\": \"Â§úÊõ≤\", \"popularity_score\": 2.448},\n    {\"song_name\": \"‰∏ÄÂçÉÂπ¥‰ª•Âêé\", \"popularity_score\": 2.44},\n    {\"song_name\": \"Á®ªÈ¶ô\", \"popularity_score\": 2.376},\n    {\"song_name\": \"ÈùíËä±Áì∑\", \"popularity_score\": 2.336},\n    {\"song_name\": \"‰∏ç‰∏∫Ë∞ÅËÄå‰ΩúÁöÑÊ≠å\", \"popularity_score\": 2.32},\n    {\"song_name\": \"Â≠¶‰∏ç‰ºö\", \"popularity_score\": 2.304},\n    {\"song_name\": \"Â∞èÈÖíÁ™ù\", \"popularity_score\": 2.264},\n    {\"song_name\": \"ÂèØÊÉúÊ≤°Â¶ÇÊûú\", \"popularity_score\": 2.248},\n    {\"song_name\": \"‰øÆÁÇºÁà±ÊÉÖ\", \"popularity_score\": 2.24},\n    {\"song_name\": \"ËÉåÂØπËÉåÊã•Êä±\", \"popularity_score\": 2.24},\n    {\"song_name\": \"Áà±Á¨ëÁöÑÁúºÁùõ\", \"popularity_score\": 2.232},\n    {\"song_name\": \"Â•πËØ¥\", \"popularity_score\": 2.216},\n    {\"song_name\": \"ÁÆÄÂçïÁà±\", \"popularity_score\": 1.952},\n    {\"song_name\": \"ÈæôÂç∑È£é\", \"popularity_score\": 1.936},\n    {\"song_name\": \"ÂèåÊà™Ê£ç\", \"popularity_score\": 1.92},\n    {\"song_name\": \"ÂèØÁà±Â•≥‰∫∫\", \"popularity_score\": 1.912},\n    {\"song_name\": \"ÊòüÊô¥\", \"popularity_score\": 1.896}\n]\n\nEXPECTED_TOP_5 = [\"Êô¥Â§©\", \"‰∏ÉÈáåÈ¶ô\", \"Ê±üÂçó\", \"Â§úÊõ≤\", \"‰∏ÄÂçÉÂπ¥‰ª•Âêé\"]\n\ndef verify_report_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the music_analysis_report.txt file exists.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    if not report_file.exists():\n        print(\"‚ùå 'music_analysis_report.txt' file not found in music/ folder\")\n        return False\n    \n    if not report_file.is_file():\n        print(\"‚ùå 'music_analysis_report.txt' exists but is not a file\")\n        return False\n    \n    print(\"‚úÖ 'music_analysis_report.txt' file exists\")\n    return True\n\ndef verify_file_content_structure(test_dir: Path) -> bool:\n    \"\"\"Verify that the file has exactly 25 lines.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        if len(lines) != 25:\n            print(f\"‚ùå File should have exactly 25 lines, but has {len(lines)}\")\n            return False\n        \n        print(\"‚úÖ File has exactly 25 lines\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error reading file content: {e}\")\n        return False\n\ndef verify_song_ranking_format(test_dir: Path) -> bool:\n    \"\"\"Verify that lines 1-20 contain songs with scores in correct format.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        # Check lines 1-20 (index 0-19)\n        for i in range(20):\n            line = lines[i].strip()\n            if not line:\n                print(f\"‚ùå Line {i+1} is empty\")\n                return False\n            \n            # Check format: songname:popularity_score\n            if ':' not in line:\n                print(f\"‚ùå Line {i+1} missing colon separator: '{line}'\")\n                return False\n            \n            parts = line.split(':', 1)\n            if len(parts) != 2:\n                print(f\"‚ùå Line {i+1} has incorrect format: '{line}'\")\n                return False\n            \n            song_name, score_str = parts\n            \n            if not song_name.strip():\n                print(f\"‚ùå Line {i+1} has empty song name: '{line}'\")\n                return False\n            \n            try:\n                score = float(score_str.strip())\n                if score < 0 or score > 5:\n                    print(f\"‚ùå Line {i+1} has invalid score range: {score}\")\n                    return False\n            except ValueError:\n                print(f\"‚ùå Line {i+1} has invalid score format: '{score_str}'\")\n                return False\n        \n        print(\"‚úÖ Lines 1-20 have correct song:score format\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking song ranking format: {e}\")\n        return False\n\ndef verify_song_ranking_order_with_tolerance(test_dir: Path) -> bool:\n    \"\"\"Verify that songs are ranked by popularity score in descending order, allowing equal scores to be swapped.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        scores = []\n        for i in range(20):\n            line = lines[i].strip()\n            parts = line.split(':', 1)\n            score = float(parts[1].strip())\n            scores.append(score)\n        \n        # Check if scores are in descending order, allowing equal scores to be adjacent\n        for i in range(1, len(scores)):\n            if scores[i] > scores[i-1]:\n                print(f\"‚ùå Scores not in descending order: {scores[i-1]} < {scores[i]} at line {i+1}\")\n                return False\n        \n        print(\"‚úÖ Songs are ranked by popularity score in descending order (allowing equal scores)\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking song ranking order: {e}\")\n        return False\n\ndef verify_song_names_match_expected(test_dir: Path) -> bool:\n    \"\"\"Verify that all expected song names are present in the ranking.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        found_songs = []\n        for i in range(20):\n            line = lines[i].strip()\n            song_name = line.split(':', 1)[0].strip()\n            found_songs.append(song_name)\n        \n        # Check if all expected songs are present\n        missing_songs = []\n        for expected_song in EXPECTED_SONGS:\n            if expected_song[\"song_name\"] not in found_songs:\n                missing_songs.append(expected_song[\"song_name\"])\n        \n        if missing_songs:\n            print(f\"‚ùå Missing expected songs: {missing_songs}\")\n            return False\n        \n        print(\"‚úÖ All expected song names are present\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking song names: {e}\")\n        return False\n\ndef verify_popularity_scores_match_expected(test_dir: Path) -> bool:\n    \"\"\"Verify that popularity scores match the expected values.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        score_errors = []\n        for i in range(20):\n            line = lines[i].strip()\n            parts = line.split(':', 1)\n            song_name = parts[0].strip()\n            actual_score = float(parts[1].strip())\n            \n            # Find expected score for this song\n            expected_score = None\n            for expected_song in EXPECTED_SONGS:\n                if expected_song[\"song_name\"] == song_name:\n                    expected_score = expected_song[\"popularity_score\"]\n                    break\n            \n            if expected_score is not None:\n                # Allow small floating point precision differences\n                if abs(actual_score - expected_score) > 0.001:\n                    score_errors.append(f\"{song_name}: expected {expected_score}, got {actual_score}\")\n        \n        if score_errors:\n            print(f\"‚ùå Score mismatches: {score_errors}\")\n            return False\n        \n        print(\"‚úÖ All popularity scores match expected values\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking popularity scores: {e}\")\n        return False\n\ndef verify_top_5_songs(test_dir: Path) -> bool:\n    \"\"\"Verify that lines 21-25 contain the top 5 song names, allowing equal scores to be in different order.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        # Check lines 21-25 (index 20-24)\n        found_top_5 = []\n        for i in range(5):\n            line_num = i + 21\n            line = lines[i + 20].strip()  # Index 20-24 for lines 21-25\n            \n            if not line:\n                print(f\"‚ùå Line {line_num} is empty\")\n                return False\n            \n            if ':' in line:\n                print(f\"‚ùå Line {line_num} should not contain colon: '{line}'\")\n                return False\n            \n            found_top_5.append(line)\n        \n        # Check if all expected top 5 songs are present (order doesn't matter for equal scores)\n        missing_songs = []\n        for expected_song in EXPECTED_TOP_5:\n            if expected_song not in found_top_5:\n                missing_songs.append(expected_song)\n        \n        if missing_songs:\n            print(f\"‚ùå Missing expected top 5 songs: {missing_songs}\")\n            return False\n        \n        # Check if the order is valid (allowing equal scores to be swapped)\n        # Since ‰∏ÉÈáåÈ¶ô and Ê±üÂçó both have score 2.488, they can be in either order\n        valid_orders = [\n            [\"Êô¥Â§©\", \"‰∏ÉÈáåÈ¶ô\", \"Ê±üÂçó\", \"Â§úÊõ≤\", \"‰∏ÄÂçÉÂπ¥‰ª•Âêé\"],  # Original order\n            [\"Êô¥Â§©\", \"Ê±üÂçó\", \"‰∏ÉÈáåÈ¶ô\", \"Â§úÊõ≤\", \"‰∏ÄÂçÉÂπ¥‰ª•Âêé\"],  # Swapped ‰∏ÉÈáåÈ¶ô and Ê±üÂçó\n        ]\n        \n        order_valid = False\n        for valid_order in valid_orders:\n            if found_top_5 == valid_order:\n                order_valid = True\n                break\n        \n        if not order_valid:\n            print(f\"‚ùå Top 5 songs order is invalid. Found: {found_top_5}\")\n            print(f\"Expected one of: {valid_orders}\")\n            return False\n        \n        print(\"‚úÖ Lines 21-25 contain correct top 5 song names in valid order\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking top 5 songs: {e}\")\n        return False\n\ndef verify_no_extra_content(test_dir: Path) -> bool:\n    \"\"\"Verify that the file contains no extra content beyond the 25 lines.\"\"\"\n    report_file = test_dir / \"music\" / \"music_analysis_report.txt\"\n    \n    try:\n        content = report_file.read_text(encoding='utf-8')\n        lines = content.strip().split('\\n')\n        \n        if len(lines) != 25:\n            print(f\"‚ùå File should have exactly 25 lines, but has {len(lines)}\")\n            return False\n        \n        print(\"‚úÖ File contains exactly 25 lines with no extra content\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error checking for extra content: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"üîç Verifying Desktop 2 Music Report Task: Music Collection Analysis...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Report File Exists\", verify_report_file_exists),\n        (\"File Content Structure\", verify_file_content_structure),\n        (\"Song Ranking Format\", verify_song_ranking_format),\n        (\"Song Ranking Order\", verify_song_ranking_order_with_tolerance),\n        (\"Song Names Match Expected\", verify_song_names_match_expected),\n        (\"Popularity Scores Match Expected\", verify_popularity_scores_match_expected),\n        (\"Top 5 Songs\", verify_top_5_songs),\n        (\"No Extra Content\", verify_no_extra_content),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"‚úÖ Music collection analysis completed correctly!\")\n        print(\"üéâ Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"‚ùå Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}