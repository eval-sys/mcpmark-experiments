{
  "task_id": "user_permission_audit",
  "task_name": "User Permission Audit",
  "category_id": "security",
  "category_name": "Security",
  "description": "Conduct comprehensive security audit identifying users with insufficient or dangling permissions in business database environment.",
  "author": "Fanshi Zhang",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "security and access control",
    "audit and compliance"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "Conduct a comprehensive security audit to identify PostgreSQL users with insufficient or dangling permissions in a business database environment.\n\n## Your Mission:\n\nYou've been hired as a security consultant to audit the PostgreSQL database permissions for a growing e-commerce company. The company has experienced rapid growth and multiple teams have been granted database access over time. However, there's concern that some users may have incomplete permissions for their roles, while others may be \"dangling\" users with no meaningful access.\n\n## Security Audit Requirements:\n\n1. **Discover the database structure**: Identify all tables and their purposes\n2. **Catalog all database users**: Find all non-system users in the database  \n3. **Analyze current permissions**: Map each user's table-level permissions\n4. **Identify security issues**:\n   - Users with no table permissions (dangling users)\n   - Users with incomplete permissions for their apparent roles\n   - Missing permissions that could affect business operations\n\n## Expected Deliverables:\n\nYour audit must produce findings in a structured format that can be verified. Create a table called `security_audit_findings` with the following structure:\n\n```sql\nCREATE TABLE security_audit_findings (\n    finding_id SERIAL PRIMARY KEY,\n    finding_type VARCHAR(50) NOT NULL, -- 'DANGLING_USER', 'MISSING_PERMISSION', 'ROLE_MISMATCH'\n    username VARCHAR(50) NOT NULL,\n    table_name VARCHAR(50), -- NULL for dangling users\n    missing_permission VARCHAR(20), -- 'SELECT', 'INSERT', 'UPDATE', 'DELETE', NULL for dangling\n    business_justification TEXT NOT NULL,\n    recommended_action TEXT NOT NULL,\n    severity VARCHAR(10) NOT NULL -- 'HIGH', 'MEDIUM', 'LOW'\n);\n```\n\n## Success Criteria:\n\nYour audit should populate the `security_audit_findings` table with:\n- All users that have zero table permissions\n- All users missing permissions required for their inferred business role\n- Specific actionable recommendations for each finding\n\nAnalyze usernames and infer their intended business roles, then determine what permissions they should have based on the available tables and typical business needs.\n\nThe verification process will check that your findings correctly identify the actual permission gaps in the system.",
  "verify": "#!/usr/bin/env python3\n\nimport os\nimport psycopg2\nimport sys\n\ndef verify_security_audit():\n    \"\"\"\n    Verify that the security audit correctly identified all permission issues.\n    \"\"\"\n\n    # Database connection parameters from environment\n    db_params = {\n        'host': os.getenv('POSTGRES_HOST', 'localhost'),\n        'port': os.getenv('POSTGRES_PORT', '5432'),\n        'user': os.getenv('POSTGRES_USER', 'postgres'),\n        'password': os.getenv('POSTGRES_PASSWORD', 'password'),\n        'database': os.getenv('POSTGRES_DATABASE', 'postgres')\n    }\n\n    try:\n        conn = psycopg2.connect(**db_params)\n        cur = conn.cursor()\n\n        print(\"Verifying security audit findings...\")\n\n        # Check if security_audit_findings table exists\n        cur.execute(\"\"\"\n            SELECT EXISTS (\n                SELECT FROM information_schema.tables\n                WHERE table_name = 'security_audit_findings'\n            );\n        \"\"\")\n\n        if not cur.fetchone()[0]:\n            print(\"❌ FAIL: security_audit_findings table not found\")\n            return False\n\n        # Get all findings\n        cur.execute(\"SELECT * FROM security_audit_findings ORDER BY finding_id;\")\n        findings = cur.fetchall()\n\n        if not findings:\n            print(\"❌ FAIL: No findings in security_audit_findings table\")\n            return False\n\n        print(f\"Found {len(findings)} audit findings\")\n\n        # Expected issues based on the setup:\n        expected_issues = {\n            # Dangling users (should have 0 permissions)\n            'dangling_users': {'temp_contractor', 'old_employee', 'test_account'},\n\n            # Users missing critical permissions for their roles\n            'permission_gaps': {\n                ('analytics_user', 'user_profiles', 'SELECT'),  # Revoked access\n                ('marketing_user', 'product_catalog', 'SELECT'),  # Revoked access\n                ('finance_user', 'user_profiles', 'SELECT'),  # Revoked access\n                ('developer_user', 'product_catalog', 'SELECT'),  # Revoked access\n                ('backup_user', 'order_management', 'SELECT'),  # Revoked access\n            }\n        }\n\n        found_dangling = set()\n        found_permission_gaps = set()\n\n        # Analyze findings\n        for finding in findings:\n            finding_type = finding[1]\n            username = finding[2]\n            table_name = finding[3]\n            missing_permission = finding[4]\n\n            if finding_type == 'DANGLING_USER':\n                found_dangling.add(username)\n            elif finding_type in ['MISSING_PERMISSION', 'ROLE_MISMATCH']:\n                if table_name and missing_permission:\n                    found_permission_gaps.add((username, table_name, missing_permission))\n\n        # Verify dangling users\n        missing_dangling = expected_issues['dangling_users'] - found_dangling\n        extra_dangling = found_dangling - expected_issues['dangling_users']\n\n        print(f\"\\n=== Dangling Users ===\")\n        print(f\"Expected: {expected_issues['dangling_users']}\")\n        print(f\"Found: {found_dangling}\")\n\n        if missing_dangling:\n            print(f\"❌ Missing dangling users: {missing_dangling}\")\n        if extra_dangling:\n            print(f\"ℹ️  Extra dangling users found: {extra_dangling}\")\n\n        # Verify permission gaps\n        missing_gaps = expected_issues['permission_gaps'] - found_permission_gaps\n\n        print(f\"\\n=== Permission Gaps ===\")\n        print(f\"Expected gaps: {len(expected_issues['permission_gaps'])}\")\n        print(f\"Found gaps: {len(found_permission_gaps)}\")\n\n        if missing_gaps:\n            print(f\"❌ Missing permission gaps:\")\n            for gap in missing_gaps:\n                print(f\"   - {gap[0]} missing {gap[2]} on {gap[1]}\")\n\n        # Additional validation: Check findings structure\n        structure_valid = True\n        for i, finding in enumerate(findings):\n            if len(finding) != 7:  # Should have 7 columns\n                print(f\"❌ FAIL: Finding {i+1} has wrong number of columns\")\n                structure_valid = False\n                continue\n\n            finding_type, username, table_name, missing_permission, justification, action, severity = finding[1:]\n\n            if not finding_type:\n                print(f\"❌ FAIL: Finding {i+1} missing finding_type\")\n                structure_valid = False\n\n            if not username:\n                print(f\"❌ FAIL: Finding {i+1} missing username\")\n                structure_valid = False\n\n            if not justification:\n                print(f\"❌ FAIL: Finding {i+1} missing business_justification\")\n                structure_valid = False\n\n            if not action:\n                print(f\"❌ FAIL: Finding {i+1} missing recommended_action\")\n                structure_valid = False\n\n            if severity not in ['HIGH', 'MEDIUM', 'LOW']:\n                print(f\"❌ FAIL: Finding {i+1} invalid severity: {severity}\")\n                structure_valid = False\n\n        # Calculate score\n        score = 0\n        max_score = 100\n\n        # Points for finding dangling users (30 points)\n        dangling_score = (len(found_dangling & expected_issues['dangling_users']) / len(expected_issues['dangling_users'])) * 30\n        score += dangling_score\n\n        # Points for finding permission gaps (50 points)\n        gap_score = (len(found_permission_gaps & expected_issues['permission_gaps']) / len(expected_issues['permission_gaps'])) * 50\n        score += gap_score\n\n        # Points for proper structure (20 points)\n        if structure_valid:\n            score += 20\n\n        print(f\"\\n=== Verification Results ===\")\n        print(f\"Dangling users score: {dangling_score:.1f}/30\")\n        print(f\"Permission gaps score: {gap_score:.1f}/50\")\n        print(f\"Structure score: {20 if structure_valid else 0}/20\")\n        print(f\"Total Score: {score:.1f}/100\")\n\n        if score >= 80:\n            print(\"✅ PASS: Security audit successfully identified most critical issues\")\n            return True\n        elif score >= 60:\n            print(\"⚠️  PARTIAL: Security audit identified some issues but missed important findings\")\n            return False\n        else:\n            print(\"❌ FAIL: Security audit failed to identify critical security issues\")\n            return False\n\n    except Exception as e:\n        print(f\"❌ FAIL: Error during verification: {e}\")\n        return False\n    finally:\n        if 'cur' in locals():\n            cur.close()\n        if 'conn' in locals():\n            conn.close()\n\nif __name__ == \"__main__\":\n    success = verify_security_audit()\n    sys.exit(0 if success else 1)\n"
}