{
  "task_id": "team_roster_management",
  "task_name": "Team Roster Management",
  "category_id": "sports",
  "category_name": "Sports",
  "description": "Manage team rosters with player transfers, injury tracking, performance evaluations, and health status adjustments.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-18",
  "difficulty": "L3",
  "tags": [
    "schema design",
    "data migration",
    "statistical aggregation"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "# Team Roster Management Operations\n\n## Background\nYou need to manage team rosters for the upcoming season, including player transfers, injury tracking, and performance evaluations.\n\n## Requirements\n\nComplete the following 5 operations in order:\n\n### 1. Set Up Player Performance Tracking\nCreate a table called `player_evaluation` with the following structure:\n- performance_id (serial primary key)\n- person_id (integer not null, references persons(id))\n- batting_avg (decimal)\n- home_runs (integer)\n- rbis (integer)\n- games_played (integer)\n- performance_score (decimal)\n- evaluation_date (date)\n\nAdd constraint: CHECK (batting_avg BETWEEN 0 AND 1)\n\n### 2. Load Historical Player Statistics\nInsert player performance data into `player_evaluation`:\n- Select all players who have offensive statistics\n- Calculate batting_avg as hits/at_bats (handle division by zero)\n- Sum up home_runs, rbi from baseball_offensive_stats\n- Count games_played from person_event_metadata\n- Calculate performance_score as: (batting_avg * 1000) + (home_runs * 5) + (rbi * 2)\n- Only include players with at least 10 games played\n- Set evaluation_date to '2024-01-01'\n\n### 3. Track Player Health Status\nCreate a table called `player_injury_status`:\n- status_id (serial primary key)\n- person_id (integer unique not null)\n- injury_count (integer default 0)\n- last_injury_date (date)\n- current_status (varchar check in ('healthy', 'injured', 'recovering'))\n\nInsert data by:\n- Including all players from player_evaluation\n- Count injuries from injury_phases for each player\n- Get the most recent injury start_date as last_injury_date\n- Set current_status: 'injured' if injury has no end_date, otherwise 'healthy'\n\n### 4. Adjust Scores Based on Health\nUpdate `player_evaluation` to reduce performance scores for injured players:\n- Reduce performance_score by 20% for players with current_status = 'injured'\n- Reduce performance_score by 10% for players with injury_count > 2\n- Set minimum performance_score to 0 (no negative scores)\n\n### 5. Generate Performance Summary Report\nCreate a summary table called `team_performance_summary`:\n- summary_id (serial primary key)\n- metric_name (varchar unique)\n- metric_value (decimal)\n\nInsert the following metrics:\n- 'total_players' - count of players in player_evaluation\n- 'avg_batting_average' - average batting_avg\n- 'total_home_runs' - sum of all home_runs\n- 'avg_performance_score' - average performance_score\n- 'injured_player_count' - count of injured players\n- 'healthy_player_count' - count of healthy players\n\n## Important Notes\n- Handle NULL values appropriately (treat as 0 where needed)\n- Ensure foreign key constraints are properly set\n- Do NOT use ROUND functions in calculations\n- Use COALESCE to handle NULL values in calculations",
  "verify": "\"\"\"\nVerification script for PostgreSQL Sports Task 2: Team Roster Management Operations\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.001 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.001:\n                return False\n        elif isinstance(actual, float) and isinstance(expected, float):\n            if abs(actual - expected) > 0.001:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\", \"sports\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\", \"postgres\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\", \"postgres\")\n    }\n\ndef verify_player_evaluation_table(conn) -> bool:\n    \"\"\"Verify the final state of player_evaluation table after all operations.\"\"\"\n    with conn.cursor() as cur:        \n        # Get actual results from the created table\n        cur.execute(\"\"\"\n            SELECT person_id, batting_avg, home_runs, rbis, games_played, performance_score\n            FROM player_evaluation\n            ORDER BY person_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query that simulates all steps:\n        # 1. Initial insert (step 2)\n        # 2. Update based on injuries (step 4)\n        cur.execute(\"\"\"\n            WITH initial_players AS (\n                SELECT \n                    s.stat_holder_id AS person_id,\n                    SUM(bos.hits)      AS total_hits,\n                    SUM(bos.at_bats)   AS total_at_bats,\n                    CASE \n                        WHEN SUM(bos.at_bats) > 0 \n                        THEN 1.0 * SUM(bos.hits) / SUM(bos.at_bats)\n                        ELSE 0 \n                    END                AS batting_avg,\n                    SUM(bos.home_runs) AS home_runs,\n                    SUM(bos.rbi)       AS rbis\n                FROM stats s\n                JOIN baseball_offensive_stats bos\n                ON s.stat_repository_id = bos.id\n                WHERE s.stat_holder_type = 'persons'\n                AND s.stat_repository_type = 'baseball_offensive_stats'\n                GROUP BY s.stat_holder_id\n            ),\n            game_counts AS (\n                SELECT \n                    person_id,\n                    COUNT(DISTINCT event_id) AS games_played\n                FROM person_event_metadata\n                GROUP BY person_id\n            ),\n            players_with_games AS (\n                SELECT \n                    ip.person_id,\n                    ip.batting_avg,\n                    ip.home_runs,\n                    ip.rbis,\n                    COALESCE(gc.games_played, 0) AS games_played,\n                    (ip.batting_avg * 1000)\n                    + (COALESCE(ip.home_runs, 0) * 5)\n                    + (COALESCE(ip.rbis, 0) * 2) AS initial_score\n                FROM initial_players ip\n                LEFT JOIN game_counts gc ON ip.person_id = gc.person_id\n                WHERE COALESCE(gc.games_played, 0) >= 10\n            ),\n            injury_info AS (\n                SELECT \n                    person_id,\n                    COUNT(*) AS injury_count,\n                    MAX(CASE WHEN end_date_time IS NULL THEN 1 ELSE 0 END) AS has_active_injury\n                FROM injury_phases\n                GROUP BY person_id\n            ),\n            adjusted_scores AS (\n                SELECT \n                    pwg.person_id,\n                    pwg.batting_avg,\n                    pwg.home_runs,\n                    pwg.rbis,\n                    pwg.games_played,\n                    GREATEST(\n                        CASE \n                            WHEN COALESCE(ii.has_active_injury, 0) = 1 AND COALESCE(ii.injury_count, 0) > 2 \n                                THEN pwg.initial_score * 0.8 * 0.9\n                            WHEN COALESCE(ii.has_active_injury, 0) = 1 \n                                THEN pwg.initial_score * 0.8\n                            WHEN COALESCE(ii.injury_count, 0) > 2 \n                                THEN pwg.initial_score * 0.9\n                            ELSE pwg.initial_score\n                        END,\n                        0\n                    ) AS performance_score\n                FROM players_with_games pwg\n                LEFT JOIN injury_info ii ON ii.person_id = pwg.person_id\n            )\n            SELECT \n                person_id,\n                batting_avg,\n                home_runs,\n                rbis,\n                games_played,\n                performance_score\n            FROM adjusted_scores\n            ORDER BY person_id;\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} player evaluation records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:  # Only show first 5 mismatches\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches in player_evaluation: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Player evaluation table is correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_injury_status_table(conn) -> bool:\n    \"\"\"Verify the player_injury_status table and data.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results\n        cur.execute(\"\"\"\n            SELECT person_id, injury_count, last_injury_date, current_status\n            FROM player_injury_status\n            ORDER BY person_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query - get players from player_evaluation\n        cur.execute(\"\"\"\n            WITH player_list AS (\n                SELECT DISTINCT person_id \n                FROM player_evaluation\n            ),\n            injury_counts AS (\n                SELECT \n                    person_id,\n                    COUNT(*) as injury_count,\n                    MAX(start_date_time::date) as last_injury_date,\n                    MAX(CASE WHEN end_date_time IS NULL THEN 1 ELSE 0 END) as has_active_injury\n                FROM injury_phases\n                GROUP BY person_id\n            )\n            SELECT \n                pl.person_id,\n                COALESCE(ic.injury_count, 0) as injury_count,\n                ic.last_injury_date,\n                CASE \n                    WHEN COALESCE(ic.has_active_injury, 0) = 1 THEN 'injured'\n                    ELSE 'healthy'\n                END as current_status\n            FROM player_list pl\n            LEFT JOIN injury_counts ic ON pl.person_id = ic.person_id\n            ORDER BY pl.person_id\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} injury status records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for i, (actual, expected) in enumerate(zip(actual_results, expected_results)):\n            if not rows_match(actual, expected):\n                if mismatches < 5:\n                    print(f\"‚ùå Row {i+1} mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches in player_injury_status: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Player injury status table is correct ({len(actual_results)} records)\")\n        return True\n\n\ndef verify_summary_table(conn) -> bool:\n    \"\"\"Verify the team_performance_summary table.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results\n        cur.execute(\"\"\"\n            SELECT metric_name, metric_value\n            FROM team_performance_summary\n            ORDER BY metric_name\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            WITH player_data AS (\n                SELECT \n                    COUNT(*) as total_players,\n                    AVG(batting_avg) as avg_batting_average,\n                    SUM(home_runs) as total_home_runs,\n                    AVG(performance_score) as avg_performance_score\n                FROM player_evaluation\n            ),\n            health_data AS (\n                SELECT \n                    SUM(CASE WHEN current_status = 'injured' THEN 1 ELSE 0 END) as injured_count,\n                    SUM(CASE WHEN current_status = 'healthy' THEN 1 ELSE 0 END) as healthy_count\n                FROM player_injury_status\n                WHERE person_id IN (SELECT person_id FROM player_evaluation)\n            )\n            SELECT metric_name, metric_value::DECIMAL\n            FROM (\n                SELECT 'avg_batting_average' as metric_name, avg_batting_average as metric_value FROM player_data\n                UNION ALL\n                SELECT 'avg_performance_score', avg_performance_score FROM player_data\n                UNION ALL\n                SELECT 'healthy_player_count', healthy_count FROM health_data\n                UNION ALL\n                SELECT 'injured_player_count', injured_count FROM health_data\n                UNION ALL\n                SELECT 'total_home_runs', total_home_runs FROM player_data\n                UNION ALL\n                SELECT 'total_players', total_players FROM player_data\n            ) metrics\n            ORDER BY metric_name\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} metrics, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for actual, expected in zip(actual_results, expected_results):\n            if not rows_match(actual, expected):\n                if mismatches < 5:\n                    print(f\"‚ùå Metric mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches in summary table: {mismatches}\")\n            return False\n        \n        print(f\"‚úÖ Team performance summary table is correct ({len(actual_results)} metrics)\")\n        return True\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n    print(\"Verifying Sports Task 2: Team Roster Management Operations\")\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify all steps\n        success = (\n            verify_player_evaluation_table(conn) and \n            verify_injury_status_table(conn) and\n            verify_summary_table(conn)\n        )\n\n        conn.close()\n\n        if success:\n            print(\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}