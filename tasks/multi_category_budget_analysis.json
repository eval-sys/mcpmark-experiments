{
  "task_id": "multi_category_budget_analysis",
  "task_name": "Multi Category Budget Analysis",
  "category_id": "shopping",
  "category_name": "Shopping",
  "description": "Analyze spending patterns across multiple product categories, optimize budget allocation, identify cost-saving opportunities, and generate comprehensive financial planning report with purchase recommendations.",
  "author": "Yaoqi Ye",
  "created_at": "2025-08-17",
  "difficulty": "L3",
  "tags": [
    "data extraction",
    "search aggregation",
    "content submission",
    "comparative analysis",
    "inventory management"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "https://storage.mcpmark.ai/tasks_state/playwright_video/one-stop-market.mp4",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "Complete the following tasks on One Stop Market (http://localhost:7770):\n\n**Task Requirements:**\n\n1. In Chocolate subcategory, sort by price (ascending):\n   - Record price and SKU of first 3 products\n\n2. Search for 'tabletop' with price range $100.00-$200.00:\n   - Find the cheapest tabletop that has the highest review rating with at least 3 reviews.\n   - Record search results count\n   - Record price of required tabletop\n\n3. In \"Computers & Accessories\" subcategory with price filter $0.00-$9,999.99:\n   - Sort by price (ascending)\n   - Record price of cheapest item\n\n4. Add these products to comparison:\n   - \"Little Secrets Chocolate Pieces, Peanut Butter Flavor\"\n   - \"Multi Accessory Hub Adapter By JOBY\"\n   - \"SanDisk Cruzer Glide 32GB (5 Pack) USB 2.0 Flash Drive\"\n   - Count total items on comparison page\n\n5. In cart:\n   - Add the cheapest chocolate product (from step 1) with \"Peanut flavor\" if available\n   - Add cheapest computer accessory (from step 3)\n   - Record cart subtotal and item count\n\n6. Calculate:\n   - Sum of 3 chocolate product prices\n   - Price difference: cheapest tabletop minus cheapest computer accessory\n   - Whether sum of 3 comparison items < $60\n\n**Output Format:**\n\n```\n<answer>\nchocolate_products|Price1:SKU1;Price2:SKU2;Price3:SKU3\nchocolate_sum|Total\ntabletop_search_count|Count\ntabletop_product|Price:SKU\ntabletop_reviews|NumbersOfReviews:Rating\ncheapest_computer_accessory|Price\nprice_difference|Amount\ncomparison_count|Count\ncart_subtotal|Amount\ncart_item_count|Count\nunder_60_budget|YES/NO\n</answer>\n```\n\n",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nimport json\nfrom pathlib import Path\n\n\ndef get_model_response():\n    \"\"\"\n    Get the model's response from the MCP_MESSAGES environment variable.\n    Returns the last assistant message text.\n    \"\"\"\n    messages_path = os.getenv(\"MCP_MESSAGES\")\n    print(f\"MCP_MESSAGES: {messages_path}\")\n    if not messages_path:\n        print(\"Warning: MCP_MESSAGES environment variable not set\", file=sys.stderr)\n        return None\n\n    try:\n        with open(messages_path, \"r\") as f:\n            messages = json.load(f)\n\n        # Find the last assistant message\n        for message in reversed(messages):\n            if (\n                message.get(\"role\") == \"assistant\"\n                and message.get(\"status\") == \"completed\"\n                and message.get(\"type\") == \"message\"\n            ):\n                content = message.get(\"content\", [])\n                for item in content:\n                    if item.get(\"type\") == \"output_text\":\n                        return item.get(\"text\", \"\")\n\n        print(\"Warning: No assistant response found in messages\", file=sys.stderr)\n        return None\n    except Exception as e:\n        print(f\"Error reading messages file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef parse_answer_format(text):\n    \"\"\"\n    Parse the <answer>...</answer> format from the agent's output.\n    Returns a dictionary with the parsed values.\n    \"\"\"\n    if not text:\n        return None\n\n    # Look for <answer>...</answer> pattern\n    match = re.search(r\"<answer>(.*?)</answer>\", text, re.IGNORECASE | re.DOTALL)\n    if not match:\n        return None\n\n    answer_content = match.group(1).strip()\n\n    # Parse each line\n    result = {}\n    lines = answer_content.split(\"\\n\")\n\n    if len(lines) != 11:\n        print(f\"Error: Expected 11 lines in answer, got {len(lines)}\", file=sys.stderr)\n        return None\n\n    for line in lines:\n        if \"|\" in line:\n            key, value = line.split(\"|\", 1)\n            result[key.strip()] = value.strip()\n\n    return result\n\n\ndef load_expected_answer(label_path):\n    \"\"\"\n    Load the expected answer from label.txt file.\n    Returns a dictionary with the expected values.\n    \"\"\"\n    try:\n        with open(label_path, \"r\") as f:\n            lines = f.read().strip().split(\"\\n\")\n\n        expected = {}\n        for line in lines:\n            if \"|\" in line:\n                key, value = line.split(\"|\", 1)\n                expected[key.strip()] = value.strip()\n\n        return expected\n    except Exception as e:\n        print(f\"Error reading label file: {str(e)}\", file=sys.stderr)\n        return None\n\n\ndef compare_answers(model_answer, expected_answer):\n    \"\"\"\n    Compare the model's answer with the expected answer.\n    Returns True if all key information matches, False otherwise.\n    \"\"\"\n    if not model_answer or not expected_answer:\n        return False\n\n    # Check each expected key\n    mismatches = []\n    for key, expected_value in expected_answer.items():\n        model_value = model_answer.get(key, \"\")\n\n        # Special handling for different types of values\n        if key == \"chocolate_products\":\n            # Parse and compare chocolate products with price:SKU format\n            expected_products = expected_value.split(\";\")\n            model_products = model_value.split(\";\")\n            \n            if len(expected_products) != len(model_products):\n                mismatches.append(f\"{key}: expected {len(expected_products)} products, got {len(model_products)}\")\n            else:\n                for i, (exp, mod) in enumerate(zip(expected_products, model_products)):\n                    exp_parts = exp.strip().split(\":\")\n                    mod_parts = mod.strip().split(\":\")\n                    if len(exp_parts) != 2 or len(mod_parts) != 2:\n                        mismatches.append(f\"{key}: product {i+1} format error - expected 'price:SKU'\")\n                    else:\n                        # Check price format (should start with $)\n                        if not mod_parts[0].startswith(\"$\"):\n                            mismatches.append(f\"{key}: product {i+1} price format error - expected '$XX.XX' format, got '{mod_parts[0]}'\")\n                        elif exp_parts[0] != mod_parts[0] or exp_parts[1] != mod_parts[1]:\n                            mismatches.append(f\"{key}: product {i+1} mismatch - expected '{exp}', got '{mod}'\")\n\n        elif key == \"tabletop_product\":\n            # Parse and compare tabletop product with price:SKU format\n            exp_parts = expected_value.strip().split(\":\")\n            mod_parts = model_value.strip().split(\":\")\n            if len(exp_parts) != 2 or len(mod_parts) != 2:\n                mismatches.append(f\"{key}: format error - expected 'price:SKU', got '{model_value}'\")\n            else:\n                # Check price format (should start with $)\n                if not mod_parts[0].startswith(\"$\"):\n                    mismatches.append(f\"{key}: price format error - expected '$XX.XX' format, got '{mod_parts[0]}'\")\n                elif exp_parts[0] != mod_parts[0] or exp_parts[1] != mod_parts[1]:\n                    mismatches.append(f\"{key}: mismatch - expected '{expected_value}', got '{model_value}'\")\n        \n        elif key == \"tabletop_reviews\":\n            # Parse and compare tabletop reviews with NumberOfReviews:Rating format\n            exp_parts = expected_value.strip().split(\":\")\n            mod_parts = model_value.strip().split(\":\")\n            if len(exp_parts) != 2 or len(mod_parts) != 2:\n                mismatches.append(f\"{key}: format error - expected 'NumberOfReviews:Rating', got '{model_value}'\")\n            else:\n                # Check if both parts match\n                if exp_parts[0] != mod_parts[0] or exp_parts[1] != mod_parts[1]:\n                    mismatches.append(f\"{key}: mismatch - expected '{expected_value}', got '{model_value}'\")\n\n        elif key in [\"chocolate_sum\", \"price_difference\", \"cart_subtotal\", \"cheapest_computer_accessory\"]:\n            # For price fields, only support $XX.XX format\n            # Check if model value has correct format\n            if not model_value.startswith(\"$\"):\n                mismatches.append(\n                    f\"{key}: incorrect format - expected '$XX.XX' format, got '{model_value}'\"\n                )\n            else:\n                # Normalize and compare values\n                expected_clean = expected_value.replace(\"$\", \"\").replace(\",\", \"\")\n                model_clean = model_value.replace(\"$\", \"\").replace(\",\", \"\")\n                if expected_clean != model_clean:\n                    mismatches.append(\n                        f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                    )\n\n        elif key == \"under_60_budget\":\n            # Compare YES/NO value (case-insensitive)\n            if expected_value.upper() != model_value.upper():\n                mismatches.append(f\"{key}: expected '{expected_value}', got '{model_value}'\")\n\n        elif key in [\"tabletop_search_count\", \"comparison_count\", \"cart_item_count\"]:\n            # Numeric fields - exact match\n            if model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n        else:\n            # Exact match for other fields\n            if model_value != expected_value:\n                mismatches.append(\n                    f\"{key}: expected '{expected_value}', got '{model_value}'\"\n                )\n\n    if mismatches:\n        print(\"\\n=== Answer Comparison Mismatches ===\", file=sys.stderr)\n        for mismatch in mismatches:\n            print(f\"✗ {mismatch}\", file=sys.stderr)\n        return False\n\n    print(\"\\n=== Answer Comparison ===\", file=sys.stderr)\n    print(\"✓ All key information matches the expected answer\", file=sys.stderr)\n    return True\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the multi-category budget analysis task has been completed correctly.\n    \"\"\"\n    # Get the label file path\n    label_path = Path(__file__).parent / \"label.txt\"\n    \n    # Load expected answer\n    expected_answer = load_expected_answer(label_path)\n    if not expected_answer:\n        print(\"Error: Could not load expected answer from label.txt\", file=sys.stderr)\n        return False\n\n    # Get model's response from MCP_MESSAGES\n    model_response = get_model_response()\n    if model_response:\n        print(\"Found model response, parsing answer format...\", file=sys.stderr)\n        model_answer = parse_answer_format(model_response)\n        \n        if model_answer:\n            print(\"\\n=== Model Answer Parsed ===\", file=sys.stderr)\n            for key, value in model_answer.items():\n                print(f\"{key}: {value}\", file=sys.stderr)\n            \n            # Compare answers\n            answer_match = compare_answers(model_answer, expected_answer)\n            if not answer_match:\n                print(\"\\nModel answer does not match expected answer\", file=sys.stderr)\n                return False\n            print(\"\\n✓ Model answer matches expected answer\", file=sys.stderr)\n            return True\n        else:\n            print(\"Warning: Could not parse answer format from model response\", file=sys.stderr)\n            return False\n    else:\n        print(\"No model response found\", file=sys.stderr)\n        return False\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()"
}