{
  "task_id": "participant_report_optimization",
  "task_name": "Participant Report Optimization",
  "category_id": "sports",
  "category_name": "Sports",
  "description": "Optimize slow-running participant performance query by creating indexes and populating performance report table.",
  "author": "Lingxiao Du",
  "created_at": "2025-08-18",
  "difficulty": "L3",
  "tags": [
    "performance optimization",
    "schema design"
  ],
  "mcp": [
    "postgres"
  ],
  "metadata": {},
  "instruction": "# Query Performance Optimization\n\n## Background\nYou need to optimize a slow-running analytics query that generates performance reports. The query currently takes too long to execute and needs optimization.\n\n## Requirements\n\n### 1. Create Performance Report Table\nCreate a table called `participant_performance_report` with the following structure:\n- report_id (serial primary key)\n- participant_id (integer not null)\n- event_count (integer)\n- stat_count (integer)\n- stat_type_count (integer)\n- last_event_date (timestamp)\n- created_at (timestamp default current_timestamp)\n\nAdd constraint: CHECK (participant_id > 0)\n\n### 2. Execute and Optimize the Slow Query\nThe following query is currently running very slowly. Your task is to:\n1. **Identify why the query is slow**\n2. **Create appropriate indexes to optimize it** \n3. **Populate the report table with the query results**\n\n```sql\nSELECT \n    pe.participant_id,\n    COUNT(pe.event_id) as event_count,\n    (SELECT COUNT(*) FROM stats s WHERE s.stat_holder_id = pe.participant_id AND s.stat_holder_type = 'persons') as stat_count,\n    (SELECT COUNT(DISTINCT s.stat_repository_type) FROM stats s WHERE s.stat_holder_id = pe.participant_id AND s.stat_holder_type = 'persons') as stat_type_count,\n    (SELECT MAX(e.start_date_time) FROM events e JOIN participants_events pe2 ON e.id = pe2.event_id WHERE pe2.participant_id = pe.participant_id) as last_event_date\nFROM participants_events pe \nWHERE pe.participant_id <= 50\nGROUP BY pe.participant_id\nORDER BY pe.participant_id;\n```\n\n### 3. Document Performance Improvement\nAfter optimization, insert the results into your `participant_performance_report` table.\n\n## Success Criteria\n- The query should execute significantly faster after your optimization\n- All results should be correctly inserted into the report table\n- Your optimization should use appropriate database indexes\n\n## Important Notes\n- Analyze the query execution plan to identify bottlenecks\n- Focus on the most impactful optimizations\n- Handle NULL values appropriately in calculations",
  "verify": "\"\"\"\nVerification script for PostgreSQL Sports Task 3: Query Performance Optimization\n\"\"\"\n\nimport os\nimport sys\nimport psycopg2\nfrom decimal import Decimal\n\ndef rows_match(actual_row, expected_row):\n    \"\"\"\n    Compare two rows with appropriate tolerance.\n    For Decimal types: allows 0.001 tolerance\n    For other types: requires exact match\n    \"\"\"\n    if len(actual_row) != len(expected_row):\n        return False\n    \n    for actual, expected in zip(actual_row, expected_row):\n        if isinstance(actual, Decimal) and isinstance(expected, Decimal):\n            if abs(float(actual) - float(expected)) > 0.001:\n                return False\n        elif isinstance(actual, float) and isinstance(expected, float):\n            if abs(actual - expected) > 0.001:\n                return False\n        elif actual != expected:\n            return False\n    \n    return True\n\ndef get_connection_params() -> dict:\n    \"\"\"Get database connection parameters.\"\"\"\n    return {\n        \"host\": os.getenv(\"POSTGRES_HOST\", \"localhost\"),\n        \"port\": int(os.getenv(\"POSTGRES_PORT\", 5432)),\n        \"database\": os.getenv(\"POSTGRES_DATABASE\", \"sports\"),\n        \"user\": os.getenv(\"POSTGRES_USERNAME\", \"postgres\"),\n        \"password\": os.getenv(\"POSTGRES_PASSWORD\", \"postgres\")\n    }\n\ndef verify_report_data(conn) -> bool:\n    \"\"\"Verify the report table contains the expected data.\"\"\"\n    with conn.cursor() as cur:\n        # Get actual results from the report table\n        cur.execute(\"\"\"\n            SELECT participant_id, event_count, stat_count, stat_type_count, last_event_date\n            FROM participant_performance_report\n            ORDER BY participant_id\n        \"\"\")\n        actual_results = cur.fetchall()\n        \n        if len(actual_results) == 0:\n            print(\"‚ùå Report table is empty\")\n            return False\n        \n        # Execute ground truth query\n        cur.execute(\"\"\"\n            SELECT \n                pe.participant_id,\n                COUNT(pe.event_id) as event_count,\n                (SELECT COUNT(*) FROM stats s WHERE s.stat_holder_id = pe.participant_id AND s.stat_holder_type = 'persons') as stat_count,\n                (SELECT COUNT(DISTINCT s.stat_repository_type) FROM stats s WHERE s.stat_holder_id = pe.participant_id AND s.stat_holder_type = 'persons') as stat_type_count,\n                (SELECT MAX(e.start_date_time) FROM events e JOIN participants_events pe2 ON e.id = pe2.event_id WHERE pe2.participant_id = pe.participant_id) as last_event_date\n            FROM participants_events pe \n            WHERE pe.participant_id <= 50\n            GROUP BY pe.participant_id\n            ORDER BY pe.participant_id\n        \"\"\")\n        expected_results = cur.fetchall()\n\n        if len(actual_results) != len(expected_results):\n            print(f\"‚ùå Expected {len(expected_results)} report records, got {len(actual_results)}\")\n            return False\n\n        mismatches = 0\n        for actual, expected in zip(actual_results, expected_results):\n            if not rows_match(actual, expected):\n                if mismatches < 5:\n                    print(f\"‚ùå Row mismatch: expected {expected}, got {actual}\")\n                mismatches += 1\n\n        if mismatches > 0:\n            print(f\"‚ùå Total mismatches in report data: {mismatches}\")\n            return False\n\n        print(f\"‚úÖ Report data is correct ({len(actual_results)} records)\")\n        return True\n\ndef verify_performance_optimization(conn) -> bool:\n    \"\"\"Verify that key performance optimization indexes have been implemented.\"\"\"\n    with conn.cursor() as cur:\n        print(\"\\nüîç Checking for critical performance indexes...\")\n        \n        # Check 1: participants_events.participant_id index (critical for subqueries)\n        cur.execute(\"\"\"\n            SELECT indexname, indexdef \n            FROM pg_indexes \n            WHERE schemaname = 'public' \n            AND tablename = 'participants_events'\n            AND indexdef LIKE '%participant_id%'\n        \"\"\")\n        participant_indexes = cur.fetchall()\n        has_participant_index = len(participant_indexes) > 0\n        \n        # Check 2: stats table optimization (critical for subquery filtering)\n        cur.execute(\"\"\"\n            SELECT indexname, indexdef \n            FROM pg_indexes \n            WHERE schemaname = 'public' \n            AND tablename = 'stats'\n            AND indexdef LIKE '%stat_holder_type%'\n            AND indexdef LIKE '%stat_holder_id%'\n        \"\"\")\n        stats_indexes = cur.fetchall()\n        has_stats_index = len(stats_indexes) > 0\n        \n        # Report findings\n        critical_indexes_found = 0\n        \n        if has_participant_index:\n            print(\"‚úÖ Found participant filtering index on participants_events.participant_id\")\n            critical_indexes_found += 1\n        else:\n            print(\"‚ùå Missing critical index on participants_events.participant_id\")\n            \n        if has_stats_index:\n            print(\"‚úÖ Found subquery optimization index on stats table\")\n            critical_indexes_found += 1\n        else:\n            print(\"‚ùå Missing critical index on stats table\")\n        \n        # Must have both critical indexes for this subquery-heavy query\n        if critical_indexes_found >= 2:\n            print(f\"\\n‚úÖ Performance optimization: PASS ({critical_indexes_found}/2 critical indexes found)\")\n            return True\n        else:\n            print(f\"\\n‚ùå Performance optimization: FAIL ({critical_indexes_found}/2 critical indexes found)\")\n            print(\"   Create these critical indexes:\")\n            print(\"   - CREATE INDEX ON participants_events(participant_id);\")\n            print(\"   - CREATE INDEX ON stats(stat_holder_type, stat_holder_id);\")\n            return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    print(\"=\" * 50)\n    print(\"Verifying Sports Task 3: Query Performance Optimization\")\n    print(\"=\" * 50)\n\n    # Get connection parameters\n    conn_params = get_connection_params()\n\n    if not conn_params[\"database\"]:\n        print(\"‚ùå No database specified\")\n        sys.exit(1)\n\n    try:\n        # Connect to database\n        conn = psycopg2.connect(**conn_params)\n\n        # Verify all components\n        success = (\n            verify_report_data(conn) and\n            verify_performance_optimization(conn)\n        )\n\n        conn.close()\n\n        if success:\n            print(\"\\nüéâ Task verification: PASS\")\n            sys.exit(0)\n        else:\n            print(\"\\n‚ùå Task verification: FAIL\")\n            sys.exit(1)\n\n    except psycopg2.Error as e:\n        print(f\"‚ùå Database error: {e}\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"‚ùå Verification error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()"
}