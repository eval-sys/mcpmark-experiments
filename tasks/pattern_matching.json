{
  "task_id": "pattern_matching",
  "task_name": "Pattern Matching",
  "category_id": "file_context",
  "category_name": "File Context",
  "description": "Search multiple files for shared character sequences and precisely locate all matching pattern occurrences within the target files.",
  "author": "Lingjun Chen",
  "created_at": "2025-08-06",
  "difficulty": "L3",
  "tags": [
    "pattern analysis",
    "cross-referencing"
  ],
  "mcp": [
    "filesystem"
  ],
  "metadata": {},
  "instruction": "# File Filtering Task: Find Files with Common Substring\n\n## üìã Task Description\n\nYour task is to find all files that contain a substring of 30 or more characters that also appears in `large_file.txt`. **You are not allowed to use python code.**\n\n## üéØ Task Objectives\n\n1. **Read the reference file** `large_file.txt` to understand its content\n2. **Examine each file** from file_01.txt to file_20.txt\n3. **Find files** that contain a substring of 30 or more characters that matches a substring in `large_file.txt`\n4. **Create a file `answer.txt`** and write the results to it with the following format:\n   - One line per matching file\n   - Format: `filename.txt,start_position`\n   - Where start_position is the character position (1-indexed) of the matching substring in `large_file.txt`\n   - Do not add any things else other than `filename.txt,start_position`.\n",
  "verify": "#!/usr/bin/env python3\n\"\"\"\nVerification script for File Filtering Task: Find Files with Common Substring\n\"\"\"\n\nimport sys\nfrom pathlib import Path\nimport os\nimport re\n\ndef get_test_directory() -> Path:\n    \"\"\"Get the test directory from FILESYSTEM_TEST_DIR env var.\"\"\"\n    test_root = os.environ.get(\"FILESYSTEM_TEST_DIR\")\n    if not test_root:\n        raise ValueError(\"FILESYSTEM_TEST_DIR environment variable is required\")\n    return Path(test_root)\n\ndef verify_answer_file_exists(test_dir: Path) -> bool:\n    \"\"\"Verify that the answer.txt file exists.\"\"\"\n    answer_file = test_dir / \"answer.txt\"\n    \n    if not answer_file.exists():\n        print(\"‚ùå File 'answer.txt' not found\")\n        return False\n    \n    print(\"‚úÖ Answer file found\")\n    return True\n\ndef verify_answer_format(test_dir: Path) -> bool:\n    \"\"\"Verify that the answer file has the correct format.\"\"\"\n    answer_file = test_dir / \"answer.txt\"\n    \n    try:\n        content = answer_file.read_text().strip()\n        \n        # If file is empty, that's acceptable (no matches found)\n        if not content:\n            print(\"‚úÖ Answer file is empty (no matches found)\")\n            return True\n        \n        lines = content.split('\\n')\n        \n        for i, line in enumerate(lines, 1):\n            line = line.strip()\n            if not line:\n                continue\n                \n            # Check format: filename.txt,start_position\n            parts = line.split(',')\n            if len(parts) != 2:\n                print(f\"‚ùå Line {i} has incorrect format: {line}\")\n                print(\"   Expected format: filename.txt,start_position\")\n                return False\n            \n            filename, start_pos = parts\n            \n            # Check filename format\n            if not filename.endswith('.txt') or not filename.startswith('file_'):\n                print(f\"‚ùå Line {i} has invalid filename: {filename}\")\n                return False\n            \n            # Check position format (should be integer)\n            try:\n                start_int = int(start_pos)\n                if start_int <= 0:\n                    print(f\"‚ùå Line {i} has invalid position: {start_pos}\")\n                    return False\n            except ValueError:\n                print(f\"‚ùå Line {i} has non-integer position: {start_pos}\")\n                return False\n        \n        print(\"‚úÖ Answer format is correct\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error reading answer file: {e}\")\n        return False\n\ndef find_30_plus_char_matches(test_dir: Path) -> dict:\n    \"\"\"Find all matches with 30 or more characters between files and large_file.txt.\"\"\"\n    large_file = test_dir / \"large_file.txt\"\n    if not large_file.exists():\n        print(\"‚ùå large_file.txt not found\")\n        return {}\n    \n    large_content = large_file.read_text()\n    matches = {}\n    \n    # Check each file from file_01.txt to file_20.txt\n    for i in range(1, 21):\n        filename = f\"file_{i:02d}.txt\"\n        file_path = test_dir / filename\n        \n        if not file_path.exists():\n            continue\n            \n        file_content = file_path.read_text()\n        \n        # Find the longest matching substring (30+ characters)\n        longest_match = \"\"\n        longest_match_start = -1\n        \n        # Check all possible substrings in the file\n        for start_pos in range(len(file_content)):\n            for end_pos in range(start_pos + 30, len(file_content) + 1):  # At least 30 characters\n                substring = file_content[start_pos:end_pos]\n                \n                # Check if this substring exists in large_file.txt\n                if substring in large_content:\n                    if len(substring) > len(longest_match):\n                        longest_match = substring\n                        # Find the position in large_file.txt where this substring starts\n                        large_start_pos = large_content.find(substring)\n                        longest_match_start = large_start_pos + 1  # 1-indexed\n        \n        # If we found a match of 30+ characters, record it\n        if longest_match and len(longest_match) >= 30:\n            matches[filename] = longest_match_start\n    \n    return matches\n\ndef verify_matches_are_correct(test_dir: Path) -> bool:\n    \"\"\"Verify that the matches found in answer.txt are actually correct.\"\"\"\n    answer_file = test_dir / \"answer.txt\"\n    \n    try:\n        content = answer_file.read_text().strip()\n        \n        # If no content, check if there should actually be no matches\n        if not content:\n            expected_matches = find_30_plus_char_matches(test_dir)\n            if expected_matches:\n                print(\"‚ùå Answer file is empty but matches should exist\")\n                for filename, start_pos in expected_matches.items():\n                    print(f\"   Expected: {filename},{start_pos}\")\n                return False\n            else:\n                print(\"‚úÖ No matches found (correct)\")\n                return True\n        \n        # Parse answer file\n        answer_matches = {}\n        lines = content.split('\\n')\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n            filename, start_pos = line.split(',')\n            answer_matches[filename] = int(start_pos)\n        \n        # Get expected matches\n        expected_matches = find_30_plus_char_matches(test_dir)\n        \n        # Check if all answer matches are correct\n        for filename, start_pos in answer_matches.items():\n            if filename not in expected_matches:\n                print(f\"‚ùå File {filename} listed in answer but has no valid 30+ character match\")\n                return False\n            \n            expected_start = expected_matches[filename]\n            if start_pos != expected_start:\n                print(f\"‚ùå Incorrect match position for {filename}\")\n                print(f\"   Expected: {expected_start}\")\n                print(f\"   Found: {start_pos}\")\n                return False\n        \n        # Check if all expected matches are in answer\n        for filename in expected_matches:\n            if filename not in answer_matches:\n                print(f\"‚ùå Missing match for {filename} in answer file\")\n                return False\n        \n        print(\"‚úÖ All matches are correct\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying matches: {e}\")\n        return False\n\ndef verify_match_length_is_30_plus(test_dir: Path) -> bool:\n    \"\"\"Verify that all matches are at least 30 characters long.\"\"\"\n    answer_file = test_dir / \"answer.txt\"\n    \n    try:\n        content = answer_file.read_text().strip()\n        \n        if not content:\n            return True  # No matches to verify\n        \n        large_file = test_dir / \"large_file.txt\"\n        large_content = large_file.read_text()\n        \n        lines = content.split('\\n')\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            filename, start_pos = line.split(',')\n            start_int = int(start_pos)\n            \n            # Get the file content to check the match\n            file_path = test_dir / filename\n            file_content = file_path.read_text()\n            \n            # Find the longest matching substring starting from the given position\n            longest_match = \"\"\n            for end_pos in range(start_int + 30 - 1, len(large_content) + 1):  # At least 30 characters\n                substring = large_content[start_int - 1:end_pos]  # Convert to 0-indexed\n                if substring in file_content:\n                    longest_match = substring\n                else:\n                    break\n            \n            if len(longest_match) < 30:\n                print(f\"‚ùå Match in {filename} is {len(longest_match)} characters, less than 30\")\n                print(f\"   Starting position: {start_int}\")\n                return False\n        \n        print(\"‚úÖ All matches are at least 30 characters long\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying match lengths: {e}\")\n        return False\n\ndef verify_files_exist(test_dir: Path) -> bool:\n    \"\"\"Verify that all files mentioned in answer.txt actually exist.\"\"\"\n    answer_file = test_dir / \"answer.txt\"\n    \n    try:\n        content = answer_file.read_text().strip()\n        \n        if not content:\n            return True  # No files to verify\n        \n        lines = content.split('\\n')\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n                \n            filename = line.split(',')[0]\n            file_path = test_dir / filename\n            \n            if not file_path.exists():\n                print(f\"‚ùå File mentioned in answer does not exist: {filename}\")\n                return False\n        \n        print(\"‚úÖ All files mentioned in answer exist\")\n        return True\n        \n    except Exception as e:\n        print(f\"‚ùå Error verifying file existence: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main verification function.\"\"\"\n    test_dir = get_test_directory()\n    print(\"üîç Verifying Pattern Matching Task: Find Files with Common Substring...\")\n    \n    # Define verification steps\n    verification_steps = [\n        (\"Answer File Exists\", verify_answer_file_exists),\n        (\"Answer Format\", verify_answer_format),\n        (\"Files Exist\", verify_files_exist),\n        (\"Match Length is 30+\", verify_match_length_is_30_plus),\n        (\"Matches are Correct\", verify_matches_are_correct),\n    ]\n    \n    # Run all verification steps\n    all_passed = True\n    for step_name, verify_func in verification_steps:\n        print(f\"\\n--- {step_name} ---\")\n        if not verify_func(test_dir):\n            all_passed = False\n    \n    # Final result\n    print(\"\\n\" + \"=\"*50)\n    if all_passed:\n        print(\"‚úÖ File filtering task completed correctly!\")\n        print(\"üéâ Task verification: PASS\")\n        sys.exit(0)\n    else:\n        print(\"‚ùå Task verification: FAIL\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()",
  "model_results": {
    "gemini-2-5-pro": 0,
    "deepseek-chat": 0,
    "qwen-3-coder": 0,
    "o3": 1,
    "gpt-5": 0,
    "k2": 0,
    "claude-4-sonnet": 0
  }
}