{
  "task_id": "buyitforlife_research",
  "task_name": "Buy It For Life Research",
  "category_id": "reddit",
  "category_name": "Reddit",
  "description": "Research durable lifetime-quality products by creating forum account, analyzing community recommendations, extracting product data, and compiling comprehensive durability report with voting metrics.",
  "author": "Fanqing Meng",
  "created_at": "2025-08-12",
  "difficulty": "L3",
  "tags": [
    "user interaction",
    "data extraction",
    "search aggregation",
    "content submission"
  ],
  "mcp": [
    "playwright"
  ],
  "meta_data": {
    "stateType": "video",
    "stateContent": null,
    "stateUrl": "",
    "stateOriginalUrl": "https://github.com/web-arena-x/webarena/tree/main/environment_docker"
  },
  "instruction": "Research durable kitchen appliances on the BuyItForLife forum by extracting information about the most popular posts and their community engagement.\n\n**Task Requirements:**\n\n1. Register a new account with username 'buyitforlife_researcher' and password 'BIFL2024Research!'\n\n2. After successful registration, navigate to the BuyItForLife forum\n\n3. Find the top 3 posts with the highest upvote counts and extract:\n   - Exact post title\n   - Exact upvote count\n   - Exact number of comments\n\n4. For the post with the highest upvotes from step 3, click through to read the comments and find the comment with the most upvotes. Record:\n   - The exact comment text\n   - The username of the commenter\n\n5. From the BuyItForLife forum, identify the usernames of the authors who posted the top 3 posts with the highest number of upvotes\n\n6. After collecting all the data, submit a new post in the BuyItForLife forum with:\n   - Title: \"Research Report for BuyItForLife\"\n   - Body text must be EXACTLY these lines without anything (keep the keys as-is, only replace the values after the pipe, follow the markdown format):\n\n```\n- Post1_Title|FILL_VALUE\n- Post1_Upvotes|FILL_VALUE\n- Post1_Comments|FILL_VALUE\n- Post2_Title|FILL_VALUE\n- Post2_Upvotes|FILL_VALUE\n- Post2_Comments|FILL_VALUE\n- Post3_Title|FILL_VALUE\n- Post3_Upvotes|FILL_VALUE\n- Post3_Comments|FILL_VALUE\n- TopComment_Text|FILL_VALUE\n- TopComment_Username|FILL_VALUE\n- Post1_Author|FILL_VALUE\n- Post2_Author|FILL_VALUE\n- Post3_Author|FILL_VALUE\n```",
  "verify": "import asyncio\nimport sys\nimport re\nimport os\nfrom pathlib import Path\nfrom playwright.async_api import (\n    async_playwright,\n    TimeoutError as PlaywrightTimeoutError,\n)\n\nBASE_URL = os.getenv(\"WEBARENA_BASE_URL\", \"http://localhost:9999\").rstrip(\"/\")\n\n\ndef parse_markdown_list_format(text):\n    \"\"\"\n    Parse the markdown list format (- Key|Value) from the submission body.\n    Also handles plain Key|Value format without the dash.\n    \"\"\"\n    data = {}\n    \n    # Pattern to match lines like: - Key|Value or just Key|Value\n    pattern = r'^(?:-\\s*)?([^|]+)\\|(.+)$'\n    \n    lines = text.strip().split('\\n')\n    for line in lines:\n        line = line.strip()\n        if '|' in line:\n            match = re.match(pattern, line)\n            if match:\n                key = match.group(1).strip()\n                value = match.group(2).strip()\n                data[key] = value\n    \n    return data\n\n\ndef normalize_text(text):\n    \"\"\"\n    Normalize text for comparison by handling different quote styles and whitespace.\n    \"\"\"\n    if not isinstance(text, str):\n        return str(text)\n\n    # Replace various quote styles with standard quotes\n    text = text.replace(\"\"\", \"'\").replace(\"\"\", \"'\")\n    text = text.replace('\"', '\"').replace('\"', '\"')\n\n    # Normalize whitespace\n    text = \" \".join(text.split())\n\n    return text.strip()\n\n\nasync def check_account_login(page):\n    \"\"\"\n    Check if the account can be successfully logged in.\n    Returns True if login successful, False otherwise.\n    \"\"\"\n    try:\n        # Navigate to main page\n        await page.goto(f\"{BASE_URL}/\", wait_until=\"networkidle\")\n        \n        # Check if already logged in\n        user_button = page.locator('button[class*=\"UserButton\"]')\n        if await user_button.count():\n            username = await user_button.inner_text()\n            if username.lower() == \"buyitforlife_researcher\":\n                print(f\"Already logged in as {username}\", file=sys.stderr)\n                return True\n            else:\n                # Log out first\n                await user_button.click()\n                await page.click('a:has-text(\"Log out\")')\n                await page.wait_for_load_state(\"networkidle\")\n        \n        # Try to login\n        await page.click('a:has-text(\"Log in\")')\n        await page.wait_for_load_state(\"networkidle\")\n        \n        await page.fill('input[name=\"_username\"]', \"buyitforlife_researcher\")\n        await page.fill('input[name=\"_password\"]', \"BIFL2024Research!\")\n        \n        await page.click('button:has-text(\"Log in\")')\n        await page.wait_for_load_state(\"networkidle\")\n        \n        # Check if login successful\n        user_button = page.locator('button:has-text(\"buyitforlife_researcher\")')\n        if await user_button.count():\n            print(\"Successfully logged in as buyitforlife_researcher\", file=sys.stderr)\n            return True\n        else:\n            print(\"Login failed for buyitforlife_researcher\", file=sys.stderr)\n            return False\n            \n    except Exception as e:\n        print(f\"Error during login check: {str(e)}\", file=sys.stderr)\n        return False\n\n\nasync def check_submission_exists(page):\n    \"\"\"\n    Check if the submission exists in the BuyItForLife forum with correct content.\n    Returns (exists, content_data) tuple.\n    \"\"\"\n    try:\n        # Navigate to BuyItForLife forum\n        await page.goto(f\"{BASE_URL}/f/BuyItForLife\", wait_until=\"networkidle\")\n        \n        # Look for the post with correct title\n        print(\"Looking for post 'Research Report for BuyItForLife'...\", file=sys.stderr)\n        post_locator = page.locator('a:has-text(\"Research Report for BuyItForLife\")')\n        \n        if not await post_locator.count():\n            print(\"Error: Could not find post with title 'Research Report for BuyItForLife'\", file=sys.stderr)\n            return False, None\n        \n        # Click on the post to view its content\n        await post_locator.first.click()\n        await page.wait_for_load_state(\"networkidle\")\n        \n        # Get the post content\n        post_content = None\n        selectors = [\n            '.PostFullItem-body',\n            '.Post-body',\n            '.PostItem-body',\n            '.item-RichText',\n            '[class*=\"RichText\"]',\n            'div:has-text(\"Post1_Title\")',\n        ]\n        \n        for selector in selectors:\n            post_content_element = page.locator(selector)\n            if await post_content_element.count():\n                # Get the text content, handling multiple elements if needed\n                if await post_content_element.count() > 1:\n                    for i in range(await post_content_element.count()):\n                        text = await post_content_element.nth(i).inner_text()\n                        if \"Post1_Title\" in text:\n                            post_content = text\n                            print(f\"Found post content using selector: {selector} (element {i})\", file=sys.stderr)\n                            break\n                else:\n                    post_content = await post_content_element.first.inner_text()\n                    print(f\"Found post content using selector: {selector}\", file=sys.stderr)\n                \n                if post_content and \"Post1_Title\" in post_content:\n                    break\n        \n        if not post_content:\n            print(\"Error: Could not find post content element\", file=sys.stderr)\n            return False, None\n        \n        print(\"Post content found:\", file=sys.stderr)\n        print(post_content[:200] + \"...\" if len(post_content) > 200 else post_content, file=sys.stderr)\n        \n        # Parse the markdown list format\n        extracted_data = parse_markdown_list_format(post_content)\n        print(f\"Extracted data: {extracted_data}\", file=sys.stderr)\n        \n        return True, extracted_data\n        \n    except Exception as e:\n        print(f\"Error checking submission: {str(e)}\", file=sys.stderr)\n        return False, None\n\n\nasync def verify() -> bool:\n    \"\"\"\n    Verifies that the BuyItForLife research task has been completed correctly.\n    Checks:\n    1. Account creation (can login with credentials)\n    2. Submission exists with correct title\n    3. Submission content matches expected format and values\n    \"\"\"\n    async with async_playwright() as p:\n        browser = await p.chromium.launch(headless=True)\n        context = await browser.new_context()\n        page = await context.new_page()\n        \n        try:\n            # Step 1: Check account creation\n            print(\"=== Step 1: Checking account creation ===\", file=sys.stderr)\n            account_ok = await check_account_login(page)\n            if not account_ok:\n                print(\"Error: Account 'buyitforlife_researcher' cannot be logged in\", file=sys.stderr)\n                return False\n            \n            # Step 2: Check submission exists and get content\n            print(\"\\n=== Step 2: Checking submission ===\", file=sys.stderr)\n            submission_exists, extracted_data = await check_submission_exists(page)\n            \n            if not submission_exists:\n                print(\"Error: Submission not found in BuyItForLife forum\", file=sys.stderr)\n                return False\n            \n            if not extracted_data:\n                print(\"Error: Could not extract data from submission\", file=sys.stderr)\n                return False\n            \n            # Step 3: Load expected data from label.txt\n            print(\"\\n=== Step 3: Validating submission content ===\", file=sys.stderr)\n            label_path = Path(__file__).parent / \"label.txt\"\n            if not label_path.exists():\n                print(\"Error: label.txt not found\", file=sys.stderr)\n                return False\n            \n            with open(label_path, \"r\") as f:\n                expected_text = f.read().strip()\n            expected_data = parse_markdown_list_format(expected_text)\n            print(f\"Expected data from label.txt: {expected_data}\", file=sys.stderr)\n            \n            # Verify all required keys are present\n            required_keys = [\n                \"Post1_Title\",\n                \"Post1_Upvotes\",\n                \"Post1_Comments\",\n                \"Post2_Title\",\n                \"Post2_Upvotes\",\n                \"Post2_Comments\",\n                \"Post3_Title\",\n                \"Post3_Upvotes\",\n                \"Post3_Comments\",\n                \"TopComment_Text\",\n                \"TopComment_Username\",\n                \"Post1_Author\",\n                \"Post2_Author\",\n                \"Post3_Author\",\n            ]\n            \n            missing_keys = []\n            for key in required_keys:\n                if key not in extracted_data:\n                    missing_keys.append(key)\n            \n            if missing_keys:\n                print(f\"Error: Missing required keys: {', '.join(missing_keys)}\", file=sys.stderr)\n                return False\n            \n            # Compare each field with expected values\n            errors = []\n            for key in required_keys:\n                if key in expected_data and key in extracted_data:\n                    expected_val = normalize_text(expected_data[key])\n                    actual_val = normalize_text(extracted_data[key])\n                    \n                    # For numeric fields, compare as integers\n                    if \"Upvotes\" in key or \"Comments\" in key:\n                        try:\n                            expected_int = int(expected_val)\n                            actual_int = int(actual_val)\n                            if expected_int != actual_int:\n                                errors.append(f\"{key} mismatch: got {actual_int}, expected {expected_int}\")\n                        except ValueError:\n                            errors.append(f\"{key} should be numeric: got '{actual_val}'\")\n                    else:\n                        # For text fields, special handling for usernames with underscores\n                        if \"Author\" in key or key == \"TopComment_Username\":\n                            expected_core = expected_val.strip('_')\n                            actual_core = actual_val.strip('_')\n                            if expected_core != actual_core:\n                                errors.append(f\"{key} mismatch: got '{actual_val}', expected '{expected_val}'\")\n                        else:\n                            if expected_val != actual_val:\n                                errors.append(f\"{key} mismatch: got '{actual_val}', expected '{expected_val}'\")\n            \n            # Verify upvotes are in descending order\n            try:\n                post1_votes = int(extracted_data[\"Post1_Upvotes\"])\n                post2_votes = int(extracted_data[\"Post2_Upvotes\"])\n                post3_votes = int(extracted_data[\"Post3_Upvotes\"])\n                \n                if not (post1_votes >= post2_votes >= post3_votes):\n                    errors.append(f\"Posts should be ordered by upvotes: {post1_votes} >= {post2_votes} >= {post3_votes}\")\n            except (ValueError, KeyError):\n                pass  # Already reported above\n            \n            if errors:\n                print(\"Error: Validation failed with the following issues:\", file=sys.stderr)\n                for error in errors:\n                    print(f\"  - {error}\", file=sys.stderr)\n                return False\n            \n            # All checks passed\n            print(\"\\n=== SUCCESS ===\", file=sys.stderr)\n            print(\"✓ Account 'buyitforlife_researcher' created and can login\", file=sys.stderr)\n            print(\"✓ Submission 'Research Report for BuyItForLife' found in correct forum\", file=sys.stderr)\n            print(\"✓ All 14 required fields present and correct\", file=sys.stderr)\n            print(\"✓ Data matches expected values from label.txt\", file=sys.stderr)\n            print(\"✓ Posts ordered by upvotes (descending)\", file=sys.stderr)\n            return True\n            \n        except PlaywrightTimeoutError as e:\n            print(f\"Error: Timeout occurred - {str(e)}\", file=sys.stderr)\n            return False\n        except Exception as e:\n            print(f\"Error: Unexpected error - {str(e)}\", file=sys.stderr)\n            return False\n        finally:\n            await browser.close()\n\n\ndef main():\n    \"\"\"\n    Executes the verification process and exits with a status code.\n    \"\"\"\n    result = asyncio.run(verify())\n    sys.exit(0 if result else 1)\n\n\nif __name__ == \"__main__\":\n    main()"
}